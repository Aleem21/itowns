/**
 * @author mrdoob / http://mrdoob.com/
 * @author Larry Battle / http://bateru.com/news
 * @author bhouston / http://exocortex.com
 */
define('lib/three',[],function () {
var THREE = { REVISION: '63' };

self.console = self.console || {

	info: function () {},
	log: function () {},
	debug: function () {},
	warn: function () {},
	error: function () {}

};

String.prototype.trim = String.prototype.trim || function () {

	return this.replace( /^\s+|\s+$/g, '' );

};

// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767
THREE.extend = function ( obj, source ) {

	// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/
	if ( Object.keys ) {

		var keys = Object.keys( source );

		for (var i = 0, il = keys.length; i < il; i++) {

			var prop = keys[i];
			Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );

		}

	} else {

		var safeHasOwnProperty = {}.hasOwnProperty;

		for ( var prop in source ) {

			if ( safeHasOwnProperty.call( source, prop ) ) {

				obj[prop] = source[prop];

			}

		}

	}

	return obj;

};

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik MÃ¶ller
// fixes from Paul Irish and Tino Zijdel
// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.
( function () {

	var lastTime = 0;
	var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

	for ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {

		self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
		self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

	}

	if ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {

		self.requestAnimationFrame = function ( callback ) {

			var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
			var id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );
			lastTime = currTime + timeToCall;
			return id;

		};

	}

	if( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {

		self.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };

	}

}() );

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;

/*
// Potential future PVRTC compressed texture formats
THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
*/

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( value ) {

	if ( value !== undefined ) this.set( value );

	return this;

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function () {

		var hsl = { h: 0, s: 0, l: 0 };

		return function () {

			// h,s,l ranges are in 0.0 - 1.0

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		};

	}(),

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array ) {

		this.r = array[ 0 ];
		this.g = array[ 1 ];
		this.b = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.r, this.g, this.b ];

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};

THREE.ColorKeywords = { "aliceblue": 0xF0F8FF, "antiquewhite": 0xFAEBD7, "aqua": 0x00FFFF, "aquamarine": 0x7FFFD4, "azure": 0xF0FFFF,
"beige": 0xF5F5DC, "bisque": 0xFFE4C4, "black": 0x000000, "blanchedalmond": 0xFFEBCD, "blue": 0x0000FF, "blueviolet": 0x8A2BE2,
"brown": 0xA52A2A, "burlywood": 0xDEB887, "cadetblue": 0x5F9EA0, "chartreuse": 0x7FFF00, "chocolate": 0xD2691E, "coral": 0xFF7F50,
"cornflowerblue": 0x6495ED, "cornsilk": 0xFFF8DC, "crimson": 0xDC143C, "cyan": 0x00FFFF, "darkblue": 0x00008B, "darkcyan": 0x008B8B,
"darkgoldenrod": 0xB8860B, "darkgray": 0xA9A9A9, "darkgreen": 0x006400, "darkgrey": 0xA9A9A9, "darkkhaki": 0xBDB76B, "darkmagenta": 0x8B008B,
"darkolivegreen": 0x556B2F, "darkorange": 0xFF8C00, "darkorchid": 0x9932CC, "darkred": 0x8B0000, "darksalmon": 0xE9967A, "darkseagreen": 0x8FBC8F,
"darkslateblue": 0x483D8B, "darkslategray": 0x2F4F4F, "darkslategrey": 0x2F4F4F, "darkturquoise": 0x00CED1, "darkviolet": 0x9400D3,
"deeppink": 0xFF1493, "deepskyblue": 0x00BFFF, "dimgray": 0x696969, "dimgrey": 0x696969, "dodgerblue": 0x1E90FF, "firebrick": 0xB22222,
"floralwhite": 0xFFFAF0, "forestgreen": 0x228B22, "fuchsia": 0xFF00FF, "gainsboro": 0xDCDCDC, "ghostwhite": 0xF8F8FF, "gold": 0xFFD700,
"goldenrod": 0xDAA520, "gray": 0x808080, "green": 0x008000, "greenyellow": 0xADFF2F, "grey": 0x808080, "honeydew": 0xF0FFF0, "hotpink": 0xFF69B4,
"indianred": 0xCD5C5C, "indigo": 0x4B0082, "ivory": 0xFFFFF0, "khaki": 0xF0E68C, "lavender": 0xE6E6FA, "lavenderblush": 0xFFF0F5, "lawngreen": 0x7CFC00,
"lemonchiffon": 0xFFFACD, "lightblue": 0xADD8E6, "lightcoral": 0xF08080, "lightcyan": 0xE0FFFF, "lightgoldenrodyellow": 0xFAFAD2, "lightgray": 0xD3D3D3,
"lightgreen": 0x90EE90, "lightgrey": 0xD3D3D3, "lightpink": 0xFFB6C1, "lightsalmon": 0xFFA07A, "lightseagreen": 0x20B2AA, "lightskyblue": 0x87CEFA,
"lightslategray": 0x778899, "lightslategrey": 0x778899, "lightsteelblue": 0xB0C4DE, "lightyellow": 0xFFFFE0, "lime": 0x00FF00, "limegreen": 0x32CD32,
"linen": 0xFAF0E6, "magenta": 0xFF00FF, "maroon": 0x800000, "mediumaquamarine": 0x66CDAA, "mediumblue": 0x0000CD, "mediumorchid": 0xBA55D3,
"mediumpurple": 0x9370DB, "mediumseagreen": 0x3CB371, "mediumslateblue": 0x7B68EE, "mediumspringgreen": 0x00FA9A, "mediumturquoise": 0x48D1CC,
"mediumvioletred": 0xC71585, "midnightblue": 0x191970, "mintcream": 0xF5FFFA, "mistyrose": 0xFFE4E1, "moccasin": 0xFFE4B5, "navajowhite": 0xFFDEAD,
"navy": 0x000080, "oldlace": 0xFDF5E6, "olive": 0x808000, "olivedrab": 0x6B8E23, "orange": 0xFFA500, "orangered": 0xFF4500, "orchid": 0xDA70D6,
"palegoldenrod": 0xEEE8AA, "palegreen": 0x98FB98, "paleturquoise": 0xAFEEEE, "palevioletred": 0xDB7093, "papayawhip": 0xFFEFD5, "peachpuff": 0xFFDAB9,
"peru": 0xCD853F, "pink": 0xFFC0CB, "plum": 0xDDA0DD, "powderblue": 0xB0E0E6, "purple": 0x800080, "red": 0xFF0000, "rosybrown": 0xBC8F8F,
"royalblue": 0x4169E1, "saddlebrown": 0x8B4513, "salmon": 0xFA8072, "sandybrown": 0xF4A460, "seagreen": 0x2E8B57, "seashell": 0xFFF5EE,
"sienna": 0xA0522D, "silver": 0xC0C0C0, "skyblue": 0x87CEEB, "slateblue": 0x6A5ACD, "slategray": 0x708090, "slategrey": 0x708090, "snow": 0xFFFAFA,
"springgreen": 0x00FF7F, "steelblue": 0x4682B4, "tan": 0xD2B48C, "teal": 0x008080, "thistle": 0xD8BFD8, "tomato": 0xFF6347, "turquoise": 0x40E0D0,
"violet": 0xEE82EE, "wheat": 0xF5DEB3, "white": 0xFFFFFF, "whitesmoke": 0xF5F5F5, "yellow": 0xFFFF00, "yellowgreen": 0x9ACD32 };

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	_euler: undefined,

	_updateEuler: function ( callback ) {

		if ( this._euler !== undefined ) {

			this._euler.setFromQuaternion( this, undefined, false );

		}

	},

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this._updateEuler();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this._updateEuler();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this._updateEuler();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this._updateEuler();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._updateEuler();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion._x;
		this._y = quaternion._y;
		this._z = quaternion._z;
		this._w = quaternion._w;

		this._updateEuler();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );
		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this._updateEuler();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
		// axis have to be normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._updateEuler();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = (m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = (m12 + m21 ) / s;
			this._z = (m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = (m13 - m31 ) / s;
			this._x = (m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = (m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._updateEuler();

		return this;

	},

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= -1;
		this._y *= -1;
		this._z *= -1;

		this._updateEuler();

		return this;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._updateEuler();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = -qb._w;
			this._x = -qb._x;
			this._y = -qb._y;
			this._z = -qb._z;

			cosHalfTheta = -cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._updateEuler();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		this._w = array[ 3 ];

		this._updateEuler();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._w ];

	},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},


	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;

	},

	negate: function() {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y ];

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[3] * y + e[6] * z;
		this.y = e[1] * x + e[4] * y + e[7] * z;
		this.z = e[2] * x + e[5] * y + e[8] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
		this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide

		this.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
		this.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
		this.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = -qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

		return this;

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z;
		this.y = e[1] * x + e[5] * y + e[9]  * z;
		this.z = e[2] * x + e[6] * y + e[10] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	negate: function () {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( "REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.");

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( "REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.");

	},

	getPositionFromMatrix: function ( m ) {

		this.x = m.elements[12];
		this.y = m.elements[13];
		this.z = m.elements[14];

		return this;

	},

	getScaleFromMatrix: function ( m ) {

		var sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();
		var sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();
		var sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	getColumnFromMatrix: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];
		this.z = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y, this.z ];

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};

THREE.extend( THREE.Vector3.prototype, {

	applyEuler: function () {

		var quaternion = new THREE.Quaternion();

		return function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );

			}

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion = new THREE.Quaternion();

		return function ( axis, angle ) {

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	projectOnVector: function () {

		var v1 = new THREE.Vector3();

		return function ( vector ) {

			v1.copy( vector ).normalize();
			var d = this.dot( v1 );
			return this.copy( v1 ).multiplyScalar( d );

		};

	}(),

	projectOnPlane: function () {

		var v1 = new THREE.Vector3();

		return function ( planeNormal ) {

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		var v1 = new THREE.Vector3();

		return function ( vector ) {

		    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );

		    return this.subVectors( v1, this );

		}

	}()

} );

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
		this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
		this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;
			this.w *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		  && ( Math.abs( m13 - m31 ) < epsilon )
		  && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			  && ( Math.abs( m13 + m31 ) < epsilon2 )
			  && ( Math.abs( m23 + m32 ) < epsilon2 )
			  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						 + ( m13 - m31 ) * ( m13 - m31 )
						 + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	negate: function() {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );

		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];
		this.z = array[ 2 ];
		this.w = array[ 3 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y, this.z, this.w ];

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	_quaternion: undefined,

	_updateQuaternion: function () {

		if ( this._quaternion !== undefined ) {

			this._quaternion.setFromEuler( this, false );

		}

	},

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this._updateQuaternion();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this._updateQuaternion();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this._updateQuaternion();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this._updateQuaternion();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._updateQuaternion();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._updateQuaternion();

		return this;

	},

	setFromRotationMatrix: function ( m, order ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		var te = m.elements;
		var m11 = te[0], m12 = te[4], m13 = te[8];
		var m21 = te[1], m22 = te[5], m23 = te[9];
		var m31 = te[2], m32 = te[6], m33 = te[10];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		this._updateQuaternion();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		// q is assumed to be normalized

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

		var sqx = q.x * q.x;
		var sqy = q.y * q.y;
		var sqz = q.z * q.z;
		var sqw = q.w * q.w;

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order ===  'YXZ' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZYX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order === 'YZX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );

		} else if ( order === 'XZY' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );

		} else {

			console.warn( 'WARNING: Euler.setFromQuaternion() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this._updateQuaternion();

		return this;

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};


	}(),

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._updateQuaternion();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function() {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	},

	clone: function () {

		return new THREE.Line3().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				point = points[ i ];

				if ( point.x < this.min.x ) {

					this.min.x = point.x;

				} else if ( point.x > this.max.x ) {

					this.max.x = point.x;

				}

				if ( point.y < this.min.y ) {

					this.min.y = point.y;

				} else if ( point.y > this.max.y ) {

					this.max.y = point.y;

				}

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return new THREE.Vector2(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	addPoint: function ( point ) {

		if ( point.x < this.min.x ) {

			this.min.x = point.x;

		} else if ( point.x > this.max.x ) {

			this.max.x = point.x;

		}

		if ( point.y < this.min.y ) {

			this.min.y = point.y;

		} else if ( point.y > this.max.y ) {

			this.max.y = point.y;

		}

		if ( point.z < this.min.z ) {

			this.min.z = point.z;

		} else if ( point.z > this.max.z ) {

			this.max.z = point.z;

		}

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				this.addPoint( points[ i ] )

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function() {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function() {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and childrens', world transforms

		var v1 = new THREE.Vector3();

		return function( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				if ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {

					var vertices = node.geometry.vertices;

					for ( var i = 0, il = vertices.length; i < il; i++ ) {

						v1.copy( vertices[ i ] );

						v1.applyMatrix4( node.matrixWorld );

						scope.expandByPoint( v1 );

					}

				}

			} );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return new THREE.Vector3(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function() {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function() {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function() {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

	this.elements = new Float32Array(9);

	this.set(

		( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,
		n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,
		n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1

	);
};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[0] = n11; te[3] = n12; te[6] = n13;
		te[1] = n21; te[4] = n22; te[7] = n23;
		te[2] = n31; te[5] = n32; te[8] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[0], me[3], me[6],
			me[1], me[4], me[7],
			me[2], me[5], me[8]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyMatrix3(this);

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[3] *= s; te[6] *= s;
		te[1] *= s; te[4] *= s; te[7] *= s;
		te[2] *= s; te[5] *= s; te[8] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[0], b = te[1], c = te[2],
			d = te[3], e = te[4], f = te[5],
			g = te[6], h = te[7], i = te[8];

		return a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
		te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
		te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
		te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
		te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
		te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
		te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
		te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
		te[ 8 ] =   me[5] * me[0] - me[1] * me[4];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[1]; m[1] = m[3]; m[3] = tmp;
		tmp = m[2]; m[2] = m[6]; m[6] = tmp;
		tmp = m[5]; m[5] = m[7]; m[7] = tmp;

		return this;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix3(

			te[0], te[3], te[6],
			te[1], te[4], te[7],
			te[2], te[5], te[8]

		);

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */


THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

	this.elements = new Float32Array( 16 );

	// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix
	//   we should not support semi specification of Matrix4, it is just weird.

	var te = this.elements;

	te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
	te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
	te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
	te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
		te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
		te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
		te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];

		return this;

	},

	extractRotation: function () {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();
			var scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();
			var scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;

			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;

			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = - c * f;
			te[8] = d;

			te[1] = af + be * d;
			te[5] = ae - bf * d;
			te[9] = - b * c;

			te[2] = bf - ae * d;
			te[6] = be + af * d;
			te[10] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce + df * b;
			te[4] = de * b - cf;
			te[8] = a * d;

			te[1] = a * f;
			te[5] = a * e;
			te[9] = - b;

			te[2] = cf * b - de;
			te[6] = df + ce * b;
			te[10] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce - df * b;
			te[4] = - a * f;
			te[8] = de + cf * b;

			te[1] = cf + de * b;
			te[5] = a * e;
			te[9] = df - ce * b;

			te[2] = - a * d;
			te[6] = b;
			te[10] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = be * d - af;
			te[8] = ae * d + bf;

			te[1] = c * f;
			te[5] = bf * d + ae;
			te[9] = af * d - be;

			te[2] = - d;
			te[6] = b * c;
			te[10] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = bd - ac * f;
			te[8] = bc * f + ad;

			te[1] = f;
			te[5] = a * e;
			te[9] = - b * e;

			te[2] = - d * e;
			te[6] = ad * f + bc;
			te[10] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = - f;
			te[8] = d * e;

			te[1] = ac * f + bd;
			te[5] = a * e;
			te[9] = ad * f - bc;

			te[2] = bc * f - ad;
			te[6] = b * e;
			te[10] = bd * f + ac;

		}

		// last column
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// bottom row
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[0] = 1 - ( yy + zz );
		te[4] = xy - wz;
		te[8] = xz + wy;

		te[1] = xy + wz;
		te[5] = 1 - ( xx + zz );
		te[9] = yz - wx;

		te[2] = xz - wy;
		te[6] = yz + wx;
		te[10] = 1 - ( xx + yy );

		// last column
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// bottom row
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;

		return this;

	},

	lookAt: function() {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[0] = x.x; te[4] = y.x; te[8] = z.x;
			te[1] = x.y; te[5] = y.y; te[9] = z.y;
			te[2] = x.z; te[6] = y.z; te[10] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
		var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
		var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
		var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

		var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
		var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
		var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
		var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

		te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];
		r[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];
		r[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];
		r[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
		te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
		te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
		te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyProjection( this );

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
		var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
		var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
		var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+n14 * n23 * n32
				-n13 * n24 * n32
				-n14 * n22 * n33
				+n12 * n24 * n33
				+n13 * n22 * n34
				-n12 * n23 * n34
			) +
			n42 * (
				+n11 * n23 * n34
				-n11 * n24 * n33
				+n14 * n21 * n33
				-n13 * n21 * n34
				+n13 * n24 * n31
				-n14 * n23 * n31
			) +
			n43 * (
				+n11 * n24 * n32
				-n11 * n22 * n34
				-n14 * n21 * n32
				+n12 * n21 * n34
				+n14 * n22 * n31
				-n12 * n24 * n31
			) +
			n44 * (
				-n13 * n22 * n31
				-n11 * n23 * n32
				+n11 * n22 * n33
				+n13 * n21 * n32
				-n12 * n21 * n33
				+n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[1]; te[1] = te[4]; te[4] = tmp;
		tmp = te[2]; te[2] = te[8]; te[8] = tmp;
		tmp = te[6]; te[6] = te[9]; te[9] = tmp;

		tmp = te[3]; te[3] = te[12]; te[12] = tmp;
		tmp = te[7]; te[7] = te[13]; te[13] = tmp;
		tmp = te[11]; te[11] = te[14]; te[14] = tmp;

		return this;

	},

	flattenToArray: function ( flat ) {

		var te = this.elements;
		flat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];
		flat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];
		flat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];
		flat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];

		return flat;

	},

	flattenToArrayOffset: function( flat, offset ) {

		var te = this.elements;
		flat[ offset ] = te[0];
		flat[ offset + 1 ] = te[1];
		flat[ offset + 2 ] = te[2];
		flat[ offset + 3 ] = te[3];

		flat[ offset + 4 ] = te[4];
		flat[ offset + 5 ] = te[5];
		flat[ offset + 6 ] = te[6];
		flat[ offset + 7 ] = te[7];

		flat[ offset + 8 ]  = te[8];
		flat[ offset + 9 ]  = te[9];
		flat[ offset + 10 ] = te[10];
		flat[ offset + 11 ] = te[11];

		flat[ offset + 12 ] = te[12];
		flat[ offset + 13 ] = te[13];
		flat[ offset + 14 ] = te[14];
		flat[ offset + 15 ] = te[15];

		return flat;

	},

	getPosition: function() {

		var v1 = new THREE.Vector3();

		return function () {

			console.warn( 'DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[12], te[13], te[14] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[12] = v.x;
		te[13] = v.y;
		te[14] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
		var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
		var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
		var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];

		te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
		te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
		te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
		te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
		te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
		te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
		te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
		te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
		te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
		te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
		te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
		te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
		te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
		te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
		te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
		te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.warn( 'DEPRECATED: Matrix4\'s .translate() has been removed.');

	},

	rotateX: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateX() has been removed.');

	},

	rotateY: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateY() has been removed.');

	},

	rotateZ: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateZ() has been removed.');

	},

	rotateByAxis: function ( axis, angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[0] *= x; te[4] *= y; te[8] *= z;
		te[1] *= x; te[5] *= y; te[9] *= z;
		te[2] *= x; te[6] *= y; te[10] *= z;
		te[3] *= x; te[7] *= y; te[11] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
		var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
		var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, -s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			-s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, -s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new THREE.Vector3();
		var matrix = new THREE.Matrix4();

		return function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[0], te[1], te[2] ).length();
			var sy = vector.set( te[4], te[5], te[6] ).length();
			var sz = vector.set( te[8], te[9], te[10] ).length();

			position.x = te[12];
			position.y = te[13];
			position.z = te[14];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[0] *= invSX;
			matrix.elements[1] *= invSX;
			matrix.elements[2] *= invSX;

			matrix.elements[4] *= invSY;
			matrix.elements[5] *= invSY;
			matrix.elements[6] *= invSY;

			matrix.elements[8] *= invSZ;
			matrix.elements[9] *= invSZ;
			matrix.elements[10] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[0] = x;	te[4] = 0;	te[8] = a;	te[12] = 0;
		te[1] = 0;	te[5] = y;	te[9] = b;	te[13] = 0;
		te[2] = 0;	te[6] = 0;	te[10] = c;	te[14] = d;
		te[3] = 0;	te[7] = 0;	te[11] = - 1;	te[15] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[0] = 2 / w;	te[4] = 0;	te[8] = 0;	te[12] = -x;
		te[1] = 0;	te[5] = 2 / h;	te[9] = 0;	te[13] = -y;
		te[2] = 0;	te[6] = 0;	te[10] = -2/p;	te[14] = -z;
		te[3] = 0;	te[7] = 0;	te[11] = 0;	te[15] = 1;

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix4(

			te[0], te[4], te[8], te[12],
			te[1], te[5], te[9], te[13],
			te[2], te[6], te[10], te[14],
			te[3], te[7], te[11], te[15]

		);

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceTo( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	distanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
		var segDir = v1.clone().sub( v0 ).normalize();
		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var diff = this.origin.clone().sub( segCenter );
		var a01 = - this.direction.dot( segDir );
		var b0 = diff.dot( this.direction );
		var b1 = - diff.dot( segDir );
		var c = diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det >= 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

		}

		return sqrDist;

	},

	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;
		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		}

	}(),

	intersectBox: function ( box , optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin,tmax,tymin,tymax,tzmin,tzmax;

		var invdirx = 1/this.direction.x,
			invdiry = 1/this.direction.y,
			invdirz = 1/this.direction.z;

		var origin = this.origin;

		if (invdirx >= 0) {

			tmin = (box.min.x - origin.x) * invdirx;
			tmax = (box.max.x - origin.x) * invdirx;

		} else {

			tmin = (box.max.x - origin.x) * invdirx;
			tmax = (box.min.x - origin.x) * invdirx;
		}

		if (invdiry >= 0) {

			tymin = (box.min.y - origin.y) * invdiry;
			tymax = (box.max.y - origin.y) * invdiry;

		} else {

			tymin = (box.max.y - origin.y) * invdiry;
			tymax = (box.min.y - origin.y) * invdiry;
		}

		if ((tmin > tymax) || (tymin > tmax)) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if (tymin > tmin || tmin !== tmin ) tmin = tymin;

		if (tymax < tmax || tmax !== tmax ) tmax = tymax;

		if (invdirz >= 0) {

			tzmin = (box.min.z - origin.z) * invdirz;
			tzmax = (box.max.z - origin.z) * invdirz;

		} else {

			tzmin = (box.max.z - origin.z) * invdirz;
			tzmax = (box.min.z - origin.z) * invdirz;
		}

		if ((tmin > tzmax) || (tzmin > tmax)) return null;

		if (tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if (tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function() {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		}

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},


	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter )  {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

 		};

	}(),

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[0].copy( p0 );
		planes[1].copy( p1 );
		planes[2].copy( p2 );
		planes[3].copy( p3 );
		planes[4].copy( p4 );
		planes[5].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for( var i = 0; i < 6; i ++ ) {

			planes[i].copy( frustum.planes[i] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
		var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
		var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
		var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = -sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox : function() {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[i];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}
			}

			return true;
		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= -1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function() {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			optionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( optionalNormalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	PI2: Math.PI * 2,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
		var uuid = new Array(36);
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

					uuid[ i ] = '-';

				} else if ( i == 14 ) {

					uuid[ i ] = '4';

				} else {

					if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];

				}
			}

			return uuid.join('');

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*(3 - 2*x);

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*x*(x*(x*6 - 15) + 10);

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	sign: function ( x ) {

		return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );

	},

	degToRad: function() {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function() {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}()

};

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( !nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function() {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function() {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( -2, -1, -1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function() {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[i0] );
		this.b.copy( points[i1] );
		this.c.copy( points[i2] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function() {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Vertex = function ( v ) {

	console.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')
	return v;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.UV = function ( u, v ) {

	console.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')
	return new THREE.Vector2( u, v );

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var index = listeners[ type ].indexOf( listener );

		if ( index !== - 1 ) {

			listeners[ type ].splice( index, 1 );

		}

	},

	dispatchEvent: function () {

		var array = [];

		return function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		};

	}()

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

	};

	var sphere = new THREE.Sphere();
	var localRay = new THREE.Ray();
	var facePlane = new THREE.Plane();
	var intersectPoint = new THREE.Vector3();
	var matrixPosition = new THREE.Vector3();

	var inverseMatrix = new THREE.Matrix4();

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	var intersectObject = function ( object, raycaster, intersects ) {

		if ( object instanceof THREE.Sprite ) {

			matrixPosition.getPositionFromMatrix( object.matrixWorld );
			var distance = raycaster.ray.distanceToPoint( matrixPosition );

			if ( distance > object.scale.x ) {

				return intersects;

			}

			intersects.push( {

				distance: distance,
				point: object.position,
				face: null,
				object: object

			} );

		} else if ( object instanceof THREE.LOD ) {

			matrixPosition.getPositionFromMatrix( object.matrixWorld );
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			intersectObject( object.getObjectForDistance( distance ), raycaster, intersects );

		} else if ( object instanceof THREE.Mesh ) {

			var geometry = object.geometry;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return intersects;

			}

			// Check boundingBox before continuing

			inverseMatrix.getInverse( object.matrixWorld );
			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {

					return intersects;

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var material = object.material;

				if ( material === undefined ) return intersects;
				if ( geometry.dynamic === false ) return intersects;

				var a, b, c;
				var precision = raycaster.precision;

				if ( geometry.attributes.index !== undefined ) {

					var offsets = geometry.offsets;
					var indices = geometry.attributes.index.array;
					var positions = geometry.attributes.position.array;
					var offLength = geometry.offsets.length;

					var fl = geometry.attributes.index.array.length / 3;

					for ( var oi = 0; oi < offLength; ++oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							a = index + indices[ i ];
							b = index + indices[ i + 1 ];
							c = index + indices[ i + 2 ];

							vA.set(
								positions[ a * 3 ],
								positions[ a * 3 + 1 ],
								positions[ a * 3 + 2 ]
							);
							vB.set(
								positions[ b * 3 ],
								positions[ b * 3 + 1 ],
								positions[ b * 3 + 2 ]
							);
							vC.set(
								positions[ c * 3 ],
								positions[ c * 3 + 1 ],
								positions[ c * 3 + 2 ]
							);


							if ( material.side === THREE.BackSide ) {

								var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true );

							} else {

								var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

							}

							if ( intersectionPoint === null ) continue;

							intersectionPoint.applyMatrix4( object.matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								point: intersectionPoint,
								face: null,
								faceIndex: null,
								object: object

							} );

						}

					}

				} else {

					var offsets = geometry.offsets;
					var positions = geometry.attributes.position.array;
					var offLength = geometry.offsets.length;

					var fl = geometry.attributes.position.array.length;

					for ( var i = 0; i < fl; i += 3 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						vA.set(
							positions[ a * 3 ],
							positions[ a * 3 + 1 ],
							positions[ a * 3 + 2 ]
						);
						vB.set(
							positions[ b * 3 ],
							positions[ b * 3 + 1 ],
							positions[ b * 3 + 2 ]
						);
						vC.set(
							positions[ c * 3 ],
							positions[ c * 3 + 1 ],
							positions[ c * 3 + 2 ]
						);


						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( object.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: null,
							faceIndex: null,
							object: object

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? object.material.materials : null;

				var a, b, c, d;
				var precision = raycaster.precision;

				var vertices = geometry.vertices;

				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

					var face = geometry.faces[ f ];

					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;

					if ( material === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = localRay.intersectTriangle( c, b, a, true );

					} else {

						var intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: face,
						faceIndex: f,
						object: object

					} );

				}

			}

		} else if ( object instanceof THREE.Line ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return intersects;

			}

			inverseMatrix.getInverse( object.matrixWorld );
			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			/* if ( geometry instanceof THREE.BufferGeometry ) {

			} else */ if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
				var interSegment = new THREE.Vector3();
				var interRay = new THREE.Vector3();
				var step = object.type === THREE.LineStrip ? 1 : 2;

				for ( var i = 0; i < nbVertices - 1; i = i + step ) {

					var distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					var distance = localRay.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( object.matrixWorld ),
						face: null,
						faceIndex: null,
						object: object

					} );

				}

			}

		}

	};

	var intersectDescendants = function ( object, raycaster, intersects ) {

		var descendants = object.getDescendants();

		for ( var i = 0, l = descendants.length; i < l; i ++ ) {

			intersectObject( descendants[ i ], raycaster, intersects );

		}
	};

	//

	THREE.Raycaster.prototype.precision = 0.0001;
	THREE.Raycaster.prototype.linePrecision = 1;

	THREE.Raycaster.prototype.set = function ( origin, direction ) {

		this.ray.set( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

	};

	THREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {

		var intersects = [];

		if ( recursive === true ) {

			intersectDescendants( object, this, intersects );

		}

		intersectObject( object, this, intersects );

		intersects.sort( descSort );

		return intersects;

	};

	THREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {

		var intersects = [];

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects );

			if ( recursive === true ) {

				intersectDescendants( objects[ i ], this, intersects );

			}

		}

		intersects.sort( descSort );

		return intersects;

	};

}( THREE ) );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

	this.id = THREE.Object3DIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.parent = undefined;
	this.children = [];

	this.up = new THREE.Vector3( 0, 1, 0 );

	this.position = new THREE.Vector3();
	this._rotation = new THREE.Euler();
	this._quaternion = new THREE.Quaternion();
	this.scale = new THREE.Vector3( 1, 1, 1 );

	// keep rotation and quaternion in sync

	this._rotation._quaternion = this.quaternion;
	this._quaternion._euler = this.rotation;

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = true;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this.userData = {};

};


THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get rotation () {
		return this._rotation;
	},

	set rotation ( value ) {

		this._rotation = value;
		this._rotation._quaternion = this._quaternion;
		this._quaternion._euler = this._rotation;
		this._rotation._updateQuaternion();

	},

	get quaternion () {
		return this._quaternion;
	},

	set quaternion ( value ) {

		this._quaternion = value;
		this._quaternion._euler = this._rotation;
		this._rotation._quaternion = this._quaternion;
		this._quaternion._updateEuler();

	},

	get eulerOrder () {

		console.warn( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	applyMatrix: function () {

		var m1 = new THREE.Matrix4();

		return function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.position.getPositionFromMatrix( this.matrix );

			this.scale.getScaleFromMatrix( this.matrix );

			m1.extractRotation( this.matrix );

			this.quaternion.setFromRotationMatrix( m1 );

		}

	}(),

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function() {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		}

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis );

			v1.applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		}

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( object === this ) {

			console.warn( 'THREE.Object3D.add: An object can\'t be added as a child of itself.' );
			return;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

			// add to scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene )  {

				scene.__addObject( object );

			}

		}

	},

	remove: function ( object ) {

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;
			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

			// remove from scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene ) {

				scene.__removeObject( object );

			}

		}

	},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	getObjectById: function ( id, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.id === id ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getObjectById( id, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getObjectByName: function ( name, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.name === name ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getObjectByName( name, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getChildByName: function ( name, recursive ) {

		console.warn( 'DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name, recursive );

	},

	getDescendants: function ( array ) {

		if ( array === undefined ) array = [];

		Array.prototype.push.apply( array, this.children );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].getDescendants( array );

		}

		return array;

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	clone: function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Object3D();
		if ( recursive === undefined ) recursive = true;

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		object.quaternion.copy( this.quaternion );
		object.scale.copy( this.scale );

		object.renderDepth = this.renderDepth;

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		object.userData = JSON.parse( JSON.stringify( this.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var child = this.children[ i ];
				object.add( child.clone() );

			}

		}

		return object;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.Projector = function () {

	var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
	_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
	_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,
	_line, _lineCount, _linePool = [], _linePoolLength = 0,
	_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

	_renderData = { objects: [], sprites: [], lights: [], elements: [] },

	_vector3 = new THREE.Vector3(),
	_vector4 = new THREE.Vector4(),

	_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),
	_boundingBox = new THREE.Box3(),
	_points3 = new Array( 3 ),
	_points4 = new Array( 4 ),

	_viewMatrix = new THREE.Matrix4(),
	_viewProjectionMatrix = new THREE.Matrix4(),

	_modelMatrix,
	_modelViewProjectionMatrix = new THREE.Matrix4(),

	_normalMatrix = new THREE.Matrix3(),
	_normalViewMatrix = new THREE.Matrix3(),

	_centroid = new THREE.Vector3(),

	_frustum = new THREE.Frustum(),

	_clippedVertex1PositionScreen = new THREE.Vector4(),
	_clippedVertex2PositionScreen = new THREE.Vector4();

	this.projectVector = function ( vector, camera ) {

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );

		return vector.applyProjection( _viewProjectionMatrix );

	};

	this.unprojectVector = function ( vector, camera ) {

		camera.projectionMatrixInverse.getInverse( camera.projectionMatrix );

		_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, camera.projectionMatrixInverse );

		return vector.applyProjection( _viewProjectionMatrix );

	};

	this.pickingRay = function ( vector, camera ) {

		// set two vectors with opposing z values
		vector.z = -1.0;
		var end = new THREE.Vector3( vector.x, vector.y, 1.0 );

		this.unprojectVector( vector, camera );
		this.unprojectVector( end, camera );

		// find direction from vector to end
		end.sub( vector ).normalize();

		return new THREE.Raycaster( vector, end );

	};

	var getObject = function ( object ) {

		_object = getNextObjectInPool();
		_object.id = object.id;
		_object.object = object;

		if ( object.renderDepth !== null ) {

			_object.z = object.renderDepth;

		} else {

			_vector3.getPositionFromMatrix( object.matrixWorld );
			_vector3.applyProjection( _viewProjectionMatrix );
			_object.z = _vector3.z;

		}

		return _object;

	};

	var projectObject = function ( object ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Light ) {

			_renderData.lights.push( object );

		} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {

			if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

				_renderData.objects.push( getObject( object ) );

			}

		} else if ( object instanceof THREE.Sprite ) {

			_renderData.sprites.push( getObject( object ) );

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			projectObject( object.children[ i ] );

		}

	};

	var projectGraph = function ( root, sortObjects ) {

		_objectCount = 0;

		_renderData.objects.length = 0;
		_renderData.sprites.length = 0;
		_renderData.lights.length = 0;

		projectObject( root );

		if ( sortObjects === true ) {

			_renderData.objects.sort( painterSort );

		}

	};

	this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

		var visible = false,
		o, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,
		geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,
		v1, v2, v3, v4, isFaceMaterial, objectMaterials;

		_face3Count = 0;
		_lineCount = 0;
		_spriteCount = 0;

		_renderData.elements.length = 0;

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

		_normalViewMatrix.getNormalMatrix( _viewMatrix );

		_frustum.setFromMatrix( _viewProjectionMatrix );

		projectGraph( scene, sortObjects );

		for ( o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {

			object = _renderData.objects[ o ].object;

			_modelMatrix = object.matrixWorld;

			_vertexCount = 0;

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				vertices = geometry.vertices;
				faces = geometry.faces;
				faceVertexUvs = geometry.faceVertexUvs;

				_normalMatrix.getNormalMatrix( _modelMatrix );

				isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
				objectMaterials = isFaceMaterial === true ? object.material : null;

				for ( v = 0, vl = vertices.length; v < vl; v ++ ) {

					_vertex = getNextVertexInPool();

					_vertex.positionWorld.copy( vertices[ v ] ).applyMatrix4( _modelMatrix );
					_vertex.positionScreen.copy( _vertex.positionWorld ).applyMatrix4( _viewProjectionMatrix );

					var invW = 1 / _vertex.positionScreen.w;

					_vertex.positionScreen.x *= invW;
					_vertex.positionScreen.y *= invW;
					_vertex.positionScreen.z *= invW;

					_vertex.visible = ! ( _vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 ||
							      _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 ||
							      _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1 );

				}

				for ( f = 0, fl = faces.length; f < fl; f ++ ) {

					face = faces[ f ];

					var material = isFaceMaterial === true
						? objectMaterials.materials[ face.materialIndex ]
						: object.material;

					if ( material === undefined ) continue;

					var side = material.side;

					v1 = _vertexPool[ face.a ];
					v2 = _vertexPool[ face.b ];
					v3 = _vertexPool[ face.c ];

					_points3[ 0 ] = v1.positionScreen;
					_points3[ 1 ] = v2.positionScreen;
					_points3[ 2 ] = v3.positionScreen;

					if ( v1.visible === true || v2.visible === true || v3.visible === true ||
						_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {

						visible = ( ( v3.positionScreen.x - v1.positionScreen.x ) *
							    ( v2.positionScreen.y - v1.positionScreen.y ) -
							    ( v3.positionScreen.y - v1.positionScreen.y ) *
							    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

						if ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {

							_face = getNextFace3InPool();

							_face.id = object.id;
							_face.v1.copy( v1 );
							_face.v2.copy( v2 );
							_face.v3.copy( v3 );

						} else {

							continue;

						}

					} else {

						continue;

					}

					_face.normalModel.copy( face.normal );

					if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

						_face.normalModel.negate();

					}

					_face.normalModel.applyMatrix3( _normalMatrix ).normalize();

					_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );

					_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );

					faceVertexNormals = face.vertexNormals;

					for ( n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

						var normalModel = _face.vertexNormalsModel[ n ];
						normalModel.copy( faceVertexNormals[ n ] );

						if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

							normalModel.negate();

						}

						normalModel.applyMatrix3( _normalMatrix ).normalize();

						var normalModelView = _face.vertexNormalsModelView[ n ];
						normalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );

					}

					_face.vertexNormalsLength = faceVertexNormals.length;

					for ( c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {

						uvs = faceVertexUvs[ c ][ f ];

						if ( uvs === undefined ) continue;

						for ( u = 0, ul = uvs.length; u < ul; u ++ ) {

							_face.uvs[ c ][ u ] = uvs[ u ];

						}

					}

					_face.color = face.color;
					_face.material = material;

					_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );

					_face.z = _centroid.z;

					_renderData.elements.push( _face );

				}

			} else if ( object instanceof THREE.Line ) {

				_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

				vertices = object.geometry.vertices;

				v1 = getNextVertexInPool();
				v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

				// Handle LineStrip and LinePieces
				var step = object.type === THREE.LinePieces ? 2 : 1;

				for ( v = 1, vl = vertices.length; v < vl; v ++ ) {

					v1 = getNextVertexInPool();
					v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

					if ( ( v + 1 ) % step > 0 ) continue;

					v2 = _vertexPool[ _vertexCount - 2 ];

					_clippedVertex1PositionScreen.copy( v1.positionScreen );
					_clippedVertex2PositionScreen.copy( v2.positionScreen );

					if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

						// Perform the perspective divide
						_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
						_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

						_line = getNextLineInPool();

						_line.id = object.id;
						_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
						_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

						_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

						_line.material = object.material;

						if ( object.material.vertexColors === THREE.VertexColors ) {

							_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
							_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

						}

						_renderData.elements.push( _line );

					}

				}

			}

		}

		for ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {

			object = _renderData.sprites[ o ].object;

			_modelMatrix = object.matrixWorld;

			if ( object instanceof THREE.Sprite ) {

				_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );
				_vector4.applyMatrix4( _viewProjectionMatrix );

				var invW = 1 / _vector4.w;

				_vector4.z *= invW;

				if ( _vector4.z > -1 && _vector4.z < 1 ) {

					_sprite = getNextSpriteInPool();
					_sprite.id = object.id;
					_sprite.x = _vector4.x * invW;
					_sprite.y = _vector4.y * invW;
					_sprite.z = _vector4.z;
					_sprite.object = object;

					_sprite.rotation = object.rotation;

					_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );
					_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );

					_sprite.material = object.material;

					_renderData.elements.push( _sprite );

				}

			}

		}

		if ( sortElements === true ) _renderData.elements.sort( painterSort );

		return _renderData;

	};

	// Pools

	function getNextObjectInPool() {

		if ( _objectCount === _objectPoolLength ) {

			var object = new THREE.RenderableObject();
			_objectPool.push( object );
			_objectPoolLength ++;
			_objectCount ++;
			return object;

		}

		return _objectPool[ _objectCount ++ ];

	}

	function getNextVertexInPool() {

		if ( _vertexCount === _vertexPoolLength ) {

			var vertex = new THREE.RenderableVertex();
			_vertexPool.push( vertex );
			_vertexPoolLength ++;
			_vertexCount ++;
			return vertex;

		}

		return _vertexPool[ _vertexCount ++ ];

	}

	function getNextFace3InPool() {

		if ( _face3Count === _face3PoolLength ) {

			var face = new THREE.RenderableFace3();
			_face3Pool.push( face );
			_face3PoolLength ++;
			_face3Count ++;
			return face;

		}

		return _face3Pool[ _face3Count ++ ];


	}

	function getNextLineInPool() {

		if ( _lineCount === _linePoolLength ) {

			var line = new THREE.RenderableLine();
			_linePool.push( line );
			_linePoolLength ++;
			_lineCount ++
			return line;

		}

		return _linePool[ _lineCount ++ ];

	}

	function getNextSpriteInPool() {

		if ( _spriteCount === _spritePoolLength ) {

			var sprite = new THREE.RenderableSprite();
			_spritePool.push( sprite );
			_spritePoolLength ++;
			_spriteCount ++
			return sprite;

		}

		return _spritePool[ _spriteCount ++ ];

	}

	//

	function painterSort( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else if ( a.id !== b.id ) {

			return a.id - b.id;

		} else {

			return 0;

		}

	}

	function clipLine( s1, s2 ) {

		var alpha1 = 0, alpha2 = 1,

		// Calculate the boundary coordinate of each vertex for the near and far clip planes,
		// Z = -1 and Z = +1, respectively.
		bc1near =  s1.z + s1.w,
		bc2near =  s2.z + s2.w,
		bc1far =  - s1.z + s1.w,
		bc2far =  - s2.z + s2.w;

		if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

			// Both vertices lie entirely within all clip planes.
			return true;

		} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {

			// Both vertices lie entirely outside one of the clip planes.
			return false;

		} else {

			// The line segment spans at least one clip plane.

			if ( bc1near < 0 ) {

				// v1 lies outside the near plane, v2 inside
				alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

			} else if ( bc2near < 0 ) {

				// v2 lies outside the near plane, v1 inside
				alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

			}

			if ( bc1far < 0 ) {

				// v1 lies outside the far plane, v2 inside
				alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

			} else if ( bc2far < 0 ) {

				// v2 lies outside the far plane, v2 inside
				alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

			}

			if ( alpha2 < alpha1 ) {

				// The line segment spans two boundaries, but is outside both of them.
				// (This can't happen when we're only clipping against just near/far but good
				//  to leave the check here for future usage if other clip planes are added.)
				return false;

			} else {

				// Update the s1 and s2 vertices to match the clipped line segment.
				s1.lerp( s2, alpha1 );
				s2.lerp( s1, 1 - alpha2 );

				return true;

			}

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [ ];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	this.centroid = new THREE.Vector3();

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );
		face.centroid.copy( this.centroid );

		face.materialIndex = this.materialIndex;

		var i, il;
		for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
		for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
		for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		return face;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.')

	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	this.id = THREE.GeometryIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in ParticleSystem and Line

	this.faces = [];

	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.buffersNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

			face.centroid.applyMatrix4( matrix );

		}

		if ( this.boundingBox instanceof THREE.Box3 ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere instanceof THREE.Sphere ) {

			this.computeBoundingSphere();

		}

	},

	computeCentroids: function () {

		var f, fl, face;

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			face.centroid.set( 0, 0, 0 );

			face.centroid.add( this.vertices[ face.a ] );
			face.centroid.add( this.vertices[ face.b ] );
			face.centroid.add( this.vertices[ face.c ] );
			face.centroid.divideScalar( 3 );

		}

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		// create internal buffers for reuse when calling this method repeatedly
		// (otherwise memory allocation / deallocation every frame is big resource hog)

		if ( this.__tmpVertices === undefined ) {

			this.__tmpVertices = new Array( this.vertices.length );
			vertices = this.__tmpVertices;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];
				face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

			}

		} else {

			vertices = this.__tmpVertices;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].set( 0, 0, 0 );

			}

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.vertexNormals[ 0 ].copy( vertices[ face.a ] );
			face.vertexNormals[ 1 ].copy( vertices[ face.b ] );
			face.vertexNormals[ 2 ].copy( vertices[ face.c ] );

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = (test < 0.0) ? -1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function ( ) {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		// reset cache of vertices as it now will be changing.
		this.__tmpVertices = undefined;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = -1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}
			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		var uvs = this.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			geometry.faceVertexUvs[ 0 ].push( uvCopy );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.BufferGeometry = function () {

	this.id = THREE.GeometryIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	// attributes

	this.attributes = {};

	// attributes typed arrays are kept only if dynamic flag is set

	this.dynamic = true;

	// offsets for chunks when using indexed elements

	this.offsets = [];

	// boundings

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	// for compatibility

	this.morphTargets = [];

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addAttribute: function( name, type, numItems, itemSize ) {

		this.attributes[ name ] = {

			itemSize: itemSize,
			array: new type( numItems * itemSize )

		};

	},

	applyMatrix: function ( matrix ) {

		var positionArray;
		var normalArray;

		if ( this.attributes[ "position" ] ) positionArray = this.attributes[ "position" ].array;
		if ( this.attributes[ "normal" ] ) normalArray = this.attributes[ "normal" ].array;

		if ( positionArray !== undefined ) {

			matrix.multiplyVector3Array( positionArray );
			this.verticesNeedUpdate = true;

		}

		if ( normalArray !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.multiplyVector3Array( normalArray );

			this.normalizeNormals();

			this.normalsNeedUpdate = true;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		var positions = this.attributes[ "position" ].array;

		if ( positions ) {

			var bb = this.boundingBox;
			var x, y, z;

			if( positions.length >= 3 ) {
				bb.min.x = bb.max.x = positions[ 0 ];
				bb.min.y = bb.max.y = positions[ 1 ];
				bb.min.z = bb.max.z = positions[ 2 ];
			}

			for ( var i = 3, il = positions.length; i < il; i += 3 ) {

				x = positions[ i ];
				y = positions[ i + 1 ];
				z = positions[ i + 2 ];

				// bounding box

				if ( x < bb.min.x ) {

					bb.min.x = x;

				} else if ( x > bb.max.x ) {

					bb.max.x = x;

				}

				if ( y < bb.min.y ) {

					bb.min.y = y;

				} else if ( y > bb.max.y ) {

					bb.max.y = y;

				}

				if ( z < bb.min.z ) {

					bb.min.z = z;

				} else if ( z > bb.max.z ) {

					bb.max.z = z;

				}

			}

		}

		if ( positions === undefined || positions.length === 0 ) {

			this.boundingBox.min.set( 0, 0, 0 );
			this.boundingBox.max.set( 0, 0, 0 );

		}

	},

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes[ "position" ].array;

			if ( positions ) {

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					box.addPoint( vector );

				}

				box.center( center );

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			}

		}

	}(),

	computeVertexNormals: function () {

		if ( this.attributes[ "position" ] ) {

			var i, il;
			var j, jl;

			var nVertexElements = this.attributes[ "position" ].array.length;

			if ( this.attributes[ "normal" ] === undefined ) {

				this.attributes[ "normal" ] = {

					itemSize: 3,
					array: new Float32Array( nVertexElements )

				};

			} else {

				// reset existing normals to zero

				for ( i = 0, il = this.attributes[ "normal" ].array.length; i < il; i ++ ) {

					this.attributes[ "normal" ].array[ i ] = 0;

				}

			}

			var positions = this.attributes[ "position" ].array;
			var normals = this.attributes[ "normal" ].array;

			var vA, vB, vC, x, y, z,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( this.attributes[ "index" ] ) {

				var indices = this.attributes[ "index" ].array;

				var offsets = this.offsets;

				for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( i = start, il = start + count; i < il; i += 3 ) {

						vA = index + indices[ i ];
						vB = index + indices[ i + 1 ];
						vC = index + indices[ i + 2 ];

						x = positions[ vA * 3 ];
						y = positions[ vA * 3 + 1 ];
						z = positions[ vA * 3 + 2 ];
						pA.set( x, y, z );

						x = positions[ vB * 3 ];
						y = positions[ vB * 3 + 1 ];
						z = positions[ vB * 3 + 2 ];
						pB.set( x, y, z );

						x = positions[ vC * 3 ];
						y = positions[ vC * 3 + 1 ];
						z = positions[ vC * 3 + 2 ];
						pC.set( x, y, z );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA * 3 ]     += cb.x;
						normals[ vA * 3 + 1 ] += cb.y;
						normals[ vA * 3 + 2 ] += cb.z;

						normals[ vB * 3 ]     += cb.x;
						normals[ vB * 3 + 1 ] += cb.y;
						normals[ vB * 3 + 2 ] += cb.z;

						normals[ vC * 3 ]     += cb.x;
						normals[ vC * 3 + 1 ] += cb.y;
						normals[ vC * 3 + 2 ] += cb.z;

					}

				}

			// non-indexed elements (unconnected triangle soup)

			} else {

				for ( i = 0, il = positions.length; i < il; i += 9 ) {

					x = positions[ i ];
					y = positions[ i + 1 ];
					z = positions[ i + 2 ];
					pA.set( x, y, z );

					x = positions[ i + 3 ];
					y = positions[ i + 4 ];
					z = positions[ i + 5 ];
					pB.set( x, y, z );

					x = positions[ i + 6 ];
					y = positions[ i + 7 ];
					z = positions[ i + 8 ];
					pC.set( x, y, z );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] 	 = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			this.normalsNeedUpdate = true;

		}

	},

	normalizeNormals: function () {

		var normals = this.attributes[ "normal" ].array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] 	 *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes[ "index" ] === undefined ||
			 this.attributes[ "position" ] === undefined ||
			 this.attributes[ "normal" ] === undefined ||
			 this.attributes[ "uv" ] === undefined ) {

			console.warn( "Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()" );
			return;

		}

		var indices = this.attributes[ "index" ].array;
		var positions = this.attributes[ "position" ].array;
		var normals = this.attributes[ "normal" ].array;
		var uvs = this.attributes[ "uv" ].array;

		var nVertices = positions.length / 3;

		if ( this.attributes[ "tangent" ] === undefined ) {

			var nTangentElements = 4 * nVertices;

			this.attributes[ "tangent" ] = {

				itemSize: 4,
				array: new Float32Array( nTangentElements )

			};

		}

		var tangents = this.attributes[ "tangent" ].array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var xA, yA, zA,
			xB, yB, zB,
			xC, yC, zC,

			uA, vA,
			uB, vB,
			uC, vC,

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			xA = positions[ a * 3 ];
			yA = positions[ a * 3 + 1 ];
			zA = positions[ a * 3 + 2 ];

			xB = positions[ b * 3 ];
			yB = positions[ b * 3 + 1 ];
			zB = positions[ b * 3 + 2 ];

			xC = positions[ c * 3 ];
			yC = positions[ c * 3 + 1 ];
			zC = positions[ c * 3 + 2 ];

			uA = uvs[ a * 2 ];
			vA = uvs[ a * 2 + 1 ];

			uB = uvs[ b * 2 ];
			vB = uvs[ b * 2 + 1 ];

			uC = uvs[ c * 2 ];
			vC = uvs[ c * 2 + 1 ];

			x1 = xB - xA;
			x2 = xC - xA;

			y1 = yB - yA;
			y2 = yC - yA;

			z1 = zB - zA;
			z2 = zC - zA;

			s1 = uB - uA;
			s2 = uC - uA;

			t1 = vB - vA;
			t2 = vC - vA;

			r = 1.0 / ( s1 * t2 - s2 * t1 );

			sdir.set(
				( t2 * x1 - t1 * x2 ) * r,
				( t2 * y1 - t1 * y2 ) * r,
				( t2 * z1 - t1 * z2 ) * r
			);

			tdir.set(
				( s1 * x2 - s2 * x1 ) * r,
				( s1 * y2 - s2 * y1 ) * r,
				( s1 * z2 - s2 * z1 ) * r
			);

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		var offsets = this.offsets;

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.x = normals[ v * 3 ];
			n.y = normals[ v * 3 + 1 ];
			n.z = normals[ v * 3 + 2 ];

			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? -1.0 : 1.0;

			tangents[ v * 4 ]     = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

		this.hasTangents = true;
		this.tangentsNeedUpdate = true;

	},

	clone: function () {

		var geometry = new THREE.BufferGeometry();

		var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];

		for ( var attr in this.attributes ) {

			var sourceAttr = this.attributes[ attr ];
			var sourceArray = sourceAttr.array;

			var attribute = {

				itemSize: sourceAttr.itemSize,
				numItems: sourceAttr.numItems,
				array: null

			};

			for ( var i = 0, il = types.length; i < il; i ++ ) {

				var type = types[ i ];

				if ( sourceArray instanceof type ) {

					attribute.array = new type( sourceArray );
					break;

				}

			}

			geometry.attributes[ attr ] = attribute;

		}

		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

			var offset = this.offsets[ i ];

			geometry.offsets.push( {

				start: offset.start,
				index: offset.index,
				count: offset.count

			} );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.matrixWorldInverse = new THREE.Matrix4();

	this.projectionMatrix = new THREE.Matrix4();
	this.projectionMatrixInverse = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function (camera) {

	if ( camera === undefined ) camera = new THREE.Camera();

	THREE.Object3D.prototype.clone.call( this, camera );

	camera.matrixWorldInverse.copy( this.matrixWorldInverse );
	camera.projectionMatrix.copy( this.projectionMatrix );
	camera.projectionMatrixInverse.copy( this.projectionMatrixInverse );

	return camera;
};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

	var camera = new THREE.OrthographicCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;

	camera.near = this.near;
	camera.far = this.far;

	return camera;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;
		var bottom = -top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.clone = function () {

	var camera = new THREE.PerspectiveCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.fov = this.fov;
	camera.aspect = this.aspect;
	camera.near = this.near;
	camera.far = this.far;

	return camera;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( hex ) {

	THREE.Object3D.call( this );

	this.color = new THREE.Color( hex );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

THREE.Light.prototype.clone = function ( light ) {

	if ( light === undefined ) light = new THREE.Light();

	THREE.Object3D.prototype.clone.call( this, light );

	light.color.copy( this.color );

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( hex ) {

	THREE.Light.call( this, hex );

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

THREE.AmbientLight.prototype.clone = function () {

	var light = new THREE.AmbientLight();

	THREE.Light.prototype.clone.call( this, light );

	return light;

};

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( hex, intensity ) {

	THREE.Light.call( this, hex );

	this.normal = new THREE.Vector3( 0, -1, 0 );
	this.right = new THREE.Vector3( 1, 0, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.width = 1.0;
	this.height = 1.0;

	this.constantAttenuation = 1.5;
	this.linearAttenuation = 0.5;
	this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );


/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( hex, intensity ) {

	THREE.Light.call( this, hex );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = -500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = -500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

THREE.DirectionalLight.prototype.clone = function () {

	var light = new THREE.DirectionalLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {

	THREE.Light.call( this, skyColorHex );

	this.position.set( 0, 100, 0 );

	this.groundColor = new THREE.Color( groundColorHex );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

THREE.HemisphereLight.prototype.clone = function () {

	var light = new THREE.HemisphereLight();

	THREE.Light.prototype.clone.call( this, light );

	light.groundColor.copy( this.groundColor );
	light.intensity = this.intensity;

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( hex, intensity, distance ) {

	THREE.Light.call( this, hex );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

THREE.PointLight.prototype.clone = function () {

	var light = new THREE.PointLight();

	THREE.Light.prototype.clone.call( this, light );

	light.intensity = this.intensity;
	light.distance = this.distance;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {

	THREE.Light.call( this, hex );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

THREE.SpotLight.prototype.clone = function () {

	var light = new THREE.SpotLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.angle = this.angle;
	light.exponent = this.exponent;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: 'anonymous',

	addStatusElement: function () {

		var e = document.createElement( "div" );

		e.style.position = "absolute";
		e.style.right = "0px";
		e.style.top = "0px";
		e.style.fontSize = "0.8em";
		e.style.textAlign = "left";
		e.style.background = "rgba(0,0,0,0.25)";
		e.style.color = "#fff";
		e.style.width = "120px";
		e.style.padding = "0.5em 0.5em 0.5em 0.5em";
		e.style.zIndex = 1000;

		e.innerHTML = "Loading ...";

		return e;

	},

	updateProgress: function ( progress ) {

		var message = "Loaded ";

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";


		} else {

			message += ( progress.loaded / 1000 ).toFixed(2) + " KB";

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );
		parts.pop();
		return ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var _this = this;

		function is_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.floor( l ) == l;

		}

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function load_image( where, url ) {

			var image = new Image();

			image.onload = function () {

				if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {

					var width = nearest_pow2( this.width );
					var height = nearest_pow2( this.height );

					where.image.width = width;
					where.image.height = height;
					where.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );

				} else {

					where.image = this;

				}

				where.needsUpdate = true;

			};

			image.crossOrigin = _this.crossOrigin;
			image.src = url;

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var isCompressed = /\.dds$/i.test( sourceFile );
			var fullPath = texturePath + "/" + sourceFile;

			if ( isCompressed ) {

				var texture = THREE.ImageUtils.loadCompressedTexture( fullPath );

				where[ name ] = texture;

			} else {

				var texture = document.createElement( 'canvas' );

				where[ name ] = new THREE.Texture( texture );

			}

			where[ name ].sourceFile = sourceFile;

			if( repeat ) {

				where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					"repeat": THREE.RepeatWrapping,
					"mirror": THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				where[ name ].anisotropy = anisotropy;

			}

			if ( ! isCompressed ) {

				load_image( where[ name ], fullPath );

			}

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = "MeshLambertMaterial";
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === "phong" ) mtype = "MeshPhongMaterial";
			else if ( shading === "basic" ) mtype = "MeshBasicMaterial";

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === "face" ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderLib[ "normalmap" ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			uniforms[ "tNormal" ].value = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ "uNormalScale" ].value.set( m.mapNormalFactor, m.mapNormalFactor );

			}

			if ( mpars.map ) {

				uniforms[ "tDiffuse" ].value = mpars.map;
				uniforms[ "enableDiffuse" ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ "tSpecular" ].value = mpars.specularMap;
				uniforms[ "enableSpecular" ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ "tAO" ].value = mpars.lightMap;
				uniforms[ "enableAO" ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ "uDiffuseColor" ].value.setHex( mpars.color );
			uniforms[ "uSpecularColor" ].value.setHex( mpars.specular );
			uniforms[ "uAmbientColor" ].value.setHex( mpars.ambient );

			uniforms[ "uShininess" ].value = mpars.shininess;

			if ( mpars.opacity !== undefined ) {

				uniforms[ "uOpacity" ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
			var material = new THREE.ShaderMaterial( parameters );

			if ( mpars.transparent ) {

				material.transparent = true;

			}

		} else {

			var material = new THREE[ mtype ]( mpars );

		}

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		var request = new XMLHttpRequest();

		if ( onLoad !== undefined ) {

			request.addEventListener( 'load', function ( event ) {

				onLoad( event.target.responseText );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;

		request.open( 'GET', url, true );
		request.send( null );

		scope.manager.itemStart( url );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		var image = document.createElement( 'img' );

		if ( onLoad !== undefined ) {

			image.addEventListener( 'load', function ( event ) {

				scope.manager.itemEnd( url );
				onLoad( this );

			}, false );

		}

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			image.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		image.src = url;

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );
					var result = context.parse( json, texturePath );
					callback( result.geometry, result.materials );

				} else {

					console.warn( "THREE.JSONLoader: [" + url + "] seems to be unreachable or file there is empty" );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				console.error( "THREE.JSONLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			if ( callbackProgress !== undefined ) {

				length = xhr.getResponseHeader( "Content-Length" );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeCentroids();
	geometry.computeFaceNormals();
	geometry.computeBoundingSphere();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, color, hex, normal,

		uvLayer, uv, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		if ( json.uvs !== undefined ) {

			// disregard empty arrays

			for ( i = 0; i < json.uvs.length; i++ ) {

				if ( json.uvs[ i ].length ) nUvLayers ++;

			}

			for ( i = 0; i < nUvLayers; i++ ) {

				geometry.faceVertexUvs[ i ] = [];

			}

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad              = isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	    = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				faceA = new THREE.Face3();
				faceA.a = faces[ offset ];
				faceA.b = faces[ offset + 1 ];
				faceA.c = faces[ offset + 3 ];

				faceB = new THREE.Face3();
				faceB.a = faces[ offset + 1 ];
				faceB.b = faces[ offset + 2 ];
				faceB.c = faces[ offset + 3 ];

				offset += 4;

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					faceA.materialIndex = materialIndex;
					faceB.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];
						geometry.faceVertexUvs[ i ][ fi + 1 ] = []

						for ( j = 0; j < 4; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					faceA.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

					faceB.normal.copy( faceA.normal );

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 4; i++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);


						if ( i !== 2 ) faceA.vertexNormals.push( normal );
						if ( i !== 0 ) faceB.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					hex = colors[ colorIndex ];

					faceA.color.setHex( hex );
					faceB.color.setHex( hex );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 4; i++ ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

					}

				}

				geometry.faces.push( faceA );
				geometry.faces.push( faceB );

			} else {

				face = new THREE.Face3();
				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];

						for ( j = 0; j < 3; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							geometry.faceVertexUvs[ i ][ fi ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					face.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 3; i++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						face.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					face.color.setHex( colors[ colorIndex ] );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 3; i++ ) {

						colorIndex = faces[ offset ++ ];
						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

					}

				}

				geometry.faces.push( face );

			}

		}

	};

	function parseSkin() {

		var i, l, x, y, z, w, a, b, c, d;

		if ( json.skinWeights ) {

			for ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

				x = json.skinWeights[ i     ];
				y = json.skinWeights[ i + 1 ];
				z = 0;
				w = 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

				a = json.skinIndices[ i     ];
				b = json.skinIndices[ i + 1 ];
				c = 0;
				d = 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;
		// could change this to json.animations[0] or remove completely
		geometry.animation = json.animation;
		geometry.animations = json.animations;
	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	if ( json.materials === undefined ) {

		return { geometry: geometry };

	} else {

		var materials = this.initMaterials( json.materials, texturePath );

		if ( this.needsTangents( materials ) ) {

			geometry.computeTangents();

		}

		return { geometry: geometry, materials: materials };

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var loaded = 0, total = 0;

	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		total ++;

	};

	this.itemEnd = function ( url ) {

		loaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, loaded, total );

		}

		if ( loaded === total && scope.onLoad !== undefined ) {

			scope.onLoad();

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var attributes = json.attributes;
		var offsets = json.offsets;
		var boundingSphere = json.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			geometry.attributes[ key ] = {
				itemSize: attribute.itemSize,
				array: new self[ attribute.type ]( attribute.array )
			}

		}

		if ( offsets !== undefined ) {

			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		if ( boundingSphere !== undefined ) {

			geometry.boundingSphere = new THREE.Sphere(
				new THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),
				boundingSphere.radius
			);

		}

		return geometry;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.GeometryLoader.prototype = {

	constructor: THREE.GeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {



	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometries = this.parseGeometries( json.geometries );
		var materials = this.parseMaterials( json.materials );
		var object = this.parseObject( json.object, geometries, materials );

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':

						geometry = new THREE.PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments
						);

						break;

					case 'CubeGeometry':

						geometry = new THREE.CubeGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data.data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data ).geometry;

						break;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];
				var material = loader.parse( data );

				material.uuid = data.uuid;

				if ( data.name !== undefined ) material.name = data.name;

				materials[ data.uuid ] = material;

			}

		}

		return materials;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );

					}

					if ( material === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined material ' + data.material );

					}

					object = new THREE.Mesh( geometry, material );

					break;

				case 'Sprite':

					var material = materials[ data.material ];

					if ( material === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined material ' + data.material );

					}

					object = new THREE.Sprite( material );

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			return object;

		}

	}()

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneLoader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};

	this.callbackSync = function () {};
	this.callbackProgress = function () {};

	this.geometryHandlers = {};
	this.hierarchyHandlers = {};

	this.addGeometryHandler( "ascii", THREE.JSONLoader );

};

THREE.SceneLoader.prototype = {

	constructor: THREE.SceneLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad, url );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	addGeometryHandler: function ( typeID, loaderClass ) {

		this.geometryHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	addHierarchyHandler: function ( typeID, loaderClass ) {

		this.hierarchyHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	parse: function ( json, callbackFinished, url ) {

		var scope = this;

		var urlBase = THREE.Loader.prototype.extractUrlBase( url );

		var geometry, material, camera, fog,
			texture, images, color,
			light, hex, intensity,
			counter_models, counter_textures,
			total_models, total_textures,
			result;

		var target_array = [];

		var data = json;

		// async geometry loaders

		for ( var typeID in this.geometryHandlers ) {

			var loaderClass = this.geometryHandlers[ typeID ][ "loaderClass" ];
			this.geometryHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		// async hierachy loaders

		for ( var typeID in this.hierarchyHandlers ) {

			var loaderClass = this.hierarchyHandlers[ typeID ][ "loaderClass" ];
			this.hierarchyHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		counter_models = 0;
		counter_textures = 0;

		result = {

			scene: new THREE.Scene(),
			geometries: {},
			face_materials: {},
			materials: {},
			textures: {},
			objects: {},
			cameras: {},
			lights: {},
			fogs: {},
			empties: {},
			groups: {}

		};

		if ( data.transform ) {

			var position = data.transform.position,
				rotation = data.transform.rotation,
				scale = data.transform.scale;

			if ( position ) {

				result.scene.position.fromArray( position );

			}

			if ( rotation ) {

				result.scene.rotation.fromArray( rotation );

			}

			if ( scale ) {

				result.scene.scale.fromArray( scale );

			}

			if ( position || rotation || scale ) {

				result.scene.updateMatrix();
				result.scene.updateMatrixWorld();

			}

		}

		function get_url( source_url, url_type ) {

			if ( url_type == "relativeToHTML" ) {

				return source_url;

			} else {

				return urlBase + "/" + source_url;

			}

		};

		// toplevel loader function, delegates to handle_children

		function handle_objects() {

			handle_children( result.scene, data.objects );

		}

		// handle all the children from the loaded json and attach them to given parent

		function handle_children( parent, children ) {

			var mat, dst, pos, rot, scl, quat;

			for ( var objID in children ) {

				// check by id if child has already been handled,
				// if not, create new object

				var object = result.objects[ objID ];
				var objJSON = children[ objID ];

				if ( object === undefined ) {

					// meshes

					if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

						if ( objJSON.loading === undefined ) {

							var reservedTypes = {
								"type": 1, "url": 1, "material": 1,
								"position": 1, "rotation": 1, "scale" : 1,
								"visible": 1, "children": 1, "userData": 1,
								"skin": 1, "morph": 1, "mirroredLoop": 1, "duration": 1
							};

							var loaderParameters = {};

							for ( var parType in objJSON ) {

								if ( ! ( parType in reservedTypes ) ) {

									loaderParameters[ parType ] = objJSON[ parType ];

								}

							}

							material = result.materials[ objJSON.material ];

							objJSON.loading = true;

							var loader = scope.hierarchyHandlers[ objJSON.type ][ "loaderObject" ];

							// ColladaLoader

							if ( loader.options ) {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );

							// UTF8Loader
							// OBJLoader

							} else {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );

							}

						}

					} else if ( objJSON.geometry !== undefined ) {

						geometry = result.geometries[ objJSON.geometry ];

						// geometry already loaded

						if ( geometry ) {

							var needsTangents = false;

							material = result.materials[ objJSON.material ];
							needsTangents = material instanceof THREE.ShaderMaterial;

							pos = objJSON.position;
							rot = objJSON.rotation;
							scl = objJSON.scale;
							mat = objJSON.matrix;
							quat = objJSON.quaternion;

							// use materials from the model file
							// if there is no material specified in the object

							if ( ! objJSON.material ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							// use materials from the model file
							// if there is just empty face material
							// (must create new material as each model has its own face material)

							if ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							if ( material instanceof THREE.MeshFaceMaterial ) {

								for ( var i = 0; i < material.materials.length; i ++ ) {

									needsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );

								}

							}

							if ( needsTangents ) {

								geometry.computeTangents();

							}

							if ( objJSON.skin ) {

								object = new THREE.SkinnedMesh( geometry, material );

							} else if ( objJSON.morph ) {

								object = new THREE.MorphAnimMesh( geometry, material );

								if ( objJSON.duration !== undefined ) {

									object.duration = objJSON.duration;

								}

								if ( objJSON.time !== undefined ) {

									object.time = objJSON.time;

								}

								if ( objJSON.mirroredLoop !== undefined ) {

									object.mirroredLoop = objJSON.mirroredLoop;

								}

								if ( material.morphNormals ) {

									geometry.computeMorphNormals();

								}

							} else {

								object = new THREE.Mesh( geometry, material );

							}

							object.name = objID;

							if ( mat ) {

								object.matrixAutoUpdate = false;
								object.matrix.set(
									mat[0],  mat[1],  mat[2],  mat[3],
									mat[4],  mat[5],  mat[6],  mat[7],
									mat[8],  mat[9],  mat[10], mat[11],
									mat[12], mat[13], mat[14], mat[15]
								);

							} else {

								object.position.fromArray( pos );

								if ( quat ) {

									object.quaternion.fromArray( quat );

								} else {

									object.rotation.fromArray( rot );

								}

								object.scale.fromArray( scl );

							}

							object.visible = objJSON.visible;
							object.castShadow = objJSON.castShadow;
							object.receiveShadow = objJSON.receiveShadow;

							parent.add( object );

							result.objects[ objID ] = object;

						}

					// lights

					} else if ( objJSON.type === "AmbientLight" || objJSON.type === "PointLight" ||
						objJSON.type === "DirectionalLight" || objJSON.type === "SpotLight" ||
						objJSON.type === "HemisphereLight" || objJSON.type === "AreaLight" ) {

						var color = objJSON.color;
						var intensity = objJSON.intensity;
						var distance = objJSON.distance;
						var position = objJSON.position;
						var rotation = objJSON.rotation;

						switch ( objJSON.type ) {

							case 'AmbientLight':
								light = new THREE.AmbientLight( color );
								break;

							case 'PointLight':
								light = new THREE.PointLight( color, intensity, distance );
								light.position.fromArray( position );
								break;

							case 'DirectionalLight':
								light = new THREE.DirectionalLight( color, intensity );
								light.position.fromArray( objJSON.direction );
								break;

							case 'SpotLight':
								light = new THREE.SpotLight( color, intensity, distance, 1 );
								light.angle = objJSON.angle;
								light.position.fromArray( position );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'HemisphereLight':
								light = new THREE.DirectionalLight( color, intensity, distance );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'AreaLight':
								light = new THREE.AreaLight(color, intensity);
								light.position.fromArray( position );
								light.width = objJSON.size;
								light.height = objJSON.size_y;
								break;

						}

						parent.add( light );

						light.name = objID;
						result.lights[ objID ] = light;
						result.objects[ objID ] = light;

					// cameras

					} else if ( objJSON.type === "PerspectiveCamera" || objJSON.type === "OrthographicCamera" ) {

						pos = objJSON.position;
						rot = objJSON.rotation;
						quat = objJSON.quaternion;

						if ( objJSON.type === "PerspectiveCamera" ) {

							camera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );

						} else if ( objJSON.type === "OrthographicCamera" ) {

							camera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );

						}

						camera.name = objID;
						camera.position.fromArray( pos );

						if ( quat !== undefined ) {

							camera.quaternion.fromArray( quat );

						} else if ( rot !== undefined ) {

							camera.rotation.fromArray( rot );

						}

						parent.add( camera );

						result.cameras[ objID ] = camera;
						result.objects[ objID ] = camera;

					// pure Object3D

					} else {

						pos = objJSON.position;
						rot = objJSON.rotation;
						scl = objJSON.scale;
						quat = objJSON.quaternion;

						object = new THREE.Object3D();
						object.name = objID;
						object.position.fromArray( pos );

						if ( quat ) {

							object.quaternion.fromArray( quat );

						} else {

							object.rotation.fromArray( rot );

						}

						object.scale.fromArray( scl );
						object.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;

						parent.add( object );

						result.objects[ objID ] = object;
						result.empties[ objID ] = object;

					}

					if ( object ) {

						if ( objJSON.userData !== undefined ) {

							for ( var key in objJSON.userData ) {

								var value = objJSON.userData[ key ];
								object.userData[ key ] = value;

							}

						}

						if ( objJSON.groups !== undefined ) {

							for ( var i = 0; i < objJSON.groups.length; i ++ ) {

								var groupID = objJSON.groups[ i ];

								if ( result.groups[ groupID ] === undefined ) {

									result.groups[ groupID ] = [];

								}

								result.groups[ groupID ].push( objID );

							}

						}

					}

				}

				if ( object !== undefined && objJSON.children !== undefined ) {

					handle_children( object, objJSON.children );

				}

			}

		};

		function handle_mesh( geo, mat, id ) {

			result.geometries[ id ] = geo;
			result.face_materials[ id ] = mat;
			handle_objects();

		};

		function handle_hierarchy( node, id, parent, material, obj ) {

			var p = obj.position;
			var r = obj.rotation;
			var q = obj.quaternion;
			var s = obj.scale;

			node.position.fromArray( p );

			if ( q ) {

				node.quaternion.fromArray( q );

			} else {

				node.rotation.fromArray( r );

			}

			node.scale.fromArray( s );

			// override children materials
			// if object material was specified in JSON explicitly

			if ( material ) {

				node.traverse( function ( child ) {

					child.material = material;

				} );

			}

			// override children visibility
			// with root node visibility as specified in JSON

			var visible = ( obj.visible !== undefined ) ? obj.visible : true;

			node.traverse( function ( child ) {

				child.visible = visible;

			} );

			parent.add( node );

			node.name = id;

			result.objects[ id ] = node;
			handle_objects();

		};

		function create_callback_geometry( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				handle_mesh( geo, mat, id );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			}

		};

		function create_callback_hierachy( id, parent, material, obj ) {

			return function ( event ) {

				var result;

				// loaders which use EventDispatcher

				if ( event.content ) {

					result = event.content;

				// ColladaLoader

				} else if ( event.dae ) {

					result = event.scene;


				// UTF8Loader

				} else {

					result = event;

				}

				handle_hierarchy( result, id, parent, material, obj );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			}

		};

		function create_callback_embed( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				result.geometries[ id ] = geo;
				result.face_materials[ id ] = mat;

			}

		};

		function async_callback_gate() {

			var progress = {

				totalModels : total_models,
				totalTextures : total_textures,
				loadedModels : total_models - counter_models,
				loadedTextures : total_textures - counter_textures

			};

			scope.callbackProgress( progress, result );

			scope.onLoadProgress();

			if ( counter_models === 0 && counter_textures === 0 ) {

				finalize();
				callbackFinished( result );

			}

		};

		function finalize() {

			// take care of targets which could be asynchronously loaded objects

			for ( var i = 0; i < target_array.length; i ++ ) {

				var ta = target_array[ i ];

				var target = result.objects[ ta.targetName ];

				if ( target ) {

					ta.object.target = target;

				} else {

					// if there was error and target of specified name doesn't exist in the scene file
					// create instead dummy target
					// (target must be added to scene explicitly as parent is already added)

					ta.object.target = new THREE.Object3D();
					result.scene.add( ta.object.target );

				}

				ta.object.target.userData.targetInverse = ta.object;

			}

		};

		var callbackTexture = function ( count ) {

			counter_textures -= count;
			async_callback_gate();

			scope.onLoadComplete();

		};

		// must use this instead of just directly calling callbackTexture
		// because of closure in the calling context loop

		var generateTextureCallback = function ( count ) {

			return function () {

				callbackTexture( count );

			};

		};

		function traverse_json_hierarchy( objJSON, callback ) {

			callback( objJSON );

			if ( objJSON.children !== undefined ) {

				for ( var objChildID in objJSON.children ) {

					traverse_json_hierarchy( objJSON.children[ objChildID ], callback );

				}

			}

		};

		// first go synchronous elements

		// fogs

		var fogID, fogJSON;

		for ( fogID in data.fogs ) {

			fogJSON = data.fogs[ fogID ];

			if ( fogJSON.type === "linear" ) {

				fog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );

			} else if ( fogJSON.type === "exp2" ) {

				fog = new THREE.FogExp2( 0x000000, fogJSON.density );

			}

			color = fogJSON.color;
			fog.color.setRGB( color[0], color[1], color[2] );

			result.fogs[ fogID ] = fog;

		}

		// now come potentially asynchronous elements

		// geometries

		// count how many geometries will be loaded asynchronously

		var geoID, geoJSON;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type in this.geometryHandlers ) {

				counter_models += 1;

				scope.onLoadStart();

			}

		}

		// count how many hierarchies will be loaded asynchronously

		for ( var objID in data.objects ) {

			traverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {

				if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

					counter_models += 1;

					scope.onLoadStart();

				}

			});

		}

		total_models = counter_models;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type === "cube" ) {

				geometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "plane" ) {

				geometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "sphere" ) {

				geometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "cylinder" ) {

				geometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "torus" ) {

				geometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "icosahedron" ) {

				geometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type in this.geometryHandlers ) {

				var loaderParameters = {};

				for ( var parType in geoJSON ) {

					if ( parType !== "type" && parType !== "url" ) {

						loaderParameters[ parType ] = geoJSON[ parType ];

					}

				}

				var loader = this.geometryHandlers[ geoJSON.type ][ "loaderObject" ];
				loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );

			} else if ( geoJSON.type === "embedded" ) {

				var modelJson = data.embeds[ geoJSON.id ],
					texture_path = "";

				// pass metadata along to jsonLoader so it knows the format version

				modelJson.metadata = data.metadata;

				if ( modelJson ) {

					var jsonLoader = this.geometryHandlers[ "ascii" ][ "loaderObject" ];
					var model = jsonLoader.parse( modelJson, texture_path );
					create_callback_embed( geoID )( model.geometry, model.materials );

				}

			}

		}

		// textures

		// count how many textures will be loaded asynchronously

		var textureID, textureJSON;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.url instanceof Array ) {

				counter_textures += textureJSON.url.length;

				for( var n = 0; n < textureJSON.url.length; n ++ ) {

					scope.onLoadStart();

				}

			} else {

				counter_textures += 1;

				scope.onLoadStart();

			}

		}

		total_textures = counter_textures;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {

				textureJSON.mapping = new THREE[ textureJSON.mapping ]();

			}

			if ( textureJSON.url instanceof Array ) {

				var count = textureJSON.url.length;
				var url_array = [];

				for( var i = 0; i < count; i ++ ) {

					url_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );

				}

				var isCompressed = /\.dds$/i.test( url_array[ 0 ] );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				} else {

					texture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				}

			} else {

				var isCompressed = /\.dds$/i.test( textureJSON.url );
				var fullUrl = get_url( textureJSON.url, data.urlBaseType );
				var textureCallback = generateTextureCallback( 1 );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );

				} else {

					texture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );

				}

				if ( THREE[ textureJSON.minFilter ] !== undefined )
					texture.minFilter = THREE[ textureJSON.minFilter ];

				if ( THREE[ textureJSON.magFilter ] !== undefined )
					texture.magFilter = THREE[ textureJSON.magFilter ];

				if ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;

				if ( textureJSON.repeat ) {

					texture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );

					if ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( textureJSON.offset ) {

					texture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );

				}

				// handle wrap after repeat so that default repeat can be overriden

				if ( textureJSON.wrap ) {

					var wrapMap = {
						"repeat": THREE.RepeatWrapping,
						"mirror": THREE.MirroredRepeatWrapping
					}

					if ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];
					if ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];

				}

			}

			result.textures[ textureID ] = texture;

		}

		// materials

		var matID, matJSON;
		var parID;

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			for ( parID in matJSON.parameters ) {

				if ( parID === "envMap" || parID === "map" || parID === "lightMap" || parID === "bumpMap" ) {

					matJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];

				} else if ( parID === "shading" ) {

					matJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === "flat" ) ? THREE.FlatShading : THREE.SmoothShading;

				} else if ( parID === "side" ) {

					if ( matJSON.parameters[ parID ] == "double" ) {

						matJSON.parameters[ parID ] = THREE.DoubleSide;

					} else if ( matJSON.parameters[ parID ] == "back" ) {

						matJSON.parameters[ parID ] = THREE.BackSide;

					} else {

						matJSON.parameters[ parID ] = THREE.FrontSide;

					}

				} else if ( parID === "blending" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;

				} else if ( parID === "combine" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;

				} else if ( parID === "vertexColors" ) {

					if ( matJSON.parameters[ parID ] == "face" ) {

						matJSON.parameters[ parID ] = THREE.FaceColors;

					// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false

					} else if ( matJSON.parameters[ parID ] ) {

						matJSON.parameters[ parID ] = THREE.VertexColors;

					}

				} else if ( parID === "wrapRGB" ) {

					var v3 = matJSON.parameters[ parID ];
					matJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );

				}

			}

			if ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {

				matJSON.parameters.transparent = true;

			}

			if ( matJSON.parameters.normalMap ) {

				var shader = THREE.ShaderLib[ "normalmap" ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

				var diffuse = matJSON.parameters.color;
				var specular = matJSON.parameters.specular;
				var ambient = matJSON.parameters.ambient;
				var shininess = matJSON.parameters.shininess;

				uniforms[ "tNormal" ].value = result.textures[ matJSON.parameters.normalMap ];

				if ( matJSON.parameters.normalScale ) {

					uniforms[ "uNormalScale" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );

				}

				if ( matJSON.parameters.map ) {

					uniforms[ "tDiffuse" ].value = matJSON.parameters.map;
					uniforms[ "enableDiffuse" ].value = true;

				}

				if ( matJSON.parameters.envMap ) {

					uniforms[ "tCube" ].value = matJSON.parameters.envMap;
					uniforms[ "enableReflection" ].value = true;
					uniforms[ "uReflectivity" ].value = matJSON.parameters.reflectivity;

				}

				if ( matJSON.parameters.lightMap ) {

					uniforms[ "tAO" ].value = matJSON.parameters.lightMap;
					uniforms[ "enableAO" ].value = true;

				}

				if ( matJSON.parameters.specularMap ) {

					uniforms[ "tSpecular" ].value = result.textures[ matJSON.parameters.specularMap ];
					uniforms[ "enableSpecular" ].value = true;

				}

				if ( matJSON.parameters.displacementMap ) {

					uniforms[ "tDisplacement" ].value = result.textures[ matJSON.parameters.displacementMap ];
					uniforms[ "enableDisplacement" ].value = true;

					uniforms[ "uDisplacementBias" ].value = matJSON.parameters.displacementBias;
					uniforms[ "uDisplacementScale" ].value = matJSON.parameters.displacementScale;

				}

				uniforms[ "uDiffuseColor" ].value.setHex( diffuse );
				uniforms[ "uSpecularColor" ].value.setHex( specular );
				uniforms[ "uAmbientColor" ].value.setHex( ambient );

				uniforms[ "uShininess" ].value = shininess;

				if ( matJSON.parameters.opacity ) {

					uniforms[ "uOpacity" ].value = matJSON.parameters.opacity;

				}

				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };

				material = new THREE.ShaderMaterial( parameters );

			} else {

				material = new THREE[ matJSON.type ]( matJSON.parameters );

			}

			material.name = matID;

			result.materials[ matID ] = material;

		}

		// second pass through all materials to initialize MeshFaceMaterials
		// that could be referring to other materials out of order

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			if ( matJSON.parameters.materials ) {

				var materialArray = [];

				for ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {

					var label = matJSON.parameters.materials[ i ];
					materialArray.push( result.materials[ label ] );

				}

				result.materials[ matID ].materials = materialArray;

			}

		}

		// objects ( synchronous init of procedural primitives )

		handle_objects();

		// defaults

		if ( result.cameras && data.defaults.camera ) {

			result.currentCamera = result.cameras[ data.defaults.camera ];

		}

		if ( result.fogs && data.defaults.fog ) {

			result.scene.fog = result.fogs[ data.defaults.fog ];

		}

		// synchronous callback

		scope.callbackSync( result );

		// just in case there are no async elements

		async_callback_gate();

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.ImageLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	this.id = THREE.MaterialIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			if ( key in this ) {

				var currentValue = this[ key ];

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key == 'overdraw') {

					// ensure overdraw is backwards-compatable with legacy boolean type
					this[ key ] = Number(newValue);

				} else {

					this[ key ] = newValue;

				}

			}

		}

	},

	clone: function ( material ) {

		if ( material === undefined ) material = new THREE.Material();

		material.name = this.name;

		material.side = this.side;

		material.opacity = this.opacity;
		material.transparent = this.transparent;

		material.blending = this.blending;

		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;

		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;

		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;

		material.alphaTest = this.alphaTest;

		material.overdraw = this.overdraw;

		material.visible = this.visible;

		return material;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;
	this.perPixel = true;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.metal = this.metal;
	material.perPixel = this.perPixel;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.MeshDepthMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype.clone = function () {

	var material = new THREE.MeshFaceMaterial();

	for ( var i = 0; i < this.materials.length; i ++ ) {

		material.materials.push( this.materials[ i ].clone() );

	}

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ParticleSystemMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.ParticleSystemMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ParticleSystemMaterial.prototype.clone = function () {

	var material = new THREE.ParticleSystemMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  defines: { "label" : "value" },
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.fragmentShader = "void main() {}";
	this.vertexShader = "void main() {}";
	this.uniforms = {};
	this.defines = {};
	this.attributes = null;

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		"color" : [ 1, 1, 1],
		"uv" : [ 0, 0 ],
		"uv2" : [ 0, 0 ]
	};

	// By default, bind position to attribute index 0. In WebGL, attribute 0
	// should always be used to avoid potentially expensive emulation.
	this.index0AttributeName = "position";

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	// defaults

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.depthTest = true;
	this.sizeAttenuation = true;
	this.rotation = 0;

	this.fog = false;

	this.uvOffset = new THREE.Vector2( 0, 0 );
	this.uvScale  = new THREE.Vector2( 1, 1 );

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.rotation = this.rotation;

	material.uvOffset.copy( this.uvOffset );
	material.uvScale.copy( this.uvScale );

	material.fog = this.fog;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <hex>,
 *  program: <function>,
 *  opacity: <float>,
 *  blending: THREE.NormalBlending
 * }
 */

THREE.SpriteCanvasMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );
	this.program = function ( context, color ) {};

	this.setValues( parameters );

};

THREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteCanvasMaterial.prototype.clone = function () {

	var material = new THREE.SpriteCanvasMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.program = this.program;

	return material;

};

// backwards compatibility

THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	this.id = THREE.TextureIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.image = image;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this.needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice(0);

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ParticleSystem = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.ParticleSystemMaterial( { color: Math.random() * 0xffffff } );

	this.sortParticles = false;
	this.frustumCulled = false;

};

THREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );

THREE.ParticleSystem.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );

	object.sortParticles = this.sortParticles;

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, type ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	this.type = ( type !== undefined ) ? type : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = -1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.log( "THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0." );

	return 0;

};

THREE.Mesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Bone = function( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;
	this.skinMatrix = new THREE.Matrix4();

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );

THREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {

	// update local

	if ( this.matrixAutoUpdate ) {

		forceUpdate |= this.updateMatrix();

	}

	// update skin matrix

	if ( forceUpdate || this.matrixWorldNeedsUpdate ) {

		if( parentSkinMatrix ) {

			this.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );

		} else {

			this.skinMatrix.copy( this.matrix );

		}

		this.matrixWorldNeedsUpdate = false;
		forceUpdate = true;

	}

	// update children

	var child, i, l = this.children.length;

	for ( i = 0; i < l; i ++ ) {

		this.children[ i ].update( this.skinMatrix, forceUpdate );

	}

};


/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	//

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	// init bones

	this.identityMatrix = new THREE.Matrix4();

	this.bones = [];
	this.boneMatrices = [];

	var b, bone, gbone, p, q, s;

	if ( this.geometry && this.geometry.bones !== undefined ) {

		for ( b = 0; b < this.geometry.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = this.addBone();

			bone.name = gbone.name;
			bone.position.set( p[0], p[1], p[2] );
			bone.quaternion.set( q[0], q[1], q[2], q[3] );

			if ( s !== undefined ) {

				bone.scale.set( s[0], s[1], s[2] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( b = 0; b < this.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];
			bone = this.bones[ b ];

			if ( gbone.parent === -1 ) {

				this.add( bone );

			} else {

				this.bones[ gbone.parent ].add( bone );

			}

		}

		//

		var nBones = this.bones.length;

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//	RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//  	 16x16 pixel texture max   64 bones (16 * 16 / 4)
			//  	 32x32 pixel texture max  256 bones (32 * 32 / 4)
			//  	 64x64 pixel texture max 1024 bones (64 * 64 / 4)

			var size;

			if ( nBones > 256 )
				size = 64;
			else if ( nBones > 64 )
				size = 32;
			else if ( nBones > 16 )
				size = 16;
			else
				size = 8;

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;

		} else {

			this.boneMatrices = new Float32Array( 16 * nBones );

		}

		this.pose();

	}

};

THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.addBone = function( bone ) {

	if ( bone === undefined ) {

		bone = new THREE.Bone( this );

	}

	this.bones.push( bone );

	return bone;

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {

	var offsetMatrix = new THREE.Matrix4();

	return function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			} else {

				this.matrixWorld.copy( this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child instanceof THREE.Bone ) {

				child.update( this.identityMatrix, false );

			} else {

				child.updateMatrixWorld( true );

			}

		}

		// make a snapshot of the bones' rest position

		if ( this.boneInverses == undefined ) {

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				var inverse = new THREE.Matrix4();

				inverse.getInverse( this.bones[ b ].skinMatrix );

				this.boneInverses.push( inverse );

			}

		}

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform;

			// TODO: we could get rid of this multiplication step if the skinMatrix
			// was already representing the offset; however, this requires some
			// major changes to the animation system

			offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}

	};

}();

THREE.SkinnedMesh.prototype.pose = function () {

	this.updateMatrixWorld( true );

	this.normalizeSkinWeights();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) {

		object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

	}

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = -1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		console.warn( "animation[" + label + "] undefined" );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= -1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	for ( var l = 0; l < this.objects.length; l ++ ) {

		if ( distance < this.objects[ l ].distance ) {

			break;

		}

	}

	this.objects.splice( l, 0, { distance: distance, object: object } );
	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

		if ( distance < this.objects[ i ].distance ) {

			break;

		}

	}

	return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( camera ) {

		if ( this.objects.length > 1 ) {

			v1.getPositionFromMatrix( camera.matrixWorld );
			v2.getPositionFromMatrix( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			this.objects[ 0 ].object.visible = true;

			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

				if ( distance >= this.objects[ i ].distance ) {

					this.objects[ i - 1 ].object.visible = false;
					this.objects[ i     ].object.visible = true;

				} else {

					break;

				}

			}

			for( ; i < l; i ++ ) {

				this.objects[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.clone = function () {

	// TODO

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = function ( material ) {

	THREE.Object3D.call( this );

	this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

};

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

/*
 * Custom update matrix
 */

THREE.Sprite.prototype.updateMatrix = function () {

	this.matrix.compose( this.position, this.quaternion, this.scale );

	this.matrixWorldNeedsUpdate = true;

};

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer
	this.matrixAutoUpdate = false;

	this.__lights = [];

	this.__objectsAdded = [];
	this.__objectsRemoved = [];

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.__addObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		if ( this.__lights.indexOf( object ) === - 1 ) {

			this.__lights.push( object );

		}

		if ( object.target && object.target.parent === undefined ) {

			this.add( object.target );

		}

	} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {

		this.__objectsAdded.push( object );

		// check if previously removed

		var i = this.__objectsRemoved.indexOf( object );

		if ( i !== -1 ) {

			this.__objectsRemoved.splice( i, 1 );

		}

	}

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__addObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.__removeObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		var i = this.__lights.indexOf( object );

		if ( i !== -1 ) {

			this.__lights.splice( i, 1 );

		}

		if ( object.shadowCascadeArray ) {

			for ( var x = 0; x < object.shadowCascadeArray.length; x ++ ) {

				this.__removeObject( object.shadowCascadeArray[ x ] );

			}

		}

	} else if ( !( object instanceof THREE.Camera ) ) {

		this.__objectsRemoved.push( object );

		// check if previously added

		var i = this.__objectsAdded.indexOf( object );

		if ( i !== -1 ) {

			this.__objectsAdded.splice( i, 1 );

		}

	}

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__removeObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Scene();

	THREE.Object3D.prototype.clone.call(this, object);

	if ( this.fog !== null ) object.fog = this.fog.clone();
	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

	object.autoUpdate = this.autoUpdate;
	object.matrixAutoUpdate = this.matrixAutoUpdate;

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( hex, near, far ) {

	this.name = '';

	this.color = new THREE.Color( hex );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( hex, density ) {

	this.name = '';

	this.color = new THREE.Color( hex );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasRenderer = function ( parameters ) {

	console.log( 'THREE.CanvasRenderer', THREE.REVISION );

	var smoothstep = THREE.Math.smoothstep;

	parameters = parameters || {};

	var _this = this,
	_renderData, _elements, _lights,
	_projector = new THREE.Projector(),

	_canvas = parameters.canvas !== undefined
			? parameters.canvas
			: document.createElement( 'canvas' ),

	_canvasWidth = _canvas.width,
	_canvasHeight = _canvas.height,
	_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),
	_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),

	_context = _canvas.getContext( '2d' ),

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0,

	_contextGlobalAlpha = 1,
	_contextGlobalCompositeOperation = 0,
	_contextStrokeStyle = null,
	_contextFillStyle = null,
	_contextLineWidth = null,
	_contextLineCap = null,
	_contextLineJoin = null,
	_contextDashSize = null,
	_contextGapSize = 0,

	_camera,

	_v1, _v2, _v3, _v4,
	_v5 = new THREE.RenderableVertex(),
	_v6 = new THREE.RenderableVertex(),

	_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,
	_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,

	_color = new THREE.Color(),
	_color1 = new THREE.Color(),
	_color2 = new THREE.Color(),
	_color3 = new THREE.Color(),
	_color4 = new THREE.Color(),

	_diffuseColor = new THREE.Color(),
	_emissiveColor = new THREE.Color(),

	_lightColor = new THREE.Color(),

	_patterns = {}, _imagedatas = {},

	_near, _far,

	_image, _uvs,
	_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,

	_clipBox = new THREE.Box2(),
	_clearBox = new THREE.Box2(),
	_elemBox = new THREE.Box2(),

	_ambientLight = new THREE.Color(),
	_directionalLights = new THREE.Color(),
	_pointLights = new THREE.Color(),

	_vector3 = new THREE.Vector3(), // Needed for PointLight

	_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,
	_gradientMap, _gradientMapContext, _gradientMapQuality = 16;

	_pixelMap = document.createElement( 'canvas' );
	_pixelMap.width = _pixelMap.height = 2;

	_pixelMapContext = _pixelMap.getContext( '2d' );
	_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
	_pixelMapContext.fillRect( 0, 0, 2, 2 );

	_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );
	_pixelMapData = _pixelMapImage.data;

	_gradientMap = document.createElement( 'canvas' );
	_gradientMap.width = _gradientMap.height = _gradientMapQuality;

	_gradientMapContext = _gradientMap.getContext( '2d' );
	_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );
	_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );

	_gradientMapQuality --; // Fix UVs

	// dash+gap fallbacks for Firefox and everything else

	if ( _context.setLineDash === undefined ) {

		if ( _context.mozDash !== undefined ) {

			_context.setLineDash = function ( values ) {

				_context.mozDash = values[ 0 ] !== null ? values : null;

			}

		} else {

			_context.setLineDash = function () {}

		}

	}

	this.domElement = _canvas;

	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	this.autoClear = true;
	this.sortObjects = true;
	this.sortElements = true;

	this.info = {

		render: {

			vertices: 0,
			faces: 0

		}

	}

	// WebGLRenderer compatibility

	this.supportsVertexTextures = function () {};
	this.setFaceCulling = function () {};

	this.setSize = function ( width, height, updateStyle ) {

		_canvasWidth = width * this.devicePixelRatio;
		_canvasHeight = height * this.devicePixelRatio;

		_canvasWidthHalf = Math.floor( _canvasWidth / 2 );
		_canvasHeightHalf = Math.floor( _canvasHeight / 2 );

		_canvas.width = _canvasWidth;
		_canvas.height = _canvasHeight;

		if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		_clipBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

		_clearBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

		_contextGlobalAlpha = 1;
		_contextGlobalCompositeOperation = 0;
		_contextStrokeStyle = null;
		_contextFillStyle = null;
		_contextLineWidth = null;
		_contextLineCap = null;
		_contextLineJoin = null;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_clearBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getMaxAnisotropy = function () {

		return 0;

	};

	this.clear = function () {

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		if ( _clearBox.empty() === false ) {

			_clearBox.intersect( _clipBox );
			_clearBox.expandByScalar( 2 );

			if ( _clearAlpha < 1 ) {

				_context.clearRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			if ( _clearAlpha > 0 ) {

				setBlending( THREE.NormalBlending );
				setOpacity( 1 );

				setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );

				_context.fillRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			_clearBox.makeEmpty();

		}


	};

	this.render = function ( scene, camera ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( this.autoClear === true ) this.clear();

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;

		_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
		_elements = _renderData.elements;
		_lights = _renderData.lights;
		_camera = camera;

		/* DEBUG
		setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );
		_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );
		*/

		calculateLights();

		for ( var e = 0, el = _elements.length; e < el; e++ ) {

			var element = _elements[ e ];

			var material = element.material;

			if ( material === undefined || material.visible === false ) continue;

			_elemBox.makeEmpty();

			if ( element instanceof THREE.RenderableSprite ) {

				_v1 = element;
				_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;

				renderSprite( _v1, element, material );

			} else if ( element instanceof THREE.RenderableLine ) {

				_v1 = element.v1; _v2 = element.v2;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;

				_elemBox.setFromPoints( [
					_v1.positionScreen,
					_v2.positionScreen
				] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderLine( _v1, _v2, element, material );

				}

			} else if ( element instanceof THREE.RenderableFace3 ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

				if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
				if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
				if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
				_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;

				if ( material.overdraw > 0 ) {

					expand( _v1.positionScreen, _v2.positionScreen, material.overdraw );
					expand( _v2.positionScreen, _v3.positionScreen, material.overdraw );
					expand( _v3.positionScreen, _v1.positionScreen, material.overdraw );

				}

				_elemBox.setFromPoints( [
					_v1.positionScreen,
					_v2.positionScreen,
					_v3.positionScreen
				] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );

				}

			}

			/* DEBUG
			setLineWidth( 1 );
			setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );
			_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );
			*/

			_clearBox.union( _elemBox );

		}

		/* DEBUG
		setLineWidth( 1 );
		setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );
		_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );
		*/

		_context.setTransform( 1, 0, 0, 1, 0, 0 );

	};

	//

	function calculateLights() {

		_ambientLight.setRGB( 0, 0, 0 );
		_directionalLights.setRGB( 0, 0, 0 );
		_pointLights.setRGB( 0, 0, 0 );

		for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

			var light = _lights[ l ];
			var lightColor = light.color;

			if ( light instanceof THREE.AmbientLight ) {

				_ambientLight.add( lightColor );

			} else if ( light instanceof THREE.DirectionalLight ) {

				// for sprites

				_directionalLights.add( lightColor );

			} else if ( light instanceof THREE.PointLight ) {

				// for sprites

				_pointLights.add( lightColor );

			}

		}

	}

	function calculateLight( position, normal, color ) {

		for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

			var light = _lights[ l ];

			_lightColor.copy( light.color );

			if ( light instanceof THREE.DirectionalLight ) {

				var lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld ).normalize();

				var amount = normal.dot( lightPosition );

				if ( amount <= 0 ) continue;

				amount *= light.intensity;

				color.add( _lightColor.multiplyScalar( amount ) );

			} else if ( light instanceof THREE.PointLight ) {

				var lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld );

				var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );

				if ( amount <= 0 ) continue;

				amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

				if ( amount == 0 ) continue;

				amount *= light.intensity;

				color.add( _lightColor.multiplyScalar( amount ) );

			}

		}

	}

	function renderSprite( v1, element, material ) {

		setOpacity( material.opacity );
		setBlending( material.blending );

		var scaleX = element.scale.x * _canvasWidthHalf;
		var scaleY = element.scale.y * _canvasHeightHalf;

		_elemBox.min.set( v1.x - ( scaleX * 0.5 ), v1.y - ( scaleY * 0.5 ) );
		_elemBox.max.set( v1.x + ( scaleX * 0.5 ), v1.y + ( scaleY * 0.5 ) );

		if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {

			_elemBox.makeEmpty();
			return;

		}

		if ( material instanceof THREE.SpriteMaterial ||
			 material instanceof THREE.ParticleSystemMaterial ) { // Backwards compatibility

			if ( material.map !== null ) {

				var bitmap = material.map.image;

				_context.save();
				_context.translate( v1.x, v1.y );
				_context.rotate( - material.rotation );
				_context.scale( scaleX, - scaleY );

				_context.drawImage( bitmap, 0, 0, bitmap.width, bitmap.height, - 0.5, - 0.5, 1, 1 );
				_context.restore();

			} else {

				setFillStyle( material.color.getStyle() );

				_context.save();
				_context.translate( v1.x, v1.y );
				_context.rotate( - element.rotation );
				_context.scale( scaleX, scaleY );
				_context.fillRect( - 0.5, - 0.5, 1, 1 );
				_context.restore();

			}

		} else if ( material instanceof THREE.SpriteCanvasMaterial ) {

			setStrokeStyle( material.color.getStyle() );
			setFillStyle( material.color.getStyle() );

			_context.save();
			_context.translate( v1.x, v1.y );
			_context.rotate( - element.rotation );
			_context.scale( scaleX, scaleY );

			material.program( _context );

			_context.restore();

		}

		/* DEBUG
		setStrokeStyle( 'rgb(255,255,0)' );
		_context.beginPath();
		_context.moveTo( v1.x - 10, v1.y );
		_context.lineTo( v1.x + 10, v1.y );
		_context.moveTo( v1.x, v1.y - 10 );
		_context.lineTo( v1.x, v1.y + 10 );
		_context.stroke();
		*/

	}

	function renderLine( v1, v2, element, material ) {

		setOpacity( material.opacity );
		setBlending( material.blending );

		_context.beginPath();
		_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
		_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );

		if ( material instanceof THREE.LineBasicMaterial ) {

			setLineWidth( material.linewidth );
			setLineCap( material.linecap );
			setLineJoin( material.linejoin );

			if ( material.vertexColors !== THREE.VertexColors ) {

				setStrokeStyle( material.color.getStyle() );

			} else {

				var colorStyle1 = element.vertexColors[0].getStyle();
				var colorStyle2 = element.vertexColors[1].getStyle();

				if ( colorStyle1 === colorStyle2 ) {

					setStrokeStyle( colorStyle1 );

				} else {

					try {

						var grad = _context.createLinearGradient(
							v1.positionScreen.x,
							v1.positionScreen.y,
							v2.positionScreen.x,
							v2.positionScreen.y
						);
						grad.addColorStop( 0, colorStyle1 );
						grad.addColorStop( 1, colorStyle2 );

					} catch ( exception ) {

						grad = colorStyle1;

					}

					setStrokeStyle( grad );

				}

			}

			_context.stroke();
			_elemBox.expandByScalar( material.linewidth * 2 );

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			setLineWidth( material.linewidth );
			setLineCap( material.linecap );
			setLineJoin( material.linejoin );
			setStrokeStyle( material.color.getStyle() );
			setDashAndGap( material.dashSize, material.gapSize );

			_context.stroke();

			_elemBox.expandByScalar( material.linewidth * 2 );

			setDashAndGap( null, null );

		}

	}

	function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {

		_this.info.render.vertices += 3;
		_this.info.render.faces ++;

		setOpacity( material.opacity );
		setBlending( material.blending );

		_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
		_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
		_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;

		drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );

		if ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {

			_diffuseColor.copy( material.color );
			_emissiveColor.copy( material.emissive );

			if ( material.vertexColors === THREE.FaceColors ) {

				_diffuseColor.multiply( element.color );

			}

			if ( material.wireframe === false && material.shading === THREE.SmoothShading && element.vertexNormalsLength === 3 ) {

				_color1.copy( _ambientLight );
				_color2.copy( _ambientLight );
				_color3.copy( _ambientLight );

				calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
				calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
				calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );

				_color1.multiply( _diffuseColor ).add( _emissiveColor );
				_color2.multiply( _diffuseColor ).add( _emissiveColor );
				_color3.multiply( _diffuseColor ).add( _emissiveColor );
				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			} else {

				_color.copy( _ambientLight );

				calculateLight( element.centroidModel, element.normalModel, _color );

				_color.multiply( _diffuseColor ).add( _emissiveColor );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			}

		} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {

			if ( material.map !== null ) {

				if ( material.map.mapping instanceof THREE.UVMapping ) {

					_uvs = element.uvs[ 0 ];
					patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );

				}


			} else if ( material.envMap !== null ) {

				if ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {

					_vector3.copy( element.vertexNormalsModelView[ uv1 ] );
					_uv1x = 0.5 * _vector3.x + 0.5;
					_uv1y = 0.5 * _vector3.y + 0.5;

					_vector3.copy( element.vertexNormalsModelView[ uv2 ] );
					_uv2x = 0.5 * _vector3.x + 0.5;
					_uv2y = 0.5 * _vector3.y + 0.5;

					_vector3.copy( element.vertexNormalsModelView[ uv3 ] );
					_uv3x = 0.5 * _vector3.x + 0.5;
					_uv3y = 0.5 * _vector3.y + 0.5;

					patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );

				}/* else if ( material.envMap.mapping === THREE.SphericalRefractionMapping ) {



				}*/


			} else {

				_color.copy( material.color );

				if ( material.vertexColors === THREE.FaceColors ) {

					_color.multiply( element.color );

				}

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			}

		} else if ( material instanceof THREE.MeshDepthMaterial ) {

			_near = _camera.near;
			_far = _camera.far;

			_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
			_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
			_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );
			_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

			_image = getGradientTexture( _color1, _color2, _color3, _color4 );

			clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			var normal;

			if ( material.shading === THREE.FlatShading ) {

				normal = element.normalModelView;

				_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			} else if ( material.shading === THREE.SmoothShading ) {

				normal = element.vertexNormalsModelView[ uv1 ];
				_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				normal = element.vertexNormalsModelView[ uv2 ];
				_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				normal = element.vertexNormalsModelView[ uv3 ];
				_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			}

		}

	}

	//

	function drawTriangle( x0, y0, x1, y1, x2, y2 ) {

		_context.beginPath();
		_context.moveTo( x0, y0 );
		_context.lineTo( x1, y1 );
		_context.lineTo( x2, y2 );
		_context.closePath();

	}

	function strokePath( color, linewidth, linecap, linejoin ) {

		setLineWidth( linewidth );
		setLineCap( linecap );
		setLineJoin( linejoin );
		setStrokeStyle( color.getStyle() );

		_context.stroke();

		_elemBox.expandByScalar( linewidth * 2 );

	}

	function fillPath( color ) {

		setFillStyle( color.getStyle() );
		_context.fill();

	}

	function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {

		if ( texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width === 0 ) return;

		if ( texture.needsUpdate === true ) {

			var repeatX = texture.wrapS === THREE.RepeatWrapping;
			var repeatY = texture.wrapT === THREE.RepeatWrapping;

			_patterns[ texture.id ] = _context.createPattern(
				texture.image, repeatX === true && repeatY === true
					? 'repeat'
					: repeatX === true && repeatY === false
						? 'repeat-x'
						: repeatX === false && repeatY === true
							? 'repeat-y'
							: 'no-repeat'
			);

			texture.needsUpdate = false;

		}

		_patterns[ texture.id ] === undefined
			? setFillStyle( 'rgba(0,0,0,1)' )
			: setFillStyle( _patterns[ texture.id ] );

		// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

		var a, b, c, d, e, f, det, idet,
		offsetX = texture.offset.x / texture.repeat.x,
		offsetY = texture.offset.y / texture.repeat.y,
		width = texture.image.width * texture.repeat.x,
		height = texture.image.height * texture.repeat.y;

		u0 = ( u0 + offsetX ) * width;
		v0 = ( 1.0 - v0 + offsetY ) * height;

		u1 = ( u1 + offsetX ) * width;
		v1 = ( 1.0 - v1 + offsetY ) * height;

		u2 = ( u2 + offsetX ) * width;
		v2 = ( 1.0 - v2 + offsetY ) * height;

		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;

		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;

		det = u1 * v2 - u2 * v1;

		if ( det === 0 ) {

			if ( _imagedatas[ texture.id ] === undefined ) {

				var canvas = document.createElement( 'canvas' )
				canvas.width = texture.image.width;
				canvas.height = texture.image.height;

				var context = canvas.getContext( '2d' );
				context.drawImage( texture.image, 0, 0 );

				_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;

			}

			var data = _imagedatas[ texture.id ];
			var index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;

			_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );
			fillPath( _color );

			return;

		}

		idet = 1 / det;

		a = ( v2 * x1 - v1 * x2 ) * idet;
		b = ( v2 * y1 - v1 * y2 ) * idet;
		c = ( u1 * x2 - u2 * x1 ) * idet;
		d = ( u1 * y2 - u2 * y1 ) * idet;

		e = x0 - a * u0 - c * v0;
		f = y0 - b * u0 - d * v0;

		_context.save();
		_context.transform( a, b, c, d, e, f );
		_context.fill();
		_context.restore();

	}

	function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {

		// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

		var a, b, c, d, e, f, det, idet,
		width = image.width - 1,
		height = image.height - 1;

		u0 *= width; v0 *= height;
		u1 *= width; v1 *= height;
		u2 *= width; v2 *= height;

		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;

		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;

		det = u1 * v2 - u2 * v1;

		idet = 1 / det;

		a = ( v2 * x1 - v1 * x2 ) * idet;
		b = ( v2 * y1 - v1 * y2 ) * idet;
		c = ( u1 * x2 - u2 * x1 ) * idet;
		d = ( u1 * y2 - u2 * y1 ) * idet;

		e = x0 - a * u0 - c * v0;
		f = y0 - b * u0 - d * v0;

		_context.save();
		_context.transform( a, b, c, d, e, f );
		_context.clip();
		_context.drawImage( image, 0, 0 );
		_context.restore();

	}

	function getGradientTexture( color1, color2, color3, color4 ) {

		// http://mrdoob.com/blog/post/710

		_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;
		_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;
		_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;

		_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;
		_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;
		_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;

		_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;
		_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;
		_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;

		_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;
		_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;
		_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;

		_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );
		_gradientMapContext.drawImage( _pixelMap, 0, 0 );

		return _gradientMap;

	}

	// Hide anti-alias gaps

	function expand( v1, v2, pixels ) {

		var x = v2.x - v1.x, y = v2.y - v1.y,
		det = x * x + y * y, idet;

		if ( det === 0 ) return;

		idet = pixels / Math.sqrt( det );

		x *= idet; y *= idet;

		v2.x += x; v2.y += y;
		v1.x -= x; v1.y -= y;

	}

	// Context cached methods.

	function setOpacity( value ) {

		if ( _contextGlobalAlpha !== value ) {

			_context.globalAlpha = value;
			_contextGlobalAlpha = value;

		}

	}

	function setBlending( value ) {

		if ( _contextGlobalCompositeOperation !== value ) {

			if ( value === THREE.NormalBlending ) {

				_context.globalCompositeOperation = 'source-over';

			} else if ( value === THREE.AdditiveBlending ) {

				_context.globalCompositeOperation = 'lighter';

			} else if ( value === THREE.SubtractiveBlending ) {

				_context.globalCompositeOperation = 'darker';

			}

			_contextGlobalCompositeOperation = value;

		}

	}

	function setLineWidth( value ) {

		if ( _contextLineWidth !== value ) {

			_context.lineWidth = value;
			_contextLineWidth = value;

		}

	}

	function setLineCap( value ) {

		// "butt", "round", "square"

		if ( _contextLineCap !== value ) {

			_context.lineCap = value;
			_contextLineCap = value;

		}

	}

	function setLineJoin( value ) {

		// "round", "bevel", "miter"

		if ( _contextLineJoin !== value ) {

			_context.lineJoin = value;
			_contextLineJoin = value;

		}

	}

	function setStrokeStyle( value ) {

		if ( _contextStrokeStyle !== value ) {

			_context.strokeStyle = value;
			_contextStrokeStyle = value;

		}

	}

	function setFillStyle( value ) {

		if ( _contextFillStyle !== value ) {

			_context.fillStyle = value;
			_contextFillStyle = value;

		}

	}

	function setDashAndGap( dashSizeValue, gapSizeValue ) {

		if ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {

			_context.setLineDash( [ dashSizeValue, gapSizeValue ] );
			_contextDashSize = dashSizeValue;
			_contextGapSize = gapSizeValue;

		}

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderChunk = {

	// FOG

	fog_pars_fragment: [

		"#ifdef USE_FOG",

			"uniform vec3 fogColor;",

			"#ifdef FOG_EXP2",

				"uniform float fogDensity;",

			"#else",

				"uniform float fogNear;",
				"uniform float fogFar;",

			"#endif",

		"#endif"

	].join("\n"),

	fog_fragment: [

		"#ifdef USE_FOG",

			"float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"#ifdef FOG_EXP2",

				"const float LOG2 = 1.442695;",
				"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
				"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",

			"#else",

				"float fogFactor = smoothstep( fogNear, fogFar, depth );",

			"#endif",

			"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

		"#endif"

	].join("\n"),

	// ENVIRONMENT MAP

	envmap_pars_fragment: [

		"#ifdef USE_ENVMAP",

			"uniform float reflectivity;",
			"uniform samplerCube envMap;",
			"uniform float flipEnvMap;",
			"uniform int combine;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"uniform bool useRefract;",
				"uniform float refractionRatio;",

			"#else",

				"varying vec3 vReflect;",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_fragment: [

		"#ifdef USE_ENVMAP",

			"vec3 reflectVec;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

				"if ( useRefract ) {",

					"reflectVec = refract( cameraToVertex, normal, refractionRatio );",

				"} else { ",

					"reflectVec = reflect( cameraToVertex, normal );",

				"}",

			"#else",

				"reflectVec = vReflect;",

			"#endif",

			"#ifdef DOUBLE_SIDED",

				"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
				"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#else",

				"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#endif",

			"#ifdef GAMMA_INPUT",

				"cubeColor.xyz *= cubeColor.xyz;",

			"#endif",

			"if ( combine == 1 ) {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );",

			"} else if ( combine == 2 ) {",

				"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;",

			"} else {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );",

			"}",

		"#endif"

	].join("\n"),

	envmap_pars_vertex: [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"varying vec3 vReflect;",

			"uniform float refractionRatio;",
			"uniform bool useRefract;",

		"#endif"

	].join("\n"),

	worldpos_vertex : [

		"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",

			"#ifdef USE_SKINNING",

				"vec4 worldPosition = modelMatrix * skinned;",

			"#endif",

			"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",

			"#endif",

			"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_vertex : [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
			"worldNormal = normalize( worldNormal );",

			"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",

			"if ( useRefract ) {",

				"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",

			"} else {",

				"vReflect = reflect( cameraToVertex, worldNormal );",

			"}",

		"#endif"

	].join("\n"),

	// COLOR MAP (particles)

	map_particle_pars_fragment: [

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),


	map_particle_fragment: [

		"#ifdef USE_MAP",

			"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );",

		"#endif"

	].join("\n"),

	// COLOR MAP (triangles)

	map_pars_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"varying vec2 vUv;",
			"uniform vec4 offsetRepeat;",

		"#endif"

	].join("\n"),

	map_pars_fragment: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"varying vec2 vUv;",

		"#endif",

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),

	map_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",

		"#endif"

	].join("\n"),

	map_fragment: [

		"#ifdef USE_MAP",

			"vec4 texelColor = texture2D( map, vUv );",

			"#ifdef GAMMA_INPUT",

				"texelColor.xyz *= texelColor.xyz;",

			"#endif",

			"gl_FragColor = gl_FragColor * texelColor;",

		"#endif"

	].join("\n"),

	// LIGHT MAP

	lightmap_pars_fragment: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",
			"uniform sampler2D lightMap;",

		"#endif"

	].join("\n"),

	lightmap_pars_vertex: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",

		"#endif"

	].join("\n"),

	lightmap_fragment: [

		"#ifdef USE_LIGHTMAP",

			"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",

		"#endif"

	].join("\n"),

	lightmap_vertex: [

		"#ifdef USE_LIGHTMAP",

			"vUv2 = uv2;",

		"#endif"

	].join("\n"),

	// BUMP MAP

	bumpmap_pars_fragment: [

		"#ifdef USE_BUMPMAP",

			"uniform sampler2D bumpMap;",
			"uniform float bumpScale;",

			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

			"vec2 dHdxy_fwd() {",

				"vec2 dSTdx = dFdx( vUv );",
				"vec2 dSTdy = dFdy( vUv );",

				"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
				"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
				"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",

				"return vec2( dBx, dBy );",

			"}",

			"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

				"vec3 vSigmaX = dFdx( surf_pos );",
				"vec3 vSigmaY = dFdy( surf_pos );",
				"vec3 vN = surf_norm;",		// normalized

				"vec3 R1 = cross( vSigmaY, vN );",
				"vec3 R2 = cross( vN, vSigmaX );",

				"float fDet = dot( vSigmaX, R1 );",

				"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
				"return normalize( abs( fDet ) * surf_norm - vGrad );",

			"}",

		"#endif"

	].join("\n"),

	// NORMAL MAP

	normalmap_pars_fragment: [

		"#ifdef USE_NORMALMAP",

			"uniform sampler2D normalMap;",
			"uniform vec2 normalScale;",

			// Per-Pixel Tangent Space Normal Mapping
			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

			"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",

				"vec3 q0 = dFdx( eye_pos.xyz );",
				"vec3 q1 = dFdy( eye_pos.xyz );",
				"vec2 st0 = dFdx( vUv.st );",
				"vec2 st1 = dFdy( vUv.st );",

				"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
				"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
				"vec3 N = normalize( surf_norm );",

				"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
				"mapN.xy = normalScale * mapN.xy;",
				"mat3 tsn = mat3( S, T, N );",
				"return normalize( tsn * mapN );",

			"}",

		"#endif"

	].join("\n"),

	// SPECULAR MAP

	specularmap_pars_fragment: [

		"#ifdef USE_SPECULARMAP",

			"uniform sampler2D specularMap;",

		"#endif"

	].join("\n"),

	specularmap_fragment: [

		"float specularStrength;",

		"#ifdef USE_SPECULARMAP",

			"vec4 texelSpecular = texture2D( specularMap, vUv );",
			"specularStrength = texelSpecular.r;",

		"#else",

			"specularStrength = 1.0;",

		"#endif"

	].join("\n"),

	// LIGHTS LAMBERT

	lights_lambert_pars_vertex: [

		"uniform vec3 ambient;",
		"uniform vec3 diffuse;",
		"uniform vec3 emissive;",

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif"

	].join("\n"),

	lights_lambert_vertex: [

		"vLightFront = vec3( 0.0 );",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vec3( 0.0 );",

		"#endif",

		"transformedNormal = normalize( transformedNormal );",

		"#if MAX_DIR_LIGHTS > 0",

		"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

			"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"vec3 dirVector = normalize( lDirection.xyz );",

			"float dotProduct = dot( transformedNormal, dirVector );",
			"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",

			"#ifdef DOUBLE_SIDED",

				"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

				"#ifdef WRAP_AROUND",

					"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

				"#endif",

			"#endif",

			"#ifdef WRAP_AROUND",

				"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
				"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",

				"#ifdef DOUBLE_SIDED",

					"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",

				"#endif",

			"#endif",

			"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",

			"#ifdef DOUBLE_SIDED",

				"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",

			"#endif",

		"}",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"lVector = normalize( lVector );",
				"float dotProduct = dot( transformedNormal, lVector );",

				"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",

				"#ifdef DOUBLE_SIDED",

					"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

					"#ifdef WRAP_AROUND",

						"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

					"#endif",

				"#endif",

				"#ifdef WRAP_AROUND",

					"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
					"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",

					"#ifdef DOUBLE_SIDED",

						"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",

					"#endif",

				"#endif",

				"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

					"float dotProduct = dot( transformedNormal, lVector );",
					"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",

					"#ifdef DOUBLE_SIDED",

						"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

						"#ifdef WRAP_AROUND",

							"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

						"#endif",

					"#endif",

					"#ifdef WRAP_AROUND",

						"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
						"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",

						"#ifdef DOUBLE_SIDED",

							"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",

						"#endif",

					"#endif",

					"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",

					"#ifdef DOUBLE_SIDED",

						"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				"float dotProduct = dot( transformedNormal, lVector );",

				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
				"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",

				"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",

				"#endif",

			"}",

		"#endif",

		"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",

		"#endif"

	].join("\n"),

	// LIGHTS PHONG

	lights_phong_pars_vertex: [

		"#ifndef PHONG_PER_PIXEL",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif"

	].join("\n"),


	lights_phong_vertex: [

		"#ifndef PHONG_PER_PIXEL",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"vPointLight[ i ] = vec4( lVector, lDistance );",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( spotLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

				"vSpotLight[ i ] = vec4( lVector, lDistance );",

			"}",

		"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"vWorldPosition = worldPosition.xyz;",

		"#endif"

	].join("\n"),

	lights_phong_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",

			"#ifdef PHONG_PER_PIXEL",

				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#else",

				"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

			"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

			"#ifdef PHONG_PER_PIXEL",

				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#else",

				"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",

			"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;"

	].join("\n"),

	lights_phong_fragment: [

		"vec3 normal = normalize( vNormal );",
		"vec3 viewPosition = normalize( vViewPosition );",

		"#ifdef DOUBLE_SIDED",

			"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

		"#endif",

		"#ifdef USE_NORMALMAP",

			"normal = perturbNormal2Arb( -vViewPosition, normal );",

		"#elif defined( USE_BUMPMAP )",

			"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"vec3 pointDiffuse  = vec3( 0.0 );",
			"vec3 pointSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"#ifdef PHONG_PER_PIXEL",

					"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

					"float lDistance = 1.0;",
					"if ( pointLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

				"#else",

					"vec3 lVector = normalize( vPointLight[ i ].xyz );",
					"float lDistance = vPointLight[ i ].w;",

				"#endif",

				// diffuse

				"float dotProduct = dot( normal, lVector );",

				"#ifdef WRAP_AROUND",

					"float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float pointDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",

				// specular

				"vec3 pointHalfVector = normalize( lVector + viewPosition );",
				"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
				"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

				"#ifdef PHYSICALLY_BASED_SHADING",

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );",
					"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",

				"#else",

					"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"vec3 spotDiffuse  = vec3( 0.0 );",
			"vec3 spotSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"#ifdef PHONG_PER_PIXEL",

					"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

				"#else",

					"vec3 lVector = normalize( vSpotLight[ i ].xyz );",
					"float lDistance = vSpotLight[ i ].w;",

				"#endif",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					// diffuse

					"float dotProduct = dot( normal, lVector );",

					"#ifdef WRAP_AROUND",

						"float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

						"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

					"#else",

						"float spotDiffuseWeight = max( dotProduct, 0.0 );",

					"#endif",

					"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",

					// specular

					"vec3 spotHalfVector = normalize( lVector + viewPosition );",
					"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
					"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

					"#ifdef PHYSICALLY_BASED_SHADING",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );",
						"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",

					"#else",

						"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"vec3 dirDiffuse  = vec3( 0.0 );",
			"vec3 dirSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 dirVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, dirVector );",

				"#ifdef WRAP_AROUND",

					"float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float dirDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",

				// specular

				"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
				"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
				"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

				"#ifdef PHYSICALLY_BASED_SHADING",

					/*
					// fresnel term from skin shader
					"const float F0 = 0.128;",

					"float base = 1.0 - dot( viewPosition, dirHalfVector );",
					"float exponential = pow( base, 5.0 );",

					"float fresnel = exponential + F0 * ( 1.0 - exponential );",
					*/

					/*
					// fresnel term from fresnel shader
					"const float mFresnelBias = 0.08;",
					"const float mFresnelScale = 0.3;",
					"const float mFresnelPower = 5.0;",

					"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );",
					*/

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
					"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

				"#else",

					"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"vec3 hemiDiffuse  = vec3( 0.0 );",
			"vec3 hemiSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",
				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

				"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"hemiDiffuse += diffuse * hemiColor;",

				// specular (sky light)

				"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
				"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
				"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

				// specular (ground light)

				"vec3 lVectorGround = -lVector;",

				"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
				"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
				"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

				"#ifdef PHYSICALLY_BASED_SHADING",

					"float dotProductGround = dot( normal, lVectorGround );",

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
					"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
					"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

				"#else",

					"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",

				"#endif",

			"}",

		"#endif",

		"vec3 totalDiffuse = vec3( 0.0 );",
		"vec3 totalSpecular = vec3( 0.0 );",

		"#if MAX_DIR_LIGHTS > 0",

			"totalDiffuse += dirDiffuse;",
			"totalSpecular += dirSpecular;",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"totalDiffuse += hemiDiffuse;",
			"totalSpecular += hemiSpecular;",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"totalDiffuse += pointDiffuse;",
			"totalSpecular += pointSpecular;",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"totalDiffuse += spotDiffuse;",
			"totalSpecular += spotSpecular;",

		"#endif",

		"#ifdef METAL",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",

		"#else",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

		"#endif"

	].join("\n"),

	// VERTEX COLORS

	color_pars_fragment: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_fragment: [

		"#ifdef USE_COLOR",

			"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );",

		"#endif"

	].join("\n"),

	color_pars_vertex: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_vertex: [

		"#ifdef USE_COLOR",

			"#ifdef GAMMA_INPUT",

				"vColor = color * color;",

			"#else",

				"vColor = color;",

			"#endif",

		"#endif"

	].join("\n"),

	// SKINNING

	skinning_pars_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef BONE_TEXTURE",

				"uniform sampler2D boneTexture;",
				"uniform int boneTextureWidth;",
				"uniform int boneTextureHeight;",

				"mat4 getBoneMatrix( const in float i ) {",

					"float j = i * 4.0;",
					"float x = mod( j, float( boneTextureWidth ) );",
					"float y = floor( j / float( boneTextureWidth ) );",

					"float dx = 1.0 / float( boneTextureWidth );",
					"float dy = 1.0 / float( boneTextureHeight );",

					"y = dy * ( y + 0.5 );",

					"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
					"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
					"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
					"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",

					"mat4 bone = mat4( v1, v2, v3, v4 );",

					"return bone;",

				"}",

			"#else",

				"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",

				"mat4 getBoneMatrix( const in float i ) {",

					"mat4 bone = boneGlobalMatrices[ int(i) ];",
					"return bone;",

				"}",

			"#endif",

		"#endif"

	].join("\n"),

	skinbase_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 boneMatX = getBoneMatrix( skinIndex.x );",
			"mat4 boneMatY = getBoneMatrix( skinIndex.y );",

		"#endif"

	].join("\n"),

	skinning_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef USE_MORPHTARGETS",

			"vec4 skinVertex = vec4( morphed, 1.0 );",

			"#else",

			"vec4 skinVertex = vec4( position, 1.0 );",

			"#endif",

			"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
			"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

		"#endif"

	].join("\n"),

	// MORPHING

	morphtarget_pars_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"#ifndef USE_MORPHNORMALS",

			"uniform float morphTargetInfluences[ 8 ];",

			"#else",

			"uniform float morphTargetInfluences[ 4 ];",

			"#endif",

		"#endif"

	].join("\n"),

	morphtarget_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"vec3 morphed = vec3( 0.0 );",
			"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
			"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
			"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
			"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",

			"#ifndef USE_MORPHNORMALS",

			"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
			"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
			"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
			"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",

			"#endif",

			"morphed += position;",

		"#endif"

	].join("\n"),

	default_vertex : [

		"vec4 mvPosition;",

		"#ifdef USE_SKINNING",

			"mvPosition = modelViewMatrix * skinned;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( position, 1.0 );",

		"#endif",

		"gl_Position = projectionMatrix * mvPosition;"

	].join("\n"),

	morphnormal_vertex: [

		"#ifdef USE_MORPHNORMALS",

			"vec3 morphedNormal = vec3( 0.0 );",

			"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
			"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
			"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
			"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",

			"morphedNormal += normal;",

		"#endif"

	].join("\n"),

	skinnormal_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 skinMatrix = skinWeight.x * boneMatX;",
			"skinMatrix 	+= skinWeight.y * boneMatY;",

			"#ifdef USE_MORPHNORMALS",

			"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",

			"#else",

			"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	defaultnormal_vertex: [

		"vec3 objectNormal;",

		"#ifdef USE_SKINNING",

			"objectNormal = skinnedNormal.xyz;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",

			"objectNormal = morphedNormal;",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",

			"objectNormal = normal;",

		"#endif",

		"#ifdef FLIP_SIDED",

			"objectNormal = -objectNormal;",

		"#endif",

		"vec3 transformedNormal = normalMatrix * objectNormal;"

	].join("\n"),

	// SHADOW MAP

	// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
	//  http://spidergl.org/example.php?id=6
	// 	http://fabiensanglard.net/shadowmapping

	shadowmap_pars_fragment: [

		"#ifdef USE_SHADOWMAP",

			"uniform sampler2D shadowMap[ MAX_SHADOWS ];",
			"uniform vec2 shadowMapSize[ MAX_SHADOWS ];",

			"uniform float shadowDarkness[ MAX_SHADOWS ];",
			"uniform float shadowBias[ MAX_SHADOWS ];",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",

			"float unpackDepth( const in vec4 rgba_depth ) {",

				"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"float depth = dot( rgba_depth, bit_shift );",
				"return depth;",

			"}",

		"#endif"

	].join("\n"),

	shadowmap_fragment: [

		"#ifdef USE_SHADOWMAP",

			"#ifdef SHADOWMAP_DEBUG",

				"vec3 frustumColors[3];",
				"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
				"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
				"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",

			"#endif",

			"#ifdef SHADOWMAP_CASCADE",

				"int inFrustumCount = 0;",

			"#endif",

			"float fDepth;",
			"vec3 shadowColor = vec3( 1.0 );",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",

				// "if ( something && something )" 		 breaks ATI OpenGL shader compiler
				// "if ( all( something, something ) )"  using this instead

				"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
				"bool inFrustum = all( inFrustumVec );",

				// don't shadow pixels outside of light frustum
				// use just first frustum (for cascades)
				// don't shadow pixels behind far plane of light frustum

				"#ifdef SHADOWMAP_CASCADE",

					"inFrustumCount += int( inFrustum );",
					"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",

				"#else",

					"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",

				"#endif",

				"bool frustumTest = all( frustumTestVec );",

				"if ( frustumTest ) {",

					"shadowCoord.z += shadowBias[ i ];",

					"#if defined( SHADOWMAP_TYPE_PCF )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						/*
						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL
						// must enroll loop manually

						"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
							"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",

								"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",

								// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
								//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",

								"float fDepth = unpackDepth( rgbaDepth );",

								"if ( fDepth < shadowCoord.z )",
									"shadow += 1.0;",

						"}",

						"shadow /= 9.0;",

						*/

						"const float shadowDelta = 1.0 / 9.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.25 * xPixelOffset;",
						"float dy0 = -1.25 * yPixelOffset;",
						"float dx1 = 1.25 * xPixelOffset;",
						"float dy1 = 1.25 * yPixelOffset;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.0 * xPixelOffset;",
						"float dy0 = -1.0 * yPixelOffset;",
						"float dx1 = 1.0 * xPixelOffset;",
						"float dy1 = 1.0 * yPixelOffset;",

						"mat3 shadowKernel;",
						"mat3 depthKernel;",

						"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",

						"vec3 shadowZ = vec3( shadowCoord.z );",
						"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));",
						"shadowKernel[0] *= vec3(0.25);",

						"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));",
						"shadowKernel[1] *= vec3(0.25);",

						"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));",
						"shadowKernel[2] *= vec3(0.25);",

						"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",

						"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
						"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",

						"vec4 shadowValues;",
						"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
						"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
						"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
						"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",

						"shadow = dot( shadowValues, vec4( 1.0 ) );",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#else",

						"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
						"float fDepth = unpackDepth( rgbaDepth );",

						"if ( fDepth < shadowCoord.z )",

							// spot with multiple shadows is darker

							"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",

							// spot with multiple shadows has the same color as single shadow spot

							//"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );",

					"#endif",

				"}",


				"#ifdef SHADOWMAP_DEBUG",

					"#ifdef SHADOWMAP_CASCADE",

						"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#else",

						"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#endif",

				"#endif",

			"}",

			"#ifdef GAMMA_OUTPUT",

				"shadowColor *= shadowColor;",

			"#endif",

			"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",

		"#endif"

	].join("\n"),

	shadowmap_pars_vertex: [

		"#ifdef USE_SHADOWMAP",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
			"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",

		"#endif"

	].join("\n"),

	shadowmap_vertex: [

		"#ifdef USE_SHADOWMAP",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"}",

		"#endif"

	].join("\n"),

	// ALPHATEST

	alphatest_fragment: [

		"#ifdef ALPHATEST",

			"if ( gl_FragColor.a < ALPHATEST ) discard;",

		"#endif"

	].join("\n"),

	// LINEAR SPACE

	linear_to_gamma_fragment: [

		"#ifdef GAMMA_OUTPUT",

			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"#endif"

	].join("\n")


};

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var u, p, tmp, merged = {};

		for ( u = 0; u < uniforms.length; u ++ ) {

			tmp = this.clone( uniforms[ u ] );

			for ( p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var u, p, parameter, parameter_src, uniforms_dst = {};

		for ( u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( p in uniforms_src[ u ] ) {

				parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: null },
		"specularMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: -1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	bump: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};

THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

				"#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				"#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

					"if ( gl_FrontFacing )",
						"gl_FragColor.xyz *= vLightFront;",
					"else",
						"gl_FragColor.xyz *= vLightBack;",

				"#else",

					"gl_FragColor.xyz *= vLightFront;",

				"#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				"vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms:  THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"#ifdef USE_SIZEATTENUATION",
					"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"#else",
					"gl_PointSize = size;",
				"#endif",

				"gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale":     { type: "f", value: 1 },
				"dashSize":  { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vLineDistance = scale * lineDistance;",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"if ( mod( vLineDistance, totalSize ) > dashSize ) {",

					"discard;",

				"}",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"void main() {",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			"void main() {",

				"float depth = gl_FragCoord.z / gl_FragCoord.w;",
				"float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],

			"void main() {",

				"vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			"void main() {",

				"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with "lights: true" material option)
	 ------------------------------------------------------------------------- */

	'normalmap' : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{

			"enableAO"		  : { type: "i", value: 0 },
			"enableDiffuse"	  : { type: "i", value: 0 },
			"enableSpecular"  : { type: "i", value: 0 },
			"enableReflection": { type: "i", value: 0 },
			"enableDisplacement": { type: "i", value: 0 },

			"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
			"tDiffuse"	   : { type: "t", value: null },
			"tCube"		   : { type: "t", value: null },
			"tNormal"	   : { type: "t", value: null },
			"tSpecular"	   : { type: "t", value: null },
			"tAO"		   : { type: "t", value: null },

			"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"uDisplacementBias": { type: "f", value: 0.0 },
			"uDisplacementScale": { type: "f", value: 1.0 },

			"uDiffuseColor": { type: "c", value: new THREE.Color( 0xffffff ) },
			"uSpecularColor": { type: "c", value: new THREE.Color( 0x111111 ) },
			"uAmbientColor": { type: "c", value: new THREE.Color( 0xffffff ) },
			"uShininess": { type: "f", value: 30 },
			"uOpacity": { type: "f", value: 1 },

			"useRefract": { type: "i", value: 0 },
			"uRefractionRatio": { type: "f", value: 0.98 },
			"uReflectivity": { type: "f", value: 0.5 },

			"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
			"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			"uniform vec3 uAmbientColor;",
			"uniform vec3 uDiffuseColor;",
			"uniform vec3 uSpecularColor;",
			"uniform float uShininess;",
			"uniform float uOpacity;",

			"uniform bool enableDiffuse;",
			"uniform bool enableSpecular;",
			"uniform bool enableAO;",
			"uniform bool enableReflection;",

			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tNormal;",
			"uniform sampler2D tSpecular;",
			"uniform sampler2D tAO;",

			"uniform samplerCube tCube;",

			"uniform vec2 uNormalScale;",

			"uniform bool useRefract;",
			"uniform float uRefractionRatio;",
			"uniform float uReflectivity;",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"uniform vec3 ambientLightColor;",

			"#if MAX_DIR_LIGHTS > 0",

				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

			"#endif",

			"#if MAX_HEMI_LIGHTS > 0",

				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

			"#endif",

			"#if MAX_POINT_LIGHTS > 0",

				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#endif",

			"#if MAX_SPOT_LIGHTS > 0",

				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#endif",

			"#ifdef WRAP_AROUND",

				"uniform vec3 wrapRGB;",

			"#endif",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );",

				"vec3 specularTex = vec3( 1.0 );",

				"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
				"normalTex.xy *= uNormalScale;",
				"normalTex = normalize( normalTex );",

				"if( enableDiffuse ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 texelColor = texture2D( tDiffuse, vUv );",
						"texelColor.xyz *= texelColor.xyz;",

						"gl_FragColor = gl_FragColor * texelColor;",

					"#else",

						"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

					"#endif",

				"}",

				"if( enableAO ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 aoColor = texture2D( tAO, vUv );",
						"aoColor.xyz *= aoColor.xyz;",

						"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

					"#else",

						"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

					"#endif",

				"}",

				"if( enableSpecular )",
					"specularTex = texture2D( tSpecular, vUv ).xyz;",

				"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
				"vec3 finalNormal = tsb * normalTex;",

				"#ifdef FLIP_SIDED",

					"finalNormal = -finalNormal;",

				"#endif",

				"vec3 normal = normalize( finalNormal );",
				"vec3 viewPosition = normalize( vViewPosition );",

				// point lights

				"#if MAX_POINT_LIGHTS > 0",

					"vec3 pointDiffuse = vec3( 0.0 );",
					"vec3 pointSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
						"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

						"float pointDistance = 1.0;",
						"if ( pointLightDistance[ i ] > 0.0 )",
							"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

						"pointVector = normalize( pointVector );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
							"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

							"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

						"#else",

							"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

						"#endif",

						"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;",

						// specular

						"vec3 pointHalfVector = normalize( pointVector + viewPosition );",
						"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
						"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );",

						"#ifdef PHYSICALLY_BASED_SHADING",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",

							"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
							"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

						"#else",

							"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;",

						"#endif",

					"}",

				"#endif",

				// spot lights

				"#if MAX_SPOT_LIGHTS > 0",

					"vec3 spotDiffuse = vec3( 0.0 );",
					"vec3 spotSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
						"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

						"float spotDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

						"spotVector = normalize( spotVector );",

						"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

						"if ( spotEffect > spotLightAngleCos[ i ] ) {",

							"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

							// diffuse

							"#ifdef WRAP_AROUND",

								"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
								"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

								"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

							"#else",

								"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

							"#endif",

							"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;",

							// specular

							"vec3 spotHalfVector = normalize( spotVector + viewPosition );",
							"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
							"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );",

							"#ifdef PHYSICALLY_BASED_SHADING",

								// 2.0 => 2.0001 is hack to work around ANGLE bug

								"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",

								"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
								"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

							"#else",

								"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;",

							"#endif",

						"}",

					"}",

				"#endif",

				// directional lights

				"#if MAX_DIR_LIGHTS > 0",

					"vec3 dirDiffuse = vec3( 0.0 );",
					"vec3 dirSpecular = vec3( 0.0 );",

					"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

						"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
						"vec3 dirVector = normalize( lDirection.xyz );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
							"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

							"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

						"#else",

							"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

						"#endif",

						"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;",

						// specular

						"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
						"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
						"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );",

						"#ifdef PHYSICALLY_BASED_SHADING",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",

							"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
							"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

						"#else",

							"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;",

						"#endif",

					"}",

				"#endif",

				// hemisphere lights

				"#if MAX_HEMI_LIGHTS > 0",

					"vec3 hemiDiffuse  = vec3( 0.0 );",
					"vec3 hemiSpecular = vec3( 0.0 );" ,

					"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

						"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
						"vec3 lVector = normalize( lDirection.xyz );",

						// diffuse

						"float dotProduct = dot( normal, lVector );",
						"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

						"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

						"hemiDiffuse += uDiffuseColor * hemiColor;",

						// specular (sky light)


						"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
						"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
						"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );",

						// specular (ground light)

						"vec3 lVectorGround = -lVector;",

						"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
						"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
						"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );",

						"#ifdef PHYSICALLY_BASED_SHADING",

							"float dotProductGround = dot( normal, lVectorGround );",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",

							"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
							"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
							"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

						"#else",

							"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",

						"#endif",

					"}",

				"#endif",

				// all lights contribution summation

				"vec3 totalDiffuse = vec3( 0.0 );",
				"vec3 totalSpecular = vec3( 0.0 );",

				"#if MAX_DIR_LIGHTS > 0",

					"totalDiffuse += dirDiffuse;",
					"totalSpecular += dirSpecular;",

				"#endif",

				"#if MAX_HEMI_LIGHTS > 0",

					"totalDiffuse += hemiDiffuse;",
					"totalSpecular += hemiSpecular;",

				"#endif",

				"#if MAX_POINT_LIGHTS > 0",

					"totalDiffuse += pointDiffuse;",
					"totalSpecular += pointSpecular;",

				"#endif",

				"#if MAX_SPOT_LIGHTS > 0",

					"totalDiffuse += spotDiffuse;",
					"totalSpecular += spotSpecular;",

				"#endif",

				"#ifdef METAL",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );",

				"#else",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;",

				"#endif",

				"if ( enableReflection ) {",

					"vec3 vReflect;",
					"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

					"if ( useRefract ) {",

						"vReflect = refract( cameraToVertex, normal, uRefractionRatio );",

					"} else {",

						"vReflect = reflect( cameraToVertex, normal );",

					"}",

					"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

					"#ifdef GAMMA_INPUT",

						"cubeColor.xyz *= cubeColor.xyz;",

					"#endif",

					"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );",

				"}",

				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n"),

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uOffset;",
			"uniform vec2 uRepeat;",

			"uniform bool enableDisplacement;",

			"#ifdef VERTEX_TEXTURES",

				"uniform sampler2D tDisplacement;",
				"uniform float uDisplacementScale;",
				"uniform float uDisplacementBias;",

			"#endif",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],

				// normal, tangent and binormal vectors

				"#ifdef USE_SKINNING",

					"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

					"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
					"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

				"#else",

					"vNormal = normalize( normalMatrix * normal );",
					"vTangent = normalize( normalMatrix * tangent.xyz );",

				"#endif",

				"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

				"vUv = uv * uRepeat + uOffset;",

				// displacement mapping

				"vec3 displacedPosition;",

				"#ifdef VERTEX_TEXTURES",

					"if ( enableDisplacement ) {",

						"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
						"float df = uDisplacementScale * dv.x + uDisplacementBias;",
						"displacedPosition = position + normalize( normal ) * df;",

					"} else {",

						"#ifdef USE_SKINNING",

							"vec4 skinVertex = vec4( position, 1.0 );",

							"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
							"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

							"displacedPosition  = skinned.xyz;",

						"#else",

							"displacedPosition = position;",

						"#endif",

					"}",

				"#else",

					"#ifdef USE_SKINNING",

						"vec4 skinVertex = vec4( position, 1.0 );",

						"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
						"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

						"displacedPosition  = skinned.xyz;",

					"#else",

						"displacedPosition = position;",

					"#endif",

				"#endif",

				//

				"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
				"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

				"gl_Position = projectionMatrix * mvPosition;",

				//

				"vWorldPosition = worldPosition.xyz;",
				"vViewPosition = -mvPosition.xyz;",

				// shadows

				"#ifdef USE_SHADOWMAP",

					"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

						"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

					"}",

				"#endif",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: -1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			"void main() {",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"vWorldPosition = worldPosition.xyz;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			"void main() {",

				"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

			"}"

		].join("\n")

	},

	// Depth encoding into RGBA texture
	// 	based on SpiderGL shadow map example
	// 		http://spidergl.org/example.php?id=6
	// 	originally from
	//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	// 	see also here:
	//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"vec4 pack_depth( const in float depth ) {",

				"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"vec4 res = fract( depth * bit_shift );",
				"res -= res.xxyz * bit_mask;",
				"return res;",

			"}",

			"void main() {",

				"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;
	this.autoUpdateObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;
	this.physicallyBasedShading = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapAutoUpdate = true;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// custom render plugins

	this.renderPluginsPre = [];
	this.renderPluginsPost = [];

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],
	_programs_counter = 0,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_currentCamera = null,
	_geometryGroupCounter = 0,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_enabledAttributes = {},

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: new Array(), positions: new Array() },
		point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },
		spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
		hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }

	};

	// initialize

	var _gl;

	var _glExtensionTextureFloat;
	var _glExtensionTextureFloatLinear;
	var _glExtensionStandardDerivatives;
	var _glExtensionTextureFilterAnisotropic;
	var _glExtensionCompressedTextureS3TC;

	initGL();

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	var _supportsVertexTextures = ( _maxVertexTextures > 0 );
	var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;

	var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );
	var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );
	var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );

	var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );
	var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );
	var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === "highp" && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = "mediump";
			console.warn( "WebGLRenderer: highp not supported, using mediump" );

		} else {

			_precision = "lowp";
			console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );

		}

	}

	if ( _precision === "mediump" && ! mediumpAvailable ) {

		_precision = "lowp";
		console.warn( "WebGLRenderer: mediump not supported, using lowp" );

	}

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return _glExtensionTextureFloat;

	};

	this.supportsStandardDerivatives = function () {

		return _glExtensionStandardDerivatives;

	};

	this.supportsCompressedTextureS3TC = function () {

		return _glExtensionCompressedTextureS3TC;

	};

	this.getMaxAnisotropy  = function () {

		return _maxAnisotropy;

	};

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, _canvas.width, _canvas.height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x !== undefined ? x : 0;
		_viewportY = y !== undefined ? y : 0;

		_viewportWidth = width !== undefined ? width : _canvas.width;
		_viewportHeight = height !== undefined ? height : _canvas.height;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor( x, y, width, height );

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Plugins

	this.addPostPlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPost.push( plugin );

	};

	this.addPrePlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPre.push( plugin );

	};

	// Rendering

	this.updateShadowMap = function ( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		this.shadowMapPlugin.update( scene, camera );

	};

	// Internal functions

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {

		if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var id in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );

			}

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		geometry.__webglInit = undefined;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;

			for ( var key in attributes ) {

				if ( attributes[ key ].buffer !== undefined ) {

					_gl.deleteBuffer( attributes[ key ].buffer );

				}

			}

			_this.info.memory.geometries --;

		} else {

			if ( geometry.geometryGroups !== undefined ) {

				for ( var g in geometry.geometryGroups ) {

					var geometryGroup = geometry.geometryGroups[ g ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

					}

					deleteBuffers( geometryGroup );

				}

			} else {

				deleteBuffers( geometry );

			}

		}

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture.__webglInit ) return;

			texture.__webglInit = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		var material = object.material;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup ),

			uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		// console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceVertexUvs.length > 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
		geometryGroup.__lineArray = new Uint16Array( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if( attribute.type === "v2" ) size = 2;
					else if( attribute.type === "v3" ) size = 3;
					else if( attribute.type === "v4" ) size = 4;
					else if( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ geometryGroup.materialIndex ]
			: object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	function bufferGuessNormalType ( material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {

			return false;

		}

		if ( materialNeedsSmoothNormals( material ) ) {

			return THREE.SmoothShading;

		} else {

			return THREE.FlatShading;

		}

	};

	function bufferGuessVertexColorType( material ) {

		if ( material.vertexColors ) {

			return material.vertexColors;

		}

		return false;

	};

	function bufferGuessUVType( material ) {

		// material must use some texture to require uvs

		if ( material.map ||
		     material.lightMap ||
		     material.bumpMap ||
		     material.normalMap ||
		     material.specularMap ||
		     material instanceof THREE.ShaderMaterial ) {

			return true;

		}

		return false;

	};

	//

	function initDirectBuffers( geometry ) {

		var a, attribute, type;

		for ( a in geometry.attributes ) {

			if ( a === "index" ) {

				type = _gl.ELEMENT_ARRAY_BUFFER;

			} else {

				type = _gl.ARRAY_BUFFER;

			}

			attribute = geometry.attributes[ a ];

			if ( attribute.numItems === undefined ) {

				attribute.numItems = attribute.array.length;

			}

			attribute.buffer = _gl.createBuffer();

			_gl.bindBuffer( type, attribute.buffer );
			_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );

		}

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_vector3.applyProjection( _projScreenMatrixPS );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === "c" ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	};

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	};

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === THREE.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors && vertexColorType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals && normalType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};


	function setDirectBuffers ( geometry, hint, dispose ) {

		var attributes = geometry.attributes;

		var attributeName, attributeItem;

		for ( attributeName in attributes ) {

			attributeItem = attributes[ attributeName ];

			if ( attributeItem.needsUpdate ) {

				if ( attributeName === 'index' ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );
					_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );

				} else {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
                                       //console.log('setDirectbuffereeeeer',attributeName);
					_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );

				}

				attributeItem.needsUpdate = false;

			}

			if ( dispose && ! attributeItem.dynamic ) {

				attributeItem.array = null;

			}

		}

	};
	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute;
		var attributeItem, attributeName, attributePointer, attributeSize;

		var program = setProgram( camera, lights, fog, material, object );

		var programAttributes = program.attributes;
		var geometryAttributes = geometry.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var index = geometryAttributes[ "index" ];

			// indexed triangles

			if ( index ) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length > 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i < il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						for ( attributeName in programAttributes ) {

							attributePointer = programAttributes[ attributeName ];
							attributeItem = geometryAttributes[ attributeName ];

							if ( attributePointer >= 0 ) {

								if ( attributeItem ) {

									attributeSize = attributeItem.itemSize;
									_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
									enableAttribute( attributePointer );
									_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32

								} else if ( material.defaultAttributeValues ) {

									if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

										_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

									} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

										_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

									}

								}

							}

						}

						// indices

						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					// render indexed triangles

					_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

					_this.info.render.calls ++;
					_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
					_this.info.render.faces += offsets[ i ].count / 3;

				}

			// non-indexed triangles

			} else {

				if ( updateBuffers ) {

					for ( attributeName in programAttributes ) {

						if ( attributeName === 'index') continue;

						attributePointer = programAttributes[ attributeName ];
						attributeItem = geometryAttributes[ attributeName ];

						if ( attributePointer >= 0 ) {

							if ( attributeItem ) {

								attributeSize = attributeItem.itemSize;
								_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
								enableAttribute( attributePointer );
								_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

							} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

								if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

									_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

								} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

									_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

								}

							}

						}

					}

				}

				var position = geometry.attributes[ "position" ];

				// render non-indexed triangles

				_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.numItems / 3;
				_this.info.render.faces += position.numItems / 3 / 3;

			}

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			if ( updateBuffers ) {

				for ( attributeName in programAttributes ) {

					attributePointer = programAttributes[ attributeName ];
					attributeItem = geometryAttributes[ attributeName ];

					if ( attributePointer >= 0 ) {

						if ( attributeItem ) {

							attributeSize = attributeItem.itemSize;
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
							enableAttribute( attributePointer );
							_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

						} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

							if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

								_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

								_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							}

						}

					}

				}

				var position = geometryAttributes[ "position" ];

				// render particles

				_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );

				_this.info.render.calls ++;
				_this.info.render.points += position.numItems / 3;

			}

		} else if ( object instanceof THREE.Line ) {

			if ( updateBuffers ) {

				for ( attributeName in programAttributes ) {

					attributePointer = programAttributes[ attributeName ];
					attributeItem = geometryAttributes[ attributeName ];

					if ( attributePointer >= 0 ) {

						if ( attributeItem ) {

							attributeSize = attributeItem.itemSize;
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
							enableAttribute( attributePointer );
							_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

						} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

							if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

								_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

								_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							}

						}

					}

				}

				// render lines

				var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

				setLineWidth( material.linewidth );

				var position = geometryAttributes[ "position" ];

				_gl.drawArrays( primitives, 0, position.numItems / 3 );

				_this.info.render.calls ++;
				_this.info.render.points += position.numItems;

			}

    	}

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute, i, il;

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// vertices

		if ( !material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[0] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[1] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		}

	};

	function enableAttribute( attribute ) {

		if ( ! _enabledAttributes[ attribute ] ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = true;

		}

	};

	function disableAttributes() {

		for ( var attribute in _enabledAttributes ) {

			if ( _enabledAttributes[ attribute ] ) {

				_gl.disableVertexAttribArray( attribute );
				_enabledAttributes[ attribute ] = false;

			}

		}

	};

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				if ( attributes[ "morphTarget" + m ] >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphTarget" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphNormal" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence, activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i < il; i ++ ) {

				influence = influences[ i ];

				if ( influence > 0 ) {

					activeInfluenceIndices.push( [ influence, i ] );

				}

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m < material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] ) {

					influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					if ( attributes[ "morphTarget" + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphTarget" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphNormal" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	};

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	};

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	};


	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var i, il,

		webglObject, object,
		renderList,

		lights = scene.__lights,
		fog = scene.fog;

		// reset caching for this frame

		_currentMaterialId = -1;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// update WebGL objects

		if ( this.autoUpdateObjects ) this.initWebGLObjects( scene );

		// custom render plugins (pre pass)

		renderPlugins( this.renderPluginsPre, scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for regular objects (frustum culled)

		renderList = scene.__webglObjects;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			webglObject.id = i;
			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					setupMatrices( object, camera );

					unrollBufferMaterial( webglObject );

					webglObject.render = true;

					if ( this.sortObjects === true ) {

						if ( object.renderDepth !== null ) {

							webglObject.z = object.renderDepth;

						} else {

							_vector3.getPositionFromMatrix( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

							webglObject.z = _vector3.z;

						}

					}

				}

			}

		}

		if ( this.sortObjects ) {

			renderList.sort( painterSortStable );

		}

		// set matrices for immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( scene.__webglObjects, false, "", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "", camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( scene.__webglObjects, true, "opaque", camera, lights, fog, false, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "opaque", camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( scene.__webglObjects, false, "transparent", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "transparent", camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		renderPlugins( this.renderPluginsPost, scene, camera );


		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function renderPlugins( plugins, scene, camera ) {

		if ( ! plugins.length ) return;

		for ( var i = 0, il = plugins.length; i < il; i ++ ) {

			// reset state for plugin (to start from clean slate)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

			plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

		}

	};

	function renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, buffer, material, start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i !== end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.setMaterialFaces( material );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

				} else {

					_this.renderBuffer( camera, lights, fog, material, buffer, object );

				}

			}

		}

	};

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, material, program;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	};

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = -1;

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	};

	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;

		if ( material instanceof THREE.MeshFaceMaterial ) {

			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

			material = material.materials[ materialIndex ];

			if ( material.transparent ) {

				globject.transparent = material;
				globject.opaque = null;

			} else {

				globject.opaque = material;
				globject.transparent = null;

			}

		} else {

			if ( material ) {

				if ( material.transparent ) {

					globject.transparent = material;
					globject.opaque = null;

				} else {

					globject.opaque = material;
					globject.transparent = null;

				}

			}

		}

	};


	// Geometry splitting

	function sortFacesByMaterial ( geometry, material ) {

		var f, fl, face, materialIndex, vertices,
			groupHash, hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;

		geometry.geometryGroups = {};

		for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			face = geometry.faces[ f ];
			materialIndex = usesFaceMaterial ? face.materialIndex : 0;

			if ( hash_map[ materialIndex ] === undefined ) {

				hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };

			}

			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

			if ( geometry.geometryGroups[ groupHash ] === undefined ) {

				geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

			}

			vertices = 3;

			if ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {

				hash_map[ materialIndex ].counter += 1;
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( geometry.geometryGroups[ groupHash ] === undefined ) {

					geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

				}

			}

			geometry.geometryGroups[ groupHash ].faces3.push( f );
			geometry.geometryGroups[ groupHash ].vertices += vertices;

		}

		geometry.geometryGroupsList = [];

		for ( var g in geometry.geometryGroups ) {

			geometry.geometryGroups[ g ].id = _geometryGroupCounter ++;

			geometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );

		}

	};

	// Objects refresh

	this.initWebGLObjects = function ( scene ) {

		if ( !scene.__webglObjects ) {

			scene.__webglObjects = [];
			scene.__webglObjectsImmediate = [];
			scene.__webglSprites = [];
			scene.__webglFlares = [];

		}

		while ( scene.__objectsAdded.length ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.splice( 0, 1 );

		}

		while ( scene.__objectsRemoved.length ) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.splice( 0, 1 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {

			var object = scene.__webglObjects[ o ].object;

			// TODO: Remove this hack (WebGLRenderer refactoring)

			if ( object.__webglInit === undefined ) {

				if ( object.__webglActive !== undefined ) {

					removeObject( object, scene );

				}

				addObject( object, scene );

			}

			updateObject( object );

		}

	};

	// Objects adding

	function addObject( object, scene ) {

		var g, geometry, material, geometryGroup;

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;

			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			if ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {

				object.geometry.__webglInit = true;
				object.geometry.addEventListener( 'dispose', onGeometryDispose );

			}

			geometry = object.geometry;

			if ( geometry === undefined ) {

				// fail silently for now

			} else if ( geometry instanceof THREE.BufferGeometry ) {

				initDirectBuffers( geometry );

			} else if ( object instanceof THREE.Mesh ) {

				material = object.material;

				if ( geometry.geometryGroups === undefined ) {

					sortFacesByMaterial( geometry, material );

				}

				// create separate VBOs per geometry chunk

				for ( g in geometry.geometryGroups ) {

					geometryGroup = geometry.geometryGroups[ g ];

					// initialise VBO on the first access

					if ( ! geometryGroup.__webglVertexBuffer ) {

						createMeshBuffers( geometryGroup );
						initMeshBuffers( geometryGroup, object );

						geometry.verticesNeedUpdate = true;
						geometry.morphTargetsNeedUpdate = true;
						geometry.elementsNeedUpdate = true;
						geometry.uvsNeedUpdate = true;
						geometry.normalsNeedUpdate = true;
						geometry.tangentsNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					}

				}

			} else if ( object instanceof THREE.Line ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object instanceof THREE.ParticleSystem ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined ) {

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( scene.__webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					for ( g in geometry.geometryGroups ) {

						geometryGroup = geometry.geometryGroups[ g ];

						addBuffer( scene.__webglObjects, geometryGroup, object );

					}

				}

			} else if ( object instanceof THREE.Line ||
						object instanceof THREE.ParticleSystem ) {

				geometry = object.geometry;
				addBuffer( scene.__webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( scene.__webglObjectsImmediate, object );

			} else if ( object instanceof THREE.Sprite ) {

				scene.__webglSprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				scene.__webglFlares.push( object );

			}

			object.__webglActive = true;

		}

	};

	function addBuffer( objlist, buffer, object ) {

		objlist.push(
			{
				id: null,
				buffer: buffer,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject( object ) {

		var geometry = object.geometry,
			geometryGroup, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			for( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {

				geometryGroup = geometry.geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				if ( geometry.buffersNeedUpdate ) {

					initMeshBuffers( geometryGroup, object );

				}

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			geometry.buffersNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );


		} else if ( object instanceof THREE.ParticleSystem ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	};

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var a in material.attributes ) {

			if ( material.attributes[ a ].needsUpdate ) return true;

		}

		return false;

	};

	function clearCustomAttributes( material ) {

		for ( var a in material.attributes ) {

			material.attributes[ a ].needsUpdate = false;

		}

	};

	// Objects removal

	function removeObject( object, scene ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.ParticleSystem ||
			 object instanceof THREE.Line ) {

			removeInstances( scene.__webglObjects, object );

		} else if ( object instanceof THREE.Sprite ) {

			removeInstancesDirect( scene.__webglSprites, object );

		} else if ( object instanceof THREE.LensFlare ) {

			removeInstancesDirect( scene.__webglFlares, object );

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( scene.__webglObjectsImmediate, object );

		}

		delete object.__webglActive;

	};

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	function removeInstancesDirect( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ] === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	// Materials

	this.initMaterial = function ( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		} else if ( material instanceof THREE.ParticleSystemMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			setMaterialShaders( material, THREE.ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		parameters = {

			map: !!material.map,
			envMap: !!material.envMap,
			lightMap: !!material.lightMap,
			bumpMap: !!material.bumpMap,
			normalMap: !!material.normalMap,
			specularMap: !!material.specularMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: this.maxMorphTargets,
			maxMorphNormals: this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
			shadowMapType: this.shadowMapType,
			shadowMapDebug: this.shadowMapDebug,
			shadowMapCascade: this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			perPixel: material.perPixel,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		material.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );

		var attributes = material.program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i < this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = "morphNormal";

			for ( i = 0; i < this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( u in material.uniforms ) {

			material.uniformsList.push( [ material.uniforms[ u ], u ] );

		}

	};

	function setMaterialShaders( material, shaders ) {

		material.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );
		material.vertexShader = shaders.vertexShader;
		material.fragmentShader = shaders.fragmentShader;

	};

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			_this.initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

		if ( program !== _currentProgram ) {

			_gl.useProgram( program );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

		if ( refreshMaterial || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( camera !== _currentCamera ) _currentCamera = camera;

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( _supportsBoneTextures && object.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.boneTextureHeight );

				}

			} else {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					setupLights( program, lights );
					_lightsNeedUpdate = false;

				}

				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.ParticleSystemMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.getPositionFromMatrix( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	};

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. normal map
		//	4. bump map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		}

		if ( uvScaleMap !== undefined ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	};

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	};

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	};

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	};

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	};

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	};

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	};

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	};

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	};

	function loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;

		for ( j = 0, jl = uniforms.length; j < jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( !location ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.value;

			if ( type === "i" ) { // single integer

				_gl.uniform1i( location, value );

			} else if ( type === "f" ) { // single float

				_gl.uniform1f( location, value );

			} else if ( type === "v2" ) { // single THREE.Vector2

				_gl.uniform2f( location, value.x, value.y );

			} else if ( type === "v3" ) { // single THREE.Vector3

				_gl.uniform3f( location, value.x, value.y, value.z );

			} else if ( type === "v4" ) { // single THREE.Vector4

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			} else if ( type === "c" ) { // single THREE.Color

				_gl.uniform3f( location, value.r, value.g, value.b );

			} else if ( type === "iv1" ) { // flat array of integers (JS or typed array)

				_gl.uniform1iv( location, value );

			} else if ( type === "iv" ) { // flat array of integers with 3 x N size (JS or typed array)

				_gl.uniform3iv( location, value );

			} else if ( type === "fv1" ) { // flat array of floats (JS or typed array)

				_gl.uniform1fv( location, value );

			} else if ( type === "fv" ) { // flat array of floats with 3 x N size (JS or typed array)

				_gl.uniform3fv( location, value );

			} else if ( type === "v2v" ) { // array of THREE.Vector2

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 2 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 2;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;

				}

				_gl.uniform2fv( location, uniform._array );

			} else if ( type === "v3v" ) { // array of THREE.Vector3

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 3 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 3;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;

				}

				_gl.uniform3fv( location, uniform._array );

			} else if ( type === "v4v" ) { // array of THREE.Vector4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 4 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 4;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;
					uniform._array[ offset + 3 ] = value[ i ].w;

				}

				_gl.uniform4fv( location, uniform._array );

			} else if ( type === "m4") { // single THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 );

				}

				value.flattenToArray( uniform._array );
				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "m4v" ) { // array of THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

				}

				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "t" ) { // single THREE.Texture (2d or cube)

				texture = value;
				textureUnit = getTextureUnit();

				_gl.uniform1i( location, textureUnit );

				if ( !texture ) continue;

				if ( texture.image instanceof Array && texture.image.length === 6 ) {

					setCubeTexture( texture, textureUnit );

				} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, textureUnit );

				} else {

					_this.setTexture( texture, textureUnit );

				}

			} else if ( type === "tv" ) { // array of THREE.Texture (2d)

				if ( uniform._array === undefined ) {

					uniform._array = [];

				}

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					uniform._array[ i ] = getTextureUnit();

				}

				_gl.uniform1iv( location, uniform._array );

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					texture = uniform.value[ i ];
					textureUnit = uniform._array[ i ];

					if ( !texture ) continue;

					_this.setTexture( texture, textureUnit );

				}

			} else {

				console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	};

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	};

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	};

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	};

	function setupLights ( program, lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.getPositionFromMatrix( light.matrixWorld );
				_vector3.getPositionFromMatrix( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.getPositionFromMatrix( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_vector3.getPositionFromMatrix( light.matrixWorld );

				spotPositions[ spotOffset ]     = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_direction.copy( _vector3 );
				_vector3.getPositionFromMatrix( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.getPositionFromMatrix( light.matrixWorld );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	};

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	};

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Defines

	function generateDefines ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	// Shaders

	function buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {

		var p, pl, d, program, code;
		var chunks = [];

		// Generate code

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( fragmentShader );
			chunks.push( vertexShader );

		}

		for ( d in defines ) {

			chunks.push( d );
			chunks.push( defines[ d ] );

		}

		for ( p in parameters ) {

			chunks.push( p );
			chunks.push( parameters[ p ] );

		}

		code = chunks.join();

		// Check if code has been already compiled

		for ( p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				// console.log( "Code already compiled." /*: \n\n" + code*/ );

				programInfo.usedTimes ++;

				return programInfo.program;

			}

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		// console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		program = _gl.createProgram();

		var prefix_vertex = [

			"precision " + _precision + " float;",
			"precision " + _precision + " int;",

			customDefines,

			_supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
			_this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			"#define MAX_BONES " + parameters.maxBones,

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.skinning ? "#define USE_SKINNING" : "",
			parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

			parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
			parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
			parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",

				"#ifdef USE_MORPHNORMALS",

					"attribute vec3 morphNormal0;",
					"attribute vec3 morphNormal1;",
					"attribute vec3 morphNormal2;",
					"attribute vec3 morphNormal3;",

				"#else",

					"attribute vec3 morphTarget4;",
					"attribute vec3 morphTarget5;",
					"attribute vec3 morphTarget6;",
					"attribute vec3 morphTarget7;",

				"#endif",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		].join("\n");

		var prefix_fragment = [

			"precision " + _precision + " float;",
			"precision " + _precision + " int;",

			( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

			customDefines,

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
			_this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
			( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.metal ? "#define METAL" : "",
			parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		].join("\n");

		var glVertexShader = getShader( "vertex", prefix_vertex + vertexShader );
		var glFragmentShader = getShader( "fragment", prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		//Force a particular attribute to index 0.
		// because potentially expensive emulation is done by browser if attribute 0 is disabled.
		//And, color, for example is often automatically bound to index 0 so disabling it
		if ( index0AttributeName ) {
			_gl.bindAttribLocation( program, 0, index0AttributeName );
		}

		_gl.linkProgram( program );

		if ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {

			console.error( "Could not initialise shader\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + ", gl error [" + _gl.getError() + "]" );
			console.error( "Program Info Log: " + _gl.getProgramInfoLog( program ) );
		}

		// clean up

		_gl.deleteShader( glFragmentShader );
		_gl.deleteShader( glVertexShader );

		// console.log( prefix_fragment + fragmentShader );
		// console.log( prefix_vertex + vertexShader );

		program.uniforms = {};
		program.attributes = {};

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'morphTargetInfluences'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );
			identifiers.push( 'boneTextureWidth' );
			identifiers.push( 'boneTextureHeight' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		for ( u in uniforms ) {

			identifiers.push( u );

		}

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( "morphNormal" + i );

		}

		for ( a in attributes ) {

			identifiers.push( a );

		}

		cacheAttributeLocations( program, identifiers );

		program.id = _programs_counter ++;

		_programs.push( { program: program, code: code, usedTimes: 1 } );

		_this.info.memory.programs = _programs.length;

		return program;

	};

	// Shader parameters cache

	function cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program, id );

		}

	};

	function cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program, id );

		}

	};

	function addLineNumbers ( string ) {

		var chunks = string.split( "\n" );

		for ( var i = 0, il = chunks.length; i < il; i ++ ) {

			// Chrome reports shader errors on lines
			// starting counting from 1

			chunks[ i ] = ( i + 1 ) + ": " + chunks[ i ];

		}

		return chunks.join( "\n" );

	};

	function getShader ( type, string ) {

		var shader;

		if ( type === "fragment" ) {

			shader = _gl.createShader( _gl.FRAGMENT_SHADER );

		} else if ( type === "vertex" ) {

			shader = _gl.createShader( _gl.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {

			console.error( _gl.getShaderInfoLog( shader ) );
			console.error( addLineNumbers( string ) );
			return null;

		}

		return shader;

	};

	// Textures


	function isPowerOfTwo ( value ) {

		return ( value & ( value - 1 ) ) === 0;

	};

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		if ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	};

	this.setTexture = function ( texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( ! texture.__webglInit ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = texture.image,
			isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					if ( texture.format!==THREE.RGBAFormat ) {
						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
					} else {
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
					}

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		} else {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width <= maxSize && image.height <= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = Math.floor( image.width * maxSize / maxDimension );
		var newHeight = Math.floor( image.height * maxSize / maxDimension );

		var canvas = document.createElement( 'canvas' );
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.getContext( "2d" );
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if( !isCompressed ) {

						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];
							if ( texture.format!==THREE.RGBAFormat ) {

								_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {
								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
							}

						}
					}
				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	};

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	};

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	};

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	};

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && ! renderTarget.__webglFramebuffer ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	};

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( _glExtensionCompressedTextureS3TC !== undefined ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		return 0;

	};

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			// 	- leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.bones.length, maxBones );

				if ( maxBones < object.bones.length ) {

					console.warn( "WebGLRenderer: too many bones - " + object.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)" );

				}

			}

			return maxBones;

		}

	};

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };

	};

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	};

	// Initialization

	function initGL() {

		try {

			var attributes = {
				alpha: _alpha,
				premultipliedAlpha: _premultipliedAlpha,
				antialias: _antialias,
				stencil: _stencil,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				throw 'Error creating WebGL context.';

			}

		} catch ( error ) {

			console.error( error );

		}

		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
		_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );

		_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );

		if ( ! _glExtensionTextureFloat ) {

			console.log( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

		if ( ! _glExtensionStandardDerivatives ) {

			console.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( ! _glExtensionTextureFilterAnisotropic ) {

			console.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

		if ( ! _glExtensionCompressedTextureS3TC ) {

			console.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );

		}

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function() {

				return {
					"rangeMin"  : 1,
					"rangeMax"  : 1,
					"precision" : 1
				};

			}
		}

	};

	function setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	// default plugins (order is important)

	this.shadowMapPlugin = new THREE.ShadowMapPlugin();
	this.addPrePlugin( this.shadowMapPlugin );

	this.addPostPlugin( new THREE.SpritePlugin() );
	this.addPostPlugin( new THREE.LensFlarePlugin() );

};

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	clone: function () {

		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );

		tmp.format = this.format;
		tmp.type = this.type;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		tmp.generateMipmaps = this.generateMipmaps;

		tmp.shareDepthFrom = this.shareDepthFrom;

		return tmp;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableVertex = function () {

	this.positionWorld = new THREE.Vector3();
	this.positionScreen = new THREE.Vector4();

	this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {

	this.positionWorld.copy( vertex.positionWorld );
	this.positionScreen.copy( vertex.positionScreen );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableFace3 = function () {

	this.id = 0;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();
	this.v3 = new THREE.RenderableVertex();

	this.centroidModel = new THREE.Vector3();

	this.normalModel = new THREE.Vector3();
	this.normalModelView = new THREE.Vector3();

	this.vertexNormalsLength = 0;
	this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	this.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

	this.color = null;
	this.material = null;
	this.uvs = [[]];

	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableObject = function () {

	this.id = 0;

	this.object = null;
	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableSprite = function () {

	this.id = 0;

	this.object = null;

	this.x = 0;
	this.y = 0;
	this.z = 0;

	this.rotation = 0;
	this.scale = new THREE.Vector2();

	this.material = null;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableLine = function () {

	this.id = 0;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();

	this.vertexColors = [ new THREE.Color(), new THREE.Color() ];
	this.material = null;

	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.GeometryUtils = {

	// Merge two geometries or geometry and geometry from object (using object's transform)

	merge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {

		var matrix, normalMatrix,
		vertexOffset = geometry1.vertices.length,
		uvPosition = geometry1.faceVertexUvs[ 0 ].length,
		geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,
		vertices1 = geometry1.vertices,
		vertices2 = geometry2.vertices,
		faces1 = geometry1.faces,
		faces2 = geometry2.faces,
		uvs1 = geometry1.faceVertexUvs[ 0 ],
		uvs2 = geometry2.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( object2 instanceof THREE.Mesh ) {

			object2.matrixAutoUpdate && object2.updateMatrix();

			matrix = object2.matrix;

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faceCopy.centroid.copy( face.centroid );

			if ( matrix ) {

				faceCopy.centroid.applyMatrix4( matrix );

			}

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			uvs1.push( uvCopy );

		}

	},

	// Get random point in triangle (via barycentric coordinates)
	// 	(uniform distribution)
	// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle

	randomPointInTriangle: function () {

		var vector = new THREE.Vector3();

		return function ( vectorA, vectorB, vectorC ) {

			var point = new THREE.Vector3();

			var a = THREE.Math.random16();
			var b = THREE.Math.random16();

			if ( ( a + b ) > 1 ) {

				a = 1 - a;
				b = 1 - b;

			}

			var c = 1 - a - b;

			point.copy( vectorA );
			point.multiplyScalar( a );

			vector.copy( vectorB );
			vector.multiplyScalar( b );

			point.add( vector );

			vector.copy( vectorC );
			vector.multiplyScalar( c );

			point.add( vector );

			return point;

		};

	}(),

	// Get random point in face (triangle / quad)
	// (uniform distribution)

	randomPointInFace: function ( face, geometry, useCachedAreas ) {

		var vA, vB, vC, vD;

		vA = geometry.vertices[ face.a ];
		vB = geometry.vertices[ face.b ];
		vC = geometry.vertices[ face.c ];

		return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );

	},

	// Get uniformly distributed random points in mesh
	// 	- create array with cumulative sums of face areas
	//  - pick random number from 0 to total area
	//  - find corresponding place in area array by binary search
	//	- get random point in face

	randomPointsInGeometry: function ( geometry, n ) {

		var face, i,
			faces = geometry.faces,
			vertices = geometry.vertices,
			il = faces.length,
			totalArea = 0,
			cumulativeAreas = [],
			vA, vB, vC, vD;

		// precompute face areas

		for ( i = 0; i < il; i ++ ) {

			face = faces[ i ];

			vA = vertices[ face.a ];
			vB = vertices[ face.b ];
			vC = vertices[ face.c ];

			face._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );

			totalArea += face._area;

			cumulativeAreas[ i ] = totalArea;

		}

		// binary search cumulative areas array

		function binarySearchIndices( value ) {

			function binarySearch( start, end ) {

				// return closest larger index
				// if exact number is not found

				if ( end < start )
					return start;

				var mid = start + Math.floor( ( end - start ) / 2 );

				if ( cumulativeAreas[ mid ] > value ) {

					return binarySearch( start, mid - 1 );

				} else if ( cumulativeAreas[ mid ] < value ) {

					return binarySearch( mid + 1, end );

				} else {

					return mid;

				}

			}

			var result = binarySearch( 0, cumulativeAreas.length - 1 )
			return result;

		}

		// pick random face weighted by face area

		var r, index,
			result = [];

		var stats = {};

		for ( i = 0; i < n; i ++ ) {

			r = THREE.Math.random16() * totalArea;

			index = binarySearchIndices( r );

			result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );

			if ( ! stats[ index ] ) {

				stats[ index ] = 1;

			} else {

				stats[ index ] += 1;

			}

		}

		return result;

	},

	// Get triangle area (half of parallelogram)
	//	http://mathworld.wolfram.com/TriangleArea.html

	triangleArea: function () {

		var vector1 = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function ( vectorA, vectorB, vectorC ) {

			vector1.subVectors( vectorB, vectorA );
			vector2.subVectors( vectorC, vectorA );
			vector1.cross( vector2 );

			return 0.5 * vector1.length();

		};

	}(),

	// Center geometry so that 0,0,0 is in center of bounding box

	center: function ( geometry ) {

		geometry.computeBoundingBox();

		var bb = geometry.boundingBox;

		var offset = new THREE.Vector3();

		offset.addVectors( bb.min, bb.max );
		offset.multiplyScalar( -0.5 );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		geometry.computeBoundingBox();

		return offset;

	},

	triangulateQuads: function ( geometry ) {

		var i, il, j, jl;

		var faces = [];
		var faceVertexUvs = [];

		for ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

			faceVertexUvs[ i ] = [];

		}

		for ( i = 0, il = geometry.faces.length; i < il; i ++ ) {

			var face = geometry.faces[ i ];

			faces.push( face );

			for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {

				faceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );

			}

		}

		geometry.faces = faces;
		geometry.faceVertexUvs = faceVertexUvs;

		geometry.computeCentroids();
		geometry.computeFaceNormals();
		geometry.computeVertexNormals();

		if ( geometry.hasTangents ) geometry.computeTangents();

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageUtils = {

	crossOrigin: 'anonymous',

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.Texture( undefined, mapping );

		var image = loader.load( url, function () {

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		} );

		texture.image = image;
		texture.sourceFile = url;

		return texture;

	},

	loadCompressedTexture: function ( url, mapping, onLoad, onError ) {

		var texture = new THREE.CompressedTexture();
		texture.mapping = mapping;

		var request = new XMLHttpRequest();

		request.onload = function () {

			var buffer = request.response;
			var dds = THREE.ImageUtils.parseDDS( buffer, true );

			texture.format = dds.format;

			texture.mipmaps = dds.mipmaps;
			texture.image.width = dds.width;
			texture.image.height = dds.height;

			// gl.generateMipmap fails for compressed textures
			// mipmaps must be embedded in the DDS file
			// or texture filters must not use mipmapping

			texture.generateMipmaps = false;

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}

		request.onerror = onError;

		request.open( 'GET', url, true );
		request.responseType = "arraybuffer";
		request.send( null );

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.Texture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping needed for cube textures

		texture.flipY = false;

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			var cubeImage = new Image();
			images[ i ] = cubeImage;

			cubeImage.onload = function () {

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			};

			cubeImage.onerror = onError;

			cubeImage.crossOrigin = this.crossOrigin;
			cubeImage.src = array[ i ];

		}

		return texture;

	},

	loadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		var generateCubeFaceCallback = function ( rq, img ) {

			return function () {

				var buffer = rq.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				img.format = dds.format;

				img.mipmaps = dds.mipmaps;
				img.width = dds.width;
				img.height = dds.height;

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

		}

		// compressed cubemap textures as 6 separate DDS files

		if ( array instanceof Array ) {

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				var cubeImage = {};
				images[ i ] = cubeImage;

				var request = new XMLHttpRequest();

				request.onload = generateCubeFaceCallback( request, cubeImage );
				request.onerror = onError;

				var url = array[ i ];

				request.open( 'GET', url, true );
				request.responseType = "arraybuffer";
				request.send( null );

			}

		// compressed cubemap texture stored in a single DDS file

		} else {

			var url = array;
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	loadDDSTexture: function ( url, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		{
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}


				} else {
					texture.image.width = dds.width;
					texture.image.height = dds.height;
					texture.mipmaps = dds.mipmaps;
				}

				texture.format = dds.format;
				texture.needsUpdate = true;
				if ( onLoad ) onLoad( texture );

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	parseDDS: function ( buffer, loadMipmaps ) {

		var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

		// Adapted from @toji's DDS utils
		//	https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

		// All values and structures referenced from:
		// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

		var DDS_MAGIC = 0x20534444;

		var DDSD_CAPS = 0x1,
			DDSD_HEIGHT = 0x2,
			DDSD_WIDTH = 0x4,
			DDSD_PITCH = 0x8,
			DDSD_PIXELFORMAT = 0x1000,
			DDSD_MIPMAPCOUNT = 0x20000,
			DDSD_LINEARSIZE = 0x80000,
			DDSD_DEPTH = 0x800000;

		var DDSCAPS_COMPLEX = 0x8,
			DDSCAPS_MIPMAP = 0x400000,
			DDSCAPS_TEXTURE = 0x1000;

		var DDSCAPS2_CUBEMAP = 0x200,
			DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
			DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
			DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
			DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
			DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
			DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
			DDSCAPS2_VOLUME = 0x200000;

		var DDPF_ALPHAPIXELS = 0x1,
			DDPF_ALPHA = 0x2,
			DDPF_FOURCC = 0x4,
			DDPF_RGB = 0x40,
			DDPF_YUV = 0x200,
			DDPF_LUMINANCE = 0x20000;

		function fourCCToInt32( value ) {

			return value.charCodeAt(0) +
				(value.charCodeAt(1) << 8) +
				(value.charCodeAt(2) << 16) +
				(value.charCodeAt(3) << 24);

		}

		function int32ToFourCC( value ) {

			return String.fromCharCode(
				value & 0xff,
				(value >> 8) & 0xff,
				(value >> 16) & 0xff,
				(value >> 24) & 0xff
			);
		}

		function loadARGBMip( buffer, dataOffset, width, height ) {
			var dataLength = width*height*4;
			var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
			var byteArray = new Uint8Array( dataLength );
			var dst = 0;
			var src = 0;
			for ( var y = 0; y < height; y++ ) {
				for ( var x = 0; x < width; x++ ) {
					var b = srcBuffer[src]; src++;
					var g = srcBuffer[src]; src++;
					var r = srcBuffer[src]; src++;
					var a = srcBuffer[src]; src++;
					byteArray[dst] = r; dst++;	//r
					byteArray[dst] = g; dst++;	//g
					byteArray[dst] = b; dst++;	//b
					byteArray[dst] = a; dst++;	//a
				}
			}
			return byteArray;
		}

		var FOURCC_DXT1 = fourCCToInt32("DXT1");
		var FOURCC_DXT3 = fourCCToInt32("DXT3");
		var FOURCC_DXT5 = fourCCToInt32("DXT5");

		var headerLengthInt = 31; // The header length in 32 bit ints

		// Offsets into the header array

		var off_magic = 0;

		var off_size = 1;
		var off_flags = 2;
		var off_height = 3;
		var off_width = 4;

		var off_mipmapCount = 7;

		var off_pfFlags = 20;
		var off_pfFourCC = 21;
		var off_RGBBitCount = 22;
		var off_RBitMask = 23;
		var off_GBitMask = 24;
		var off_BBitMask = 25;
		var off_ABitMask = 26;

		var off_caps = 27;
		var off_caps2 = 28;
		var off_caps3 = 29;
		var off_caps4 = 30;

		// Parse header

		var header = new Int32Array( buffer, 0, headerLengthInt );

		if ( header[ off_magic ] !== DDS_MAGIC ) {

			console.error( "ImageUtils.parseDDS(): Invalid magic number in DDS header" );
			return dds;

		}

		if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

			console.error( "ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code" );
			return dds;

		}

		var blockBytes;

		var fourCC = header[ off_pfFourCC ];

		var isRGBAUncompressed = false;

		switch ( fourCC ) {

			case FOURCC_DXT1:

				blockBytes = 8;
				dds.format = THREE.RGB_S3TC_DXT1_Format;
				break;

			case FOURCC_DXT3:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT3_Format;
				break;

			case FOURCC_DXT5:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT5_Format;
				break;

			default:

				if( header[off_RGBBitCount] ==32
					&& header[off_RBitMask]&0xff0000
					&& header[off_GBitMask]&0xff00
					&& header[off_BBitMask]&0xff
					&& header[off_ABitMask]&0xff000000  ) {
					isRGBAUncompressed = true;
					blockBytes = 64;
					dds.format = THREE.RGBAFormat;
				} else {
					console.error( "ImageUtils.parseDDS(): Unsupported FourCC code: ", int32ToFourCC( fourCC ) );
					return dds;
				}
		}

		dds.mipmapCount = 1;

		if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

			dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

		}

		//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.

		dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;

		dds.width = header[ off_width ];
		dds.height = header[ off_height ];

		var dataOffset = header[ off_size ] + 4;

		// Extract mipmaps buffers

		var width = dds.width;
		var height = dds.height;

		var faces = dds.isCubemap ? 6 : 1;

		for ( var face = 0; face < faces; face ++ ) {

			for ( var i = 0; i < dds.mipmapCount; i ++ ) {

				if( isRGBAUncompressed ) {
					var byteArray = loadARGBMip( buffer, dataOffset, width, height );
					var dataLength = byteArray.length;
				} else {
					var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
					var byteArray = new Uint8Array( buffer, dataOffset, dataLength );
				}

				var mipmap = { "data": byteArray, "width": width, "height": height };
				dds.mipmaps.push( mipmap );

				dataOffset += dataLength;

				width = Math.max( width * 0.5, 1 );
				height = Math.max( height * 0.5, 1 );

			}

			width = dds.width;
			height = dds.height;

		}

		return dds;

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	  = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach : function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces : {},

	// Just for now. face[weight][style]

	face : "helvetiker",
	weight: "normal",
	style : "normal",
	size : 150,
	divisions : 10,

	getFace : function() {

		return this.faces[ this.face ][ this.weight ][ this.style ];

	},

	loadFace : function( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText : function( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths : fontPaths, offset : width };

	},




	extractGlyphPoints : function( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( !glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch( action ) {

				case 'm':

					// Move To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;
					path.lineTo(x,y);
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i++ ] * scaleX + offset;
					cpy  = outline[ i++ ] * scaleY;
					cpx1 = outline[ i++ ] * scaleX + offset;
					cpy1 = outline[ i++ ] * scaleY;

					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i++ ] *  scaleX + offset;
					cpy  = outline[ i++ ] *  scaleY;
					cpx1 = outline[ i++ ] *  scaleX + offset;
					cpy1 = outline[ i++ ] * -scaleY;
					cpx2 = outline[ i++ ] *  scaleX + offset;
					cpy2 = outline[ i++ ] * -scaleY;

					path.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha*scale, path:path};
	}

};


THREE.FontUtils.generateShapes = function( text, parameters ) {

	// Parameters

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;

	var font = parameters.font !== undefined ? parameters.font : "helvetiker";
	var weight = parameters.weight !== undefined ? parameters.weight : "normal";
	var style = parameters.style !== undefined ? parameters.style : "normal";

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count-- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( "Warning, unable to triangulate polygon!" );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv--;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for( var p = n - 1, q = 0; q < n; p = q++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p++ ) {

			if( (p === u) || (p === v) || (p === w) ) continue;

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX*bpy - aY*bpx;
			cCROSSap = cX*apy - cY*apx;
			bCROSScp = bX*cpy - bY*cpx;

			if ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

})(THREE.FontUtils);

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& !this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return -3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;
	},


	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 â 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 â 2t^2 + t
		var h01 = -6 * t * t + 6 * t; 	// â 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 â t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];

	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);

	if (!startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates, as well as centroid

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY,
		centroid: sum.divideScalar( il )

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or ParticleSystem objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};


/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {

	this.matrixAutoUpdate && this.updateMatrix();

	// update matrixWorld

	if ( this.matrixWorldNeedsUpdate || force ) {

		if ( this.parent ) {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			this.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );
			this.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );

			this.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );


		} else {

			this.matrixWorld.copy( this.matrix );

		}


		this.matrixWorldNeedsUpdate = false;

		force = true;

	}

	// update children

	for ( var i = 0, l = this.children.length; i < l; i ++ ) {

		this.children[ i ].updateMatrixWorld( force );

	}

};

THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();


/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
											   aCP2x, aCP2y,
											   aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(1);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !!args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !!args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

// Breaks path into shapes

THREE.Path.prototype.toShapes = function( isCCW ) {

	var i, il, item, action, args;

	var subPaths = [], lastPath = new THREE.Path();

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		args = item.args;
		action = item.action;

		if ( action == THREE.PathActions.MOVE_TO ) {

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );
				lastPath = new THREE.Path();

			}

		}

		lastPath[ action ].apply( lastPath, args );

	}

	if ( lastPath.actions.length != 0 ) {

		subPaths.push( lastPath );

	}

	// console.log(subPaths);

	if ( subPaths.length == 0 ) return [];

	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length == 1) {

		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? !holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);

	if ( holesFirst ) {

		tmpShape = new THREE.Shape();

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			solid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );
			solid = isCCW ? !solid : solid;

			if ( solid ) {

				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );
				tmpShape = new THREE.Shape();

				//console.log('cw', i);

			} else {

				tmpShape.holes.push( tmpPath );

				//console.log('ccw', i);

			}

		}

	} else {

		// Shapes first
		tmpShape = undefined;

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			solid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );
			solid = isCCW ? !solid : solid;

			if ( solid ) {

				if ( tmpShape ) shapes.push( tmpShape );

				tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

			} else {

				tmpShape.holes.push( tmpPath );

			}

		}

		shapes.push( tmpShape );

	}

	//console.log("shape", shapes);

	return shapes;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	/*
		contour - array of vector2 for contour
		holes   - array of array of vector2
	*/

	removeHoles: function ( contour, holes ) {

		var shape = contour.concat(); // work on this shape
		var allpoints = shape.concat();

		/* For each isolated shape, find the closest points and break to the hole to allow triangulation */


		var prevShapeVert, nextShapeVert,
			prevHoleVert, nextHoleVert,
			holeIndex, shapeIndex,
			shapeId, shapeGroup,
			h, h2,
			hole, shortest, d,
			p, pts1, pts2,
			tmpShape1, tmpShape2,
			tmpHole1, tmpHole2,
			verts = [];

		for ( h = 0; h < holes.length; h ++ ) {

			hole = holes[ h ];

			/*
			shapeholes[ h ].concat(); // preserves original
			holes.push( hole );
			*/

			Array.prototype.push.apply( allpoints, hole );

			shortest = Number.POSITIVE_INFINITY;


			// Find the shortest pair of pts between shape and hole

			// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)
			// Using distanceToSquared() intead of distanceTo() should speed a little
			// since running square roots operations are reduced.

			for ( h2 = 0; h2 < hole.length; h2 ++ ) {

				pts1 = hole[ h2 ];
				var dist = [];

				for ( p = 0; p < shape.length; p++ ) {

					pts2 = shape[ p ];
					d = pts1.distanceToSquared( pts2 );
					dist.push( d );

					if ( d < shortest ) {

						shortest = d;
						holeIndex = h2;
						shapeIndex = p;

					}

				}

			}

			//console.log("shortest", shortest, dist);

			prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
			prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			var areaapts = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var areaa = THREE.FontUtils.Triangulate.area( areaapts );

			var areabpts = [

				hole[ holeIndex ],
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			var areab = THREE.FontUtils.Triangulate.area( areabpts );

			var shapeOffset = 1;
			var holeOffset = -1;

			var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;
			shapeIndex += shapeOffset;
			holeIndex += holeOffset;

			if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
			shapeIndex %= shape.length;

			if ( holeIndex < 0 ) { holeIndex += hole.length;  }
			holeIndex %= hole.length;

			prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
			prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			areaapts = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var areaa2 = THREE.FontUtils.Triangulate.area( areaapts );

			areabpts = [

				hole[ holeIndex ],
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			var areab2 = THREE.FontUtils.Triangulate.area( areabpts );
			//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));

			if ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {

				// In case areas are not correct.
				//console.log("USE THIS");

				shapeIndex = oldShapeIndex;
				holeIndex = oldHoleIndex ;

				if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
				shapeIndex %= shape.length;

				if ( holeIndex < 0 ) { holeIndex += hole.length;  }
				holeIndex %= hole.length;

				prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
				prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			} else {

				//console.log("USE THAT ")

			}

			tmpShape1 = shape.slice( 0, shapeIndex );
			tmpShape2 = shape.slice( shapeIndex );
			tmpHole1 = hole.slice( holeIndex );
			tmpHole2 = hole.slice( 0, holeIndex );

			// Should check orders here again?

			var trianglea = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var triangleb = [

				hole[ holeIndex ] ,
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			verts.push( trianglea );
			verts.push( triangleb );

			shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

		}

		return {

			shape:shape, 		/* shape with no holes */
			isolatedPts: verts, /* isolated faces */
			allpoints: allpoints

		}


	},

	triangulateShape: function ( contour, holes ) {

		var shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );

		var shape = shapeWithoutHoles.shape,
			allpoints = shapeWithoutHoles.allpoints,
			isolatedPts = shapeWithoutHoles.isolatedPts;

		var triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		//console.log( "triangles",triangles, triangles.length );
		//console.log( "allpoints",allpoints, allpoints.length );

		var i, il, f, face,
			key, index,
			allPointsMap = {},
			isolatedPointsMap = {};

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		// check isolated points vertices against all points map

		for ( i = 0, il = isolatedPts.length; i < il; i ++ ) {

			face = isolatedPts[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat( isolatedPts );

	}, // end triangulate shapes

	/*
	triangulate2 : function( pts, holes ) {

		// For use with Poly2Tri.js

		var allpts = pts.concat();
		var shape = [];
		for (var p in pts) {
			shape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));
		}

		var swctx = new js.poly2tri.SweepContext(shape);

		for (var h in holes) {
			var aHole = holes[h];
			var newHole = []
			for (i in aHole) {
				newHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));
				allpts.push(aHole[i]);
			}
			swctx.AddHole(newHole);
		}

		var find;
		var findIndexForPt = function (pt) {
			find = new THREE.Vector2(pt.x, pt.y);
			var p;
			for (p=0, pl = allpts.length; p<pl; p++) {
				if (allpts[p].equals(find)) return p;
			}
			return -1;
		};

		// triangulate
		js.poly2tri.sweep.Triangulate(swctx);

		var triangles =  swctx.GetTriangles();
		var tr ;
		var facesPts = [];
		for (var t in triangles) {
			tr =  triangles[t];
			facesPts.push([
				findIndexForPt(tr.GetPoint(0)),
				findIndexForPt(tr.GetPoint(1)),
				findIndexForPt(tr.GetPoint(2))
					]);
		}


	//	console.log(facesPts);
	//	console.log("triangles", triangles.length, triangles);

		// Returns array of faces with 3 element each
	return facesPts;
	},
*/

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};


/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};
/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return new THREE.Vector2( tx, ty );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};
/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};
/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = (points == undefined) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var v = new THREE.Vector2();
	var c = [];
	var points = this.points, point, intPoint, weight;
	point = ( points.length - 1 ) * t;

	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;
	c[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;

	v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
	v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );

	return v;

};
/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var angle;
	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}

	var tx = this.aX + this.xRadius * Math.cos( angle );
	var ty = this.aY + this.yRadius * Math.sin( angle );

	return new THREE.Vector2( tx, ty );

};

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var r = new THREE.Vector3();


		r.subVectors( this.v2, this.v1 ); // diff
		r.multiplyScalar( t );
		r.add( this.v1 );

		return r;

	}

);

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		tz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);
/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		tz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);
/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

	function ( t ) {

		var v = new THREE.Vector3();
		var c = [];
		var points = this.points, point, intPoint, weight;
		point = ( points.length - 1 ) * t;

		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

		var pt0 = points[ c[0] ],
			pt1 = points[ c[1] ],
			pt2 = points[ c[2] ],
			pt3 = points[ c[3] ];

		v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
		v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
		v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);

		return v;

	}

);


// THREE.SplineCurve3.prototype.getTangent = function(t) {
// 		var v = new THREE.Vector3();
// 		var c = [];
// 		var points = this.points, point, intPoint, weight;
// 		point = ( points.length - 1 ) * t;

// 		intPoint = Math.floor( point );
// 		weight = point - intPoint;

// 		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
// 		c[ 1 ] = intPoint;
// 		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
// 		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

// 		var pt0 = points[ c[0] ],
// 			pt1 = points[ c[1] ],
// 			pt2 = points[ c[2] ],
// 			pt3 = points[ c[3] ];

// 	// t = weight;
// 	v.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );
// 	v.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );
// 	v.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );

// 	return v;

// }
/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

    function ( t ) {

        var v = new THREE.Vector3();
        var c = [];
        var points = this.points, point, intPoint, weight;
        point = ( points.length - 0 ) * t;
            // This needs to be from 0-length +1

        intPoint = Math.floor( point );
        weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
        c[ 0 ] = ( intPoint - 1 ) % points.length;
        c[ 1 ] = ( intPoint ) % points.length;
        c[ 2 ] = ( intPoint + 1 ) % points.length;
        c[ 3 ] = ( intPoint + 2 ) % points.length;

        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );

        return v;

    }

);
/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = (function() {

	var playing = [];
	var library = {};
	var that    = {};


	//--- update ---

	that.update = function( deltaTimeMS ) {

		for( var i = 0; i < playing.length; i ++ )
			playing[ i ].update( deltaTimeMS );

	};


	//--- add ---

	that.addToUpdate = function( animation ) {

		if ( playing.indexOf( animation ) === -1 )
			playing.push( animation );

	};


	//--- remove ---

	that.removeFromUpdate = function( animation ) {

		var index = playing.indexOf( animation );

		if( index !== -1 )
			playing.splice( index, 1 );

	};


	//--- add ---

	that.add = function( data ) {

		if ( library[ data.name ] !== undefined )
			console.log( "THREE.AnimationHandler.add: Warning! " + data.name + " already exists in library. Overwriting." );

		library[ data.name ] = data;
		initData( data );

	};


	//--- get ---

	that.get = function( name ) {

		if ( typeof name === "string" ) {

			if ( library[ name ] ) {

				return library[ name ];

			} else {

				console.log( "THREE.AnimationHandler.get: Couldn't find animation " + name );
				return null;

			}

		} else {

			// todo: add simple tween library

		}

	};

	//--- parse ---

	that.parse = function( root ) {

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for( var b = 0; b < root.bones.length; b++ ) {

				hierarchy.push( root.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	};

	var parseRecurseHierarchy = function( root, hierarchy ) {

		hierarchy.push( root );

		for( var c = 0; c < root.children.length; c++ )
			parseRecurseHierarchy( root.children[ c ], hierarchy );

	}


	//--- init data ---

	var initData = function( data ) {

		if( data.initialized === true )
			return;


		// loop through all keys

		for( var h = 0; h < data.hierarchy.length; h ++ ) {

			for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if( data.hierarchy[ h ].keys[ k ].time < 0 )
					data.hierarchy[ h ].keys[ k ].time = 0;


				// create quaternions

				if( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				 !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );

				}

			}


			// prepare morph target keys

			if( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = -1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}


		// JIT

		var lengthInFrames = parseInt( data.length * data.fps, 10 );

		data.JIT = {};
		data.JIT.hierarchy = [];

		for( var h = 0; h < data.hierarchy.length; h ++ )
			data.JIT.hierarchy.push( new Array( lengthInFrames ) );


		// done

		data.initialized = true;

	};


	// interpolation types

	that.LINEAR = 0;
	that.CATMULLROM = 1;
	that.CATMULLROM_FORWARD = 2;

	return that;

}());

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, name, interpolationType ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( name );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;

	this.points = [];
	this.target = new THREE.Vector3();

};

THREE.Animation.prototype.play = function ( loop, startTimeMS ) {

	if ( this.isPlaying === false ) {

		this.isPlaying = true;
		this.loop = loop !== undefined ? loop : true;
		this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object;

		for ( h = 0; h < hl; h ++ ) {

			object = this.hierarchy[ h ];

			object.matrixAutoUpdate = true;

			if ( object.animationCache === undefined ) {

				object.animationCache = {};
				object.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var prevKey = object.animationCache.prevKey;
			var nextKey = object.animationCache.nextKey;

			prevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];
			prevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];
			prevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];

			nextKey.pos = this.getNextKeyWith( "pos", h, 1 );
			nextKey.rot = this.getNextKeyWith( "rot", h, 1 );
			nextKey.scl = this.getNextKeyWith( "scl", h, 1 );

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};


THREE.Animation.prototype.pause = function() {

	if ( this.isPaused === true ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );

};


THREE.Animation.prototype.update = function ( deltaTimeMS ) {

	// early out

	if ( this.isPlaying === false ) return;


	// vars

	var types = [ "pos", "rot", "scl" ];
	var type;
	var scale;
	var vector;
	var prevXYZ, nextXYZ;
	var prevKey, nextKey;
	var object;
	var animationCache;
	var frame;
	var JIThierarchy = this.data.JIT.hierarchy;
	var currentTime, unloopedCurrentTime;
	var currentPoint, forwardPoint, angle;


	this.currentTime += deltaTimeMS * this.timeScale;

	unloopedCurrentTime = this.currentTime;
	currentTime = this.currentTime = this.currentTime % this.data.length;
	frame = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );


	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		object = this.hierarchy[ h ];
		animationCache = object.animationCache;

		// loop through pos/rot/scl

		for ( var t = 0; t < 3; t ++ ) {

			// get keys

			type    = types[ t ];
			prevKey = animationCache.prevKey[ type ];
			nextKey = animationCache.nextKey[ type ];

			// switch keys?

			if ( nextKey.time <= unloopedCurrentTime ) {

				// did we loop?

				if ( currentTime < unloopedCurrentTime ) {

					if ( this.loop ) {

						prevKey = this.data.hierarchy[ h ].keys[ 0 ];
						nextKey = this.getNextKeyWith( type, h, 1 );

						while( nextKey.time < currentTime ) {

							prevKey = nextKey;
							nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

						}

					} else {

						this.stop();
						return;

					}

				} else {

					do {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					} while( nextKey.time < currentTime )

				}

				animationCache.prevKey[ type ] = prevKey;
				animationCache.nextKey[ type ] = nextKey;

			}


			object.matrixAutoUpdate = true;
			object.matrixWorldNeedsUpdate = true;

			scale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
			prevXYZ = prevKey[ type ];
			nextXYZ = nextKey[ type ];


			// check scale error

			if ( scale < 0 || scale > 1 ) {

				console.log( "THREE.Animation.update: Warning! Scale out of bounds:" + scale + " on bone " + h );
				scale = scale < 0 ? 0 : 1;

			}

			// interpolate

			if ( type === "pos" ) {

				vector = object.position;

				if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

					vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

				} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
						    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

					this.points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
					this.points[ 1 ] = prevXYZ;
					this.points[ 2 ] = nextXYZ;
					this.points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

					scale = scale * 0.33 + 0.33;

					currentPoint = this.interpolateCatmullRom( this.points, scale );

					vector.x = currentPoint[ 0 ];
					vector.y = currentPoint[ 1 ];
					vector.z = currentPoint[ 2 ];

					if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

						forwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );

						this.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
						this.target.sub( vector );
						this.target.y = 0;
						this.target.normalize();

						angle = Math.atan2( this.target.x, this.target.z );
						object.rotation.set( 0, angle, 0 );

					}

				}

			} else if ( type === "rot" ) {

				THREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );

			} else if ( type === "scl" ) {

				vector = object.scale;

				vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
				vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
				vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

			}

		}

	}

};

// Catmull-Rom spline

THREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {

	var c = [], v3 = [],
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	point = ( points.length - 1 ) * scale;
	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
	c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

	pa = points[ c[ 0 ] ];
	pb = points[ c[ 1 ] ];
	pc = points[ c[ 2 ] ];
	pd = points[ c[ 3 ] ];

	w2 = weight * weight;
	w3 = weight * w2;

	v3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
	v3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
	v3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

	return v3;

};

THREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

	var v0 = ( p2 - p0 ) * 0.5,
		v1 = ( p3 - p1 ) * 0.5;

	return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

};



// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key -- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function( root, data, JITCompile ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;
	this.JITCompile = JITCompile !== undefined ? JITCompile : true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};

// Play

THREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {

	if( !this.isPlaying ) {

		this.isPlaying = true;
		this.loop = loop !== undefined ? loop : true;
		this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
		this.startTimeMs = startTimeMS;
		this.startTime = 10000000;
		this.endTime = -this.startTime;


		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};



// Pause

THREE.KeyFrameAnimation.prototype.pause = function() {

	if( this.isPaused ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


// Stop

THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );


	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h++ ) {

        var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			if( obj instanceof THREE.Bone ) {

				original.copy( obj.skinMatrix );
				obj.skinMatrix = original;

			} else {

				original.copy( obj.matrix );
				obj.matrix = original;

			}

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {

	// early out

	if( !this.isPlaying ) return;


	// vars

	var prevKey, nextKey;
	var object;
	var node;
	var frame;
	var JIThierarchy = this.data.JIT.hierarchy;
	var currentTime, unloopedCurrentTime;
	var looped;


	// update

	this.currentTime += deltaTimeMS * this.timeScale;

	unloopedCurrentTime = this.currentTime;
	currentTime         = this.currentTime = this.currentTime % this.data.length;

	// if looped around, the current time should be based on the startTime
	if ( currentTime < this.startTimeMs ) {

		currentTime = this.currentTime = this.startTimeMs + currentTime;

	}

	frame               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );
	looped 				= currentTime < unloopedCurrentTime;

	if ( looped && !this.loop ) {

		// Set the animation to the last keyframes and stop
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				end = keys.length-1,
				obj = this.hierarchy[h];

			if ( keys.length ) {

				for ( var s = 0; s < sids.length; s++ ) {

					var sid = sids[ s ],
						prev = this.getPrevKeyWith( sid, h, end );

					if ( prev ) {
						prev.apply( sid );

					}

				}

				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;

			}

		}

		this.stop();
		return;

	}

	// check pre-infinity
	if ( currentTime < this.startTime ) {

		return;

	}

	// update

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		object = this.hierarchy[ h ];
		node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;

		// use JIT?

		if ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {

			if( object instanceof THREE.Bone ) {

				object.skinMatrix = JIThierarchy[ h ][ frame ];
				object.matrixWorldNeedsUpdate = false;

			} else {

				object.matrix = JIThierarchy[ h ][ frame ];
				object.matrixWorldNeedsUpdate = true;

			}

		// use interpolation

		} else if ( keys.length ) {

			// make sure so original matrix and not JIT matrix is set

			if ( this.JITCompile && animationCache ) {

				if( object instanceof THREE.Bone ) {

					object.skinMatrix = animationCache.originalMatrix;

				} else {

					object.matrix = animationCache.originalMatrix;

				}

			}

			prevKey = animationCache.prevKey;
			nextKey = animationCache.nextKey;

			if ( prevKey && nextKey ) {

				// switch keys?

				if ( nextKey.time <= unloopedCurrentTime ) {

					// did we loop?

					if ( looped && this.loop ) {

						prevKey = keys[ 0 ];
						nextKey = keys[ 1 ];

						while ( nextKey.time < currentTime ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

					} else if ( !looped ) {

						var lastIndex = keys.length - 1;

						while ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

					}

					animationCache.prevKey = prevKey;
					animationCache.nextKey = nextKey;

				}
                if(nextKey.time >= currentTime)
                    prevKey.interpolate( nextKey, currentTime );
                else
                    prevKey.interpolate( nextKey, nextKey.time);

			}

			this.data.hierarchy[h].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

	// update JIT?

	if ( this.JITCompile ) {

		if ( JIThierarchy[ 0 ][ frame ] === undefined ) {

			this.hierarchy[ 0 ].updateMatrixWorld( true );

			for ( var h = 0; h < this.hierarchy.length; h++ ) {

				if( this.hierarchy[ h ] instanceof THREE.Bone ) {

					JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();

				} else {

					JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();

				}

			}

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key-- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, -1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, -1, 0 );
	cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, -1 );
	cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, -1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, -1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

/*
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
 *
 *	A general perpose camera, for setting FOV, Lens Focal Length,
 *		and switching between perspective and orthographic views easily.
 *		Use this only if you do not wish to manage
 *		both a Orthographic and Perspective Camera
 *
 */


THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {

	THREE.Camera.call( this );

	this.fov = fov;

	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

	// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects

	this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthoNear, orthoFar );
	this.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );

	this.zoom = 1;

	this.toPerspective();

	var aspect = width/height;

};

THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.CombinedCamera.prototype.toPerspective = function () {

	// Switches to the Perspective Camera

	this.near = this.cameraP.near;
	this.far = this.cameraP.far;

	this.cameraP.fov =  this.fov / this.zoom ;

	this.cameraP.updateProjectionMatrix();

	this.projectionMatrix = this.cameraP.projectionMatrix;

	this.inPerspectiveMode = true;
	this.inOrthographicMode = false;

};

THREE.CombinedCamera.prototype.toOrthographic = function () {

	// Switches to the Orthographic camera estimating viewport from Perspective

	var fov = this.fov;
	var aspect = this.cameraP.aspect;
	var near = this.cameraP.near;
	var far = this.cameraP.far;

	// The size that we set is the mid plane of the viewing frustum

	var hyperfocus = ( near + far ) / 2;

	var halfHeight = Math.tan( fov / 2 ) * hyperfocus;
	var planeHeight = 2 * halfHeight;
	var planeWidth = planeHeight * aspect;
	var halfWidth = planeWidth / 2;

	halfHeight /= this.zoom;
	halfWidth /= this.zoom;

	this.cameraO.left = -halfWidth;
	this.cameraO.right = halfWidth;
	this.cameraO.top = halfHeight;
	this.cameraO.bottom = -halfHeight;

	// this.cameraO.left = -farHalfWidth;
	// this.cameraO.right = farHalfWidth;
	// this.cameraO.top = farHalfHeight;
	// this.cameraO.bottom = -farHalfHeight;

	// this.cameraO.left = this.left / this.zoom;
	// this.cameraO.right = this.right / this.zoom;
	// this.cameraO.top = this.top / this.zoom;
	// this.cameraO.bottom = this.bottom / this.zoom;

	this.cameraO.updateProjectionMatrix();

	this.near = this.cameraO.near;
	this.far = this.cameraO.far;
	this.projectionMatrix = this.cameraO.projectionMatrix;

	this.inPerspectiveMode = false;
	this.inOrthographicMode = true;

};


THREE.CombinedCamera.prototype.setSize = function( width, height ) {

	this.cameraP.aspect = width / height;
	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

};


THREE.CombinedCamera.prototype.setFov = function( fov ) {

	this.fov = fov;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

// For mantaining similar API with PerspectiveCamera

THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toPerspective();
		this.toOrthographic();

	}

};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

	this.setFov( fov );

	return fov;
};


THREE.CombinedCamera.prototype.setZoom = function( zoom ) {

	this.zoom = zoom;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

THREE.CombinedCamera.prototype.toFrontView = function() {

	this.rotation.x = 0;
	this.rotation.y = 0;
	this.rotation.z = 0;

	// should we be modifing the matrix instead?

	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBackView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toLeftView = function() {

	this.rotation.x = 0;
	this.rotation.y = - Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toRightView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toTopView = function() {

	this.rotation.x = - Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBottomView = function() {

	this.rotation.x = Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};


/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.radius = radius = radius || 50;
	this.segments = segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
	this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var i, uvs = [],
	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

	this.vertices.push(center);
	uvs.push( centerUV );

	for ( i = 0; i <= segments; i ++ ) {

		var vertex = new THREE.Vector3();
		var segment = thetaStart + i / segments * thetaLength;

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		this.vertices.push( vertex );
		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 1; i <= segments; i ++ ) {

		var v1 = i;
		var v2 = i + 1 ;
		var v3 = 0;

		this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.width = width;
	this.height = height;
	this.depth = depth;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var width_half = this.width / 2;
	var height_half = this.height / 2;
	var depth_half = this.depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy++ ) {

			for ( ix = 0; ix < gridX; ix++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.computeCentroids();
	this.mergeVertices();

};

THREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

	THREE.Geometry.call( this );

	this.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;
	this.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	this.height = height = height !== undefined ? height : 100;

	this.radialSegments = radialSegments = radialSegments || 8;
	this.heightSegments = heightSegments = heightSegments || 1;

	this.openEnded = openEnded = openEnded !== undefined ? openEnded : false;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * Math.PI * 2 );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var shapebb = this.shapebb;
	//shapebb = shape.getBoundingBox();



	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( !vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( pt_i, pt_j, pt_k ) {

		// Algorithm 2

		return getBevelVec2( pt_i, pt_j, pt_k );

	}

	function getBevelVec1( pt_i, pt_j, pt_k ) {

		var anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );
		var angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );

		if ( anglea > angleb ) {

			angleb += Math.PI * 2;

		}

		var anglec = ( anglea + angleb ) / 2;


		//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);

		var x = - Math.cos( anglec );
		var y = - Math.sin( anglec );

		var vec = new THREE.Vector2( x, y ); //.normalize();

		return vec;

	}

	function getBevelVec2( pt_i, pt_j, pt_k ) {

		var a = THREE.ExtrudeGeometry.__v1,
			b = THREE.ExtrudeGeometry.__v2,
			v_hat = THREE.ExtrudeGeometry.__v3,
			w_hat = THREE.ExtrudeGeometry.__v4,
			p = THREE.ExtrudeGeometry.__v5,
			q = THREE.ExtrudeGeometry.__v6,
			v, w,
			v_dot_w_hat, q_sub_p_dot_w_hat,
			s, intersection;

		// good reading for line-line intersection
		// http://sputsoft.com/blog/2010/03/line-line-intersection.html

		// define a as vector j->i
		// define b as vectot k->i

		a.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );
		b.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );

		// get unit vectors

		v = a.normalize();
		w = b.normalize();

		// normals from pt i

		v_hat.set( -v.y, v.x );
		w_hat.set( w.y, -w.x );

		// pts from i

		p.copy( pt_i ).add( v_hat );
		q.copy( pt_i ).add( w_hat );

		if ( p.equals( q ) ) {

			//console.log("Warning: lines are straight");
			return w_hat.clone();

		}

		// Points from j, k. helps prevents points cross overover most of the time

		p.copy( pt_j ).add( v_hat );
		q.copy( pt_k ).add( w_hat );

		v_dot_w_hat = v.dot( w_hat );
		q_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );

		// We should not reach these conditions

		if ( v_dot_w_hat === 0 ) {

			console.log( "Either infinite or no solutions!" );

			if ( q_sub_p_dot_w_hat === 0 ) {

				console.log( "Its finite solutions." );

			} else {

				console.log( "Too bad, no solutions." );

			}

		}

		s = q_sub_p_dot_w_hat / v_dot_w_hat;

		if ( s < 0 ) {

			// in case of emergecy, revert to algorithm 1.

			return getBevelVec1( pt_i, pt_j, pt_k );

		}

		intersection = v.multiplyScalar( s ).add( p );

		return intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly

	}

	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			//vert = scalePt( contour[ i ], contourCentroid, bs, false );
			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
				//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );

				v( vert.x, vert.y,  -z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( !extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( !extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( !extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ], true );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c, isBottom ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,
 		                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );

 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y;

		return [
			new THREE.Vector2( ax, ay ),
			new THREE.Vector2( bx, by ),
			new THREE.Vector2( cx, cy )
		];

	},

	generateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {

		return this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );

	},

	generateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,
	                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,
	                              contourIndex1, contourIndex2 ) {

		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,
			az = geometry.vertices[ indexA ].z,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,
			bz = geometry.vertices[ indexB ].z,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y,
			cz = geometry.vertices[ indexC ].z,

			dx = geometry.vertices[ indexD ].x,
			dy = geometry.vertices[ indexD ].y,
			dz = geometry.vertices[ indexD ].z;

		if ( Math.abs( ay - by ) < 0.01 ) {
			return [
				new THREE.Vector2( ax, 1 - az ),
				new THREE.Vector2( bx, 1 - bz ),
				new THREE.Vector2( cx, 1 - cz ),
				new THREE.Vector2( dx, 1 - dz )
			];
		} else {
			return [
				new THREE.Vector2( ay, 1 - az ),
				new THREE.Vector2( by, 1 - bz ),
				new THREE.Vector2( cy, 1 - cz ),
				new THREE.Vector2( dy, 1 - dz )
			];
		}
	}
};

THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	var shapebb = this.shapebb;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );

	}

};

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.
THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );

	this.width = width;
	this.height = height;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;

	var ix, iz;
	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = this.widthSegments;
	var gridZ = this.heightSegments;

	var gridX1 = gridX + 1;
	var gridZ1 = gridZ + 1;

	var segment_width = this.width / gridX;
	var segment_height = this.height / gridZ;

	var normal = new THREE.Vector3( 0, 0, 1 );

	for ( iz = 0; iz < gridZ1; iz ++ ) {

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;
			var y = iz * segment_height - height_half;

			this.vertices.push( new THREE.Vector3( x, - y, 0 ) );

		}

	}

	for ( iz = 0; iz < gridZ; iz ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iz;
			var b = ix + gridX1 * ( iz + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iz + 1 );
			var d = ( ix + 1 ) + gridX1 * iz;

			var uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );
			var uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );
			var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );
			var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );

			var face = new THREE.Face3( a, b, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			face = new THREE.Face3( b, c, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeCentroids();

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring

		for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

		var thetaSegment = i * thetaSegments;

		for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment + i;
			var v2 = segment + thetaSegments + i;
			var v3 = segment + thetaSegments + 1 + i;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			v1 = segment + i;
			v2 = segment + thetaSegments + 1 + i;
			v3 = segment + 1 + i;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.radius = radius = radius || 50;

	this.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	this.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	this.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;
	this.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
	this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;
			var v = y / heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < this.heightSegments; y ++ ) {

		for ( x = 0; x < this.widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {

				uv1.x = ( uv1.x + uv2.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {

				uv3.x = ( uv3.x + uv4.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 8;
	this.tubularSegments = tubularSegments || 6;
	this.arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= this.radialSegments; j ++ ) {

		for ( var i = 0; i <= this.tubularSegments; i ++ ) {

			var u = i / this.tubularSegments * this.arc;
			var v = j / this.radialSegments * Math.PI * 2;

			center.x = this.radius * Math.cos( u );
			center.y = this.radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = this.tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}
	}


	for ( var j = 1; j <= this.radialSegments; j ++ ) {

		for ( var i = 1; i <= this.tubularSegments; i ++ ) {

			var a = ( this.tubularSegments + 1 ) * j + i - 1;
			var b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( this.tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ], normals[ b ], normals[ d ] ] );
			face.normal.add( normals[ a ] );
			face.normal.add( normals[ b ] );
			face.normal.add( normals[ d ] );
			face.normal.normalize();

			this.faces.push( face );

			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ], normals[ c ], normals[ d ] ] );
			face.normal.add( normals[ b ] );
			face.normal.add( normals[ c ] );
			face.normal.add( normals[ d ] );
			face.normal.normalize();

			this.faces.push( face );

			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
		}

	}

	this.computeCentroids();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 64;
	this.tubularSegments = tubularSegments || 8;
	this.p = p || 2;
	this.q = q || 3;
	this.heightScale = heightScale || 1;
	this.grid = new Array( this.radialSegments );

	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		this.grid[ i ] = new Array( this.tubularSegments );
		var u = i / this.radialSegments * 2 * this.p * Math.PI;
		var p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );
		var p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var v = j / this.tubularSegments * 2 * Math.PI;
			var cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = this.tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			this.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % this.radialSegments;
			var jp = ( j + 1 ) % this.tubularSegments;

			var a = this.grid[ i ][ j ];
			var b = this.grid[ ip ][ j ];
			var c = this.grid[ ip ][ jp ];
			var d = this.grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );
			var uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {

	THREE.Geometry.call( this );

	this.path = path;
	this.segments = segments || 64;
	this.radius = radius || 1;
	this.radialSegments = radialSegments || 8;
	this.closed = closed || false;

	this.grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = this.segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}


	// consruct the grid

	for ( i = 0; i < numpoints; i++ ) {

		this.grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		for ( j = 0; j < this.radialSegments; j++ ) {

			v = j / this.radialSegments * 2 * Math.PI;

			cx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = this.radius * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			this.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < this.segments; i++ ) {

		for ( j = 0; j < this.radialSegments; j++ ) {

			ip = ( this.closed ) ? (i + 1) % this.segments : i + 1;
			jp = (j + 1) % this.radialSegments;

			a = this.grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = this.grid[ ip ][ j ];
			c = this.grid[ ip ][ jp ];
			d = this.grid[ i ][ jp ];

			uva = new THREE.Vector2( i / this.segments, j / this.radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );
			uvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = -theta;

		}

		for ( i = 1; i < numpoints; i++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {

	THREE.Geometry.call( this );

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i ++ ) {

		prepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	var f = [];
	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var v1 = p[ faces[ i ][ 0 ] ];
		var v2 = p[ faces[ i ][ 1 ] ];
		var v3 = p[ faces[ i ][ 2 ] ];

		f[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	for ( var i = 0, l = f.length; i < l; i ++ ) {

		subdivide(f[ i ], detail);

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, Math.max( x1, x2 ) );
		var min = Math.min( x0, Math.min( x1, x2 ) );

		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeCentroids();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		face.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
		that.faces.push( face );

		var azi = azimuth( face.centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide(face, detail ) {

		var cols = Math.pow(2, detail);
		var cells = Math.pow(4, detail);
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++) {

				if ( j == 0 && i == cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 == 0 ) {

					make(
						v[ i ][ k + 1],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1][ k + 1],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, -vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	this.radius = radius;
	this.detail = detail;

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
		[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
		[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
	];

	var faces = [
		[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],
		[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],
		[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],
		[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]
	];

	var faces = [
		[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]
	];

	var faces = [
		[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j + 1;
			d = (i + 1) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var geometry = new THREE.Geometry();

	geometry.vertices.push(
		new THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, 0, size )
	);

	geometry.colors.push(
		new THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),
		new THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),
		new THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )
	);

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  hex - color in hex value
 */

THREE.ArrowHelper = function ( dir, origin, length, hex ) {

	// dir is assumed to be normalized

	THREE.Object3D.call( this );

	if ( hex === undefined ) hex = 0xffff00;
	if ( length === undefined ) length = 1;

	this.position = origin;

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
	lineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );

	this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.05, 0.25, 5, 1 );
	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.875, 0 ) );

	this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length );

};

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = function () {

	var axis = new THREE.Vector3();
	var radians;

	return function ( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}();

THREE.ArrowHelper.prototype.setLength = function ( length ) {

	this.scale.set( length, length, length );

};

THREE.ArrowHelper.prototype.setColor = function ( hex ) {

	this.line.material.color.setHex( hex );
	this.cone.material.color.setHex( hex );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	//   5____4
	// 1/___0/|
	// | 6__|_7
	// 2/___3/

	var vertices = [
		new THREE.Vector3(   1,   1,   1 ),
		new THREE.Vector3( - 1,   1,   1 ),
		new THREE.Vector3( - 1, - 1,   1 ),
		new THREE.Vector3(   1, - 1,   1 ),

		new THREE.Vector3(   1,   1, - 1 ),
		new THREE.Vector3( - 1,   1, - 1 ),
		new THREE.Vector3( - 1, - 1, - 1 ),
		new THREE.Vector3(   1, - 1, - 1 )
	];

	this.vertices = vertices;

	// TODO: Wouldn't be nice if Line had .segments?

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		vertices[ 0 ], vertices[ 1 ],
		vertices[ 1 ], vertices[ 2 ],
		vertices[ 2 ], vertices[ 3 ],
		vertices[ 3 ], vertices[ 0 ],

		vertices[ 4 ], vertices[ 5 ],
		vertices[ 5 ], vertices[ 6 ],
		vertices[ 6 ], vertices[ 7 ],
		vertices[ 7 ], vertices[ 4 ],

		vertices[ 0 ], vertices[ 4 ],
		vertices[ 1 ], vertices[ 5 ],
		vertices[ 2 ], vertices[ 6 ],
		vertices[ 3 ], vertices[ 7 ]
	);

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

THREE.BoxHelper.prototype.update = function ( object ) {

	var geometry = object.geometry;

	if ( geometry.boundingBox === null ) {

		geometry.computeBoundingBox();

	}

	var min = geometry.boundingBox.min;
	var max = geometry.boundingBox.max;
	var vertices = this.vertices;

	vertices[ 0 ].set( max.x, max.y, max.z );
	vertices[ 1 ].set( min.x, max.y, max.z );
	vertices[ 2 ].set( min.x, min.y, max.z );
	vertices[ 3 ].set( max.x, min.y, max.z );
	vertices[ 4 ].set( max.x, max.y, min.z );
	vertices[ 5 ].set( min.x, max.y, min.z );
	vertices[ 6 ].set( min.x, min.y, min.z );
	vertices[ 7 ].set( max.x, min.y, min.z );

	this.geometry.computeBoundingSphere();
	this.geometry.verticesNeedUpdate = true;

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = hex || 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.CubeGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.camera = camera;
	this.matrixWorld = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();
	var projector = new THREE.Projector();

	return function () {

		var scope = this;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, -1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", -w, -h, -1 );
		setPoint( "n2",  w, -h, -1 );
		setPoint( "n3", -w,  h, -1 );
		setPoint( "n4",  w,  h, -1 );

		// far

		setPoint( "f1", -w, -h, 1 );
		setPoint( "f2",  w, -h, 1 );
		setPoint( "f3", -w,  h, 1 );
		setPoint( "f4",  w,  h, 1 );

		// up

		setPoint( "u1",  w * 0.7, h * 1.1, -1 );
		setPoint( "u2", -w * 0.7, h * 1.1, -1 );
		setPoint( "u3",        0, h * 2,   -1 );

		// cross

		setPoint( "cf1", -w,  0, 1 );
		setPoint( "cf2",  w,  0, 1 );
		setPoint( "cf3",  0, -h, 1 );
		setPoint( "cf4",  0,  h, 1 );

		setPoint( "cn1", -w,  0, -1 );
		setPoint( "cn2",  w,  0, -1 );
		setPoint( "cn3",  0, -h, -1 );
		setPoint( "cn4",  0,  h, -1 );

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z );
			projector.unprojectVector( vector, camera );

			var points = scope.pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					scope.geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		}

		this.geometry.verticesNeedUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;
	var geometry = new THREE.PlaneGeometry( size, size );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Mesh( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3() );
	geometry.vertices.push( new THREE.Vector3() );

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.getPositionFromMatrix( this.light.matrixWorld );
		v2.getPositionFromMatrix( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	}

}();


/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = size || 1;

	var color = hex || 0xffff00;

	var width = linewidth || 1;

	var geometry = new THREE.Geometry();

	var faces = this.object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.vertices.push( new THREE.Vector3() );

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.FaceNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function ( object ) {

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			v1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

			var idx = 2 * i;

			vertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );

			vertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());


/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.getPositionFromMatrix( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();


/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrixWorld = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};


/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.getPositionFromMatrix( this.light.matrixWorld );
		vector2.getPositionFromMatrix( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = size || 1;

	var color = hex || 0xff0000;

	var width = linewidth || 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var normal = face.vertexNormals[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = size || 1;

	var color = hex || 0x0000ff;

	var width = linewidth || 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var tangent = face.vertexTangents[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object ) {

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c', 'd' ];
	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;
	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				geometry.vertices.push( vertices[ edge[ 0 ] ] );
				geometry.vertices.push( vertices[ edge[ 1 ] ] );

				hash[ key ] = true;

			}

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffffff } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) { };

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if( size === undefined ) size = -1;
	if( distance === undefined ) distance = 0;
	if( opacity === undefined ) opacity = 1;
	if( color === undefined ) color = new THREE.Color( 0xffffff );
	if( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( { texture: texture, 			// THREE.Texture
		                    size: size, 				// size in pixels (-1 = use texture.width)
		                    distance: distance, 		// distance (0-1) from light source (0=at light source)
		                    x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		                    scale: 1, 					// scale
		                    rotation: 1, 				// rotation
		                    opacity: opacity,			// opacity
							color: color,				// color
		                    blending: blending } );		// blending

};


/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = -this.positionScreen.x * 2;
	var vecY = -this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};













/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = -1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = -1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= -1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function () {

	var _gl, _renderer, _precision, _lensFlare = {};

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		_precision = renderer.getPrecision();

		_lensFlare.vertices = new Float32Array( 8 + 8 );
		_lensFlare.faces = new Uint16Array( 6 );

		var i = 0;
		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;	// vertex
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;	// uv... etc.

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;

		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;

		i = 0;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;

		// buffers

		_lensFlare.vertexBuffer     = _gl.createBuffer();
		_lensFlare.elementBuffer    = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );

		// textures

		_lensFlare.tempTexture      = _gl.createTexture();
		_lensFlare.occlusionTexture = _gl.createTexture();

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		if ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {

			_lensFlare.hasVertexTexture = false;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlare" ], _precision );

		} else {

			_lensFlare.hasVertexTexture = true;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlareVertexTexture" ], _precision );

		}

		_lensFlare.attributes = {};
		_lensFlare.uniforms = {};

		_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, "position" );
		_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, "uv" );

		_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, "renderType" );
		_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, "map" );
		_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, "occlusionMap" );
		_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, "opacity" );
		_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, "color" );
		_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, "scale" );
		_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, "rotation" );
		_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, "screenPosition" );

	};


	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 *         Then _lensFlare.update_lensFlares() is called to re-position and
	 *         update transparency of flares. Then they are rendered.
	 *
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var flares = scene.__webglFlares,
			nFlares = flares.length;

		if ( ! nFlares ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		var uniforms = _lensFlare.uniforms,
			attributes = _lensFlare.attributes;

		// set _lensFlare program and reset blending

		_gl.useProgram( _lensFlare.program );

		_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );
		_gl.enableVertexAttribArray( _lensFlare.attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		_gl.uniform1i( uniforms.occlusionMap, 0 );
		_gl.uniform1i( uniforms.map, 1 );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );

		_gl.disable( _gl.CULL_FACE );
		_gl.depthMask( false );

		var i, j, jl, flare, sprite;

		for ( i = 0; i < nFlares; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( _lensFlare.hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				_gl.uniform1i( uniforms.renderType, 0 );
				_gl.uniform2f( uniforms.scale, scale.x, scale.y );
				_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				_gl.disable( _gl.BLEND );
				_gl.enable( _gl.DEPTH_TEST );

				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				_gl.activeTexture( _gl.TEXTURE0 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				_gl.uniform1i( uniforms.renderType, 1 );
				_gl.disable( _gl.DEPTH_TEST );

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				_gl.uniform1i( uniforms.renderType, 2 );
				_gl.enable( _gl.BLEND );

				for ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						_gl.uniform2f( uniforms.scale, scale.x, scale.y );
						_gl.uniform1f( uniforms.rotation, sprite.rotation );

						_gl.uniform1f( uniforms.opacity, sprite.opacity );
						_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						_renderer.setTexture( sprite.texture, 1 );

						_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );
		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthMask( true );

	};

	function createProgram ( shader, precision ) {

		var program = _gl.createProgram();

		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );

		var prefix = "precision " + precision + " float;\n";

		_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		_gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		_gl.compileShader( fragmentShader );
		_gl.compileShader( vertexShader );

		_gl.attachShader( program, fragmentShader );
		_gl.attachShader( program, vertexShader );

		_gl.linkProgram( program );

		return program;

	};

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function () {

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,
		renderList,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = scene.__lights.length; i < il; i ++ ) {

			light = scene.__lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position = light.shadowCascadeOffset;

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					console.error( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				light.shadowCamera.add( light.cameraHelper );

			}

			if ( light.isVirtual && virtualLight.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			shadowCamera.position.getPositionFromMatrix( light.matrixWorld );
			_matrixPosition.getPositionFromMatrix( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
							  0.0, 0.5, 0.0, 0.5,
							  0.0, 0.0, 0.5, 0.5,
							  0.0, 0.0, 0.0, 1.0 );

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			renderList = scene.__webglObjects;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				webglObject.render = false;

				if ( object.visible && object.castShadow ) {

					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						webglObject.render = true;

					}

				}

			}

			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];

				if ( webglObject.render ) {

					object = webglObject.object;
					buffer = webglObject.buffer;

					// culling is overriden globally for all objects
					// while rendering depth map

					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)

					objectMaterial = getObjectMaterial( object );

					useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

					if ( object.customDepthMaterial ) {

						material = object.customDepthMaterial;

					} else if ( useSkinning ) {

						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

					} else if ( useMorphing ) {

						material = _depthMaterialMorph;

					} else {

						material = _depthMaterial;

					}

					if ( buffer instanceof THREE.BufferGeometry ) {

						_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );

					} else {

						_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );

					}

				}

			}

			// set matrices and render immediate objects

			renderList = scene.__webglObjectsImmediate;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

	};

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( -1, -1, nearZ );
		pointsFrustum[ 1 ].set(  1, -1, nearZ );
		pointsFrustum[ 2 ].set( -1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( -1, -1, farZ );
		pointsFrustum[ 5 ].set(  1, -1, farZ );
		pointsFrustum[ 6 ].set( -1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( -Infinity, -Infinity, -Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			THREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

THREE.ShadowMapPlugin.__projector = new THREE.Projector();

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function () {

	var _gl, _renderer, _texture;

	var vertices, faces, vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		vertices = new Float32Array( [
			- 0.5, - 0.5, 0, 0,
			  0.5, - 0.5, 1, 0,
			  0.5,   0.5, 1, 1,
			- 0.5,   0.5, 0, 1
		] );

		faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = _gl.createBuffer();
		elementBuffer = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			_gl.getAttribLocation ( program, 'position' ),
			uv:					_gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			_gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			_gl.getUniformLocation( program, 'uvScale' ),

			rotation:			_gl.getUniformLocation( program, 'rotation' ),
			scale:				_gl.getUniformLocation( program, 'scale' ),
			halfViewport: 		_gl.getUniformLocation( program, 'halfViewport' ),

			color:				_gl.getUniformLocation( program, 'color' ),
			map:				_gl.getUniformLocation( program, 'map' ),
			opacity:			_gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	_gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	_gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			_gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			_gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			_gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				_gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			_gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			_gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = '#ffffff';
		context.fillRect( 0, 0, canvas.width, canvas.height );

		_texture = new THREE.Texture( canvas );
		_texture.needsUpdate = true;

	};

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var sprites = scene.__webglSprites,
			nSprites = sprites.length;

		if ( ! nSprites ) return;

		var halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		// setup gl

		_gl.useProgram( program );

		_gl.enableVertexAttribArray( attributes.position );
		_gl.enableVertexAttribArray( attributes.uv );

		_gl.disable( _gl.CULL_FACE );
		_gl.enable( _gl.BLEND );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
		_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		_gl.activeTexture( _gl.TEXTURE0 );
		_gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				_gl.uniform1f( uniforms.fogNear, fog.near );
				_gl.uniform1f( uniforms.fogFar, fog.far );

				_gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				_gl.uniform1f( uniforms.fogDensity, fog.density );

				_gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			_gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		var i, sprite, material, fogType, scale = [];

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];
			material = sprite.material;

			if ( sprite.visible === false ) continue;

			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];

			if ( sprite.visible === false ) continue;

			material = sprite.material;

			_gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

			scale[ 0 ] = sprite.scale.x;
			scale[ 1 ] = sprite.scale.y;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			} else {

				fogType = 0;

			}

			if ( oldFogType !== fogType ) {

				_gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			_gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );
			_gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );

			_gl.uniform1f( uniforms.opacity, material.opacity );
			_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			_gl.uniform1f( uniforms.rotation, material.rotation );
			_gl.uniform2fv( uniforms.scale, scale );
			_gl.uniform2f( uniforms.halfViewport, halfViewportWidth, halfViewportHeight );

			_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			_renderer.setDepthTest( material.depthTest );
			_renderer.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				_renderer.setTexture( material.map, 0 );

			} else {

				_renderer.setTexture( _texture, 0 );

			}

			_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );

	};

	function createProgram () {

		var program = _gl.createProgram();

		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );

		_gl.shaderSource( vertexShader, [

			'precision ' + _renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',
			'uniform vec2 halfViewport;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		_gl.shaderSource( fragmentShader, [

			'precision ' + _renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		_gl.compileShader( vertexShader );
		_gl.compileShader( fragmentShader );

		_gl.attachShader( program, vertexShader );
		_gl.attachShader( program, fragmentShader );

		_gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DepthPassPlugin = function () {

	this.enabled = false;
	this.renderTarget = null;

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! this.enabled ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		program, buffer, material,
		webglObject, object, light,
		renderList,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_renderer.setDepthTest( true );

		// update scene

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// render depth map

		_renderer.setRenderTarget( this.renderTarget );
		_renderer.clear();

		// set object matrices & frustum culling

		renderList = scene.__webglObjects;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

					webglObject.render = true;

				}

			}

		}

		// render regular objects

		var objectMaterial, useMorphing, useSkinning;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				// todo: create proper depth material for particles

				if ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;

				objectMaterial = getObjectMaterial( object );

				if ( objectMaterial ) _renderer.setMaterialFaces( object.material );

				useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				if ( buffer instanceof THREE.BufferGeometry ) {

					_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );

				} else {

					_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );

				}

			}

		}

		// set matrices and render immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			if ( object.visible ) {

				object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

				_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

	};

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};


/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderFlares = {

	'lensFlareVertexTexture': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"uniform sampler2D occlusionMap;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

					"vVisibility =        visibility.r / 9.0;",
					"vVisibility *= 1.0 - visibility.g / 9.0;",
					"vVisibility *=       visibility.b / 9.0;",
					"vVisibility *= 1.0 - visibility.a / 9.0;",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * vVisibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"
		].join( "\n" )

	},


	'lensFlare': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"precision mediump float;",

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform sampler2D occlusionMap;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
					"visibility = ( 1.0 - visibility / 4.0 );",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * visibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"

		].join( "\n" )

	}

};



/**
 *  Add the following part to three item later
 */

/**
 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CSS3DObject = function ( element ) {

	THREE.Object3D.call( this );

	this.element = element;
	this.element.style.position = 'absolute';
	this.element.style.WebkitTransformStyle = 'preserve-3d';
	this.element.style.MozTransformStyle = 'preserve-3d';
	this.element.style.oTransformStyle = 'preserve-3d';
	this.element.style.transformStyle = 'preserve-3d';

	this.addEventListener( 'removed', function ( event ) {

		if ( this.element.parentNode !== null ) {

			this.element.parentNode.removeChild( this.element );

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].dispatchEvent( event );

			}

		}

	} );

};

THREE.CSS3DObject.prototype = Object.create( THREE.Object3D.prototype );

THREE.CSS3DSprite = function ( element ) {

	THREE.CSS3DObject.call( this, element );

};

THREE.CSS3DSprite.prototype = Object.create( THREE.CSS3DObject.prototype );

//

THREE.CSS3DRenderer = function () {

	console.log( 'THREE.CSS3DRenderer', THREE.REVISION );

	var _width, _height;
	var _widthHalf, _heightHalf;

	var matrix = new THREE.Matrix4();

	var domElement = document.createElement( 'div' );
	domElement.style.overflow = 'hidden';

	domElement.style.WebkitTransformStyle = 'preserve-3d';
	domElement.style.MozTransformStyle = 'preserve-3d';
	domElement.style.oTransformStyle = 'preserve-3d';
	domElement.style.transformStyle = 'preserve-3d';

	this.domElement = domElement;

	var cameraElement = document.createElement( 'div' );

	cameraElement.style.WebkitTransformStyle = 'preserve-3d';
	cameraElement.style.MozTransformStyle = 'preserve-3d';
	cameraElement.style.oTransformStyle = 'preserve-3d';
	cameraElement.style.transformStyle = 'preserve-3d';

	domElement.appendChild( cameraElement );

	this.setSize = function ( width, height ) {

		_width = width;
		_height = height;

		_widthHalf = _width / 2;
		_heightHalf = _height / 2;

		domElement.style.width = width + 'px';
		domElement.style.height = height + 'px';

		cameraElement.style.width = width + 'px';
		cameraElement.style.height = height + 'px';

	};

	var epsilon = function ( value ) {

		return Math.abs( value ) < 0.000001 ? 0 : value;

	};

	var getCameraCSSMatrix = function ( matrix ) {

		var elements = matrix.elements;

		return 'matrix3d(' +
			epsilon( elements[ 0 ] ) + ',' +
			epsilon( - elements[ 1 ] ) + ',' +
			epsilon( elements[ 2 ] ) + ',' +
			epsilon( elements[ 3 ] ) + ',' +
			epsilon( elements[ 4 ] ) + ',' +
			epsilon( - elements[ 5 ] ) + ',' +
			epsilon( elements[ 6 ] ) + ',' +
			epsilon( elements[ 7 ] ) + ',' +
			epsilon( elements[ 8 ] ) + ',' +
			epsilon( - elements[ 9 ] ) + ',' +
			epsilon( elements[ 10 ] ) + ',' +
			epsilon( elements[ 11 ] ) + ',' +
			epsilon( elements[ 12 ] ) + ',' +
			epsilon( - elements[ 13 ] ) + ',' +
			epsilon( elements[ 14 ] ) + ',' +
			epsilon( elements[ 15 ] ) +
		')';

	};

	var getObjectCSSMatrix = function ( matrix ) {

		var elements = matrix.elements;

		return 'translate3d(-50%,-50%,0) matrix3d(' +
			epsilon( elements[ 0 ] ) + ',' +
			epsilon( elements[ 1 ] ) + ',' +
			epsilon( elements[ 2 ] ) + ',' +
			epsilon( elements[ 3 ] ) + ',' +
			epsilon( - elements[ 4 ] ) + ',' +
			epsilon( - elements[ 5 ] ) + ',' +
			epsilon( - elements[ 6 ] ) + ',' +
			epsilon( - elements[ 7 ] ) + ',' +
			epsilon( elements[ 8 ] ) + ',' +
			epsilon( elements[ 9 ] ) + ',' +
			epsilon( elements[ 10 ] ) + ',' +
			epsilon( elements[ 11 ] ) + ',' +
			epsilon( elements[ 12 ] ) + ',' +
			epsilon( elements[ 13 ] ) + ',' +
			epsilon( elements[ 14 ] ) + ',' +
			epsilon( elements[ 15 ] ) +
		')';

	};

	var renderObject = function ( object, camera ) {

		if ( object instanceof THREE.CSS3DObject ) {
			//console.log("css object: " + object);
			//console.log("css object length" + object.length);

			var style;

			if ( object instanceof THREE.CSS3DSprite ) {

				// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/

				matrix.copy( camera.matrixWorldInverse );
				matrix.transpose();
				matrix.copyPosition( object.matrixWorld );
				matrix.scale( object.scale );

				matrix.elements[ 3 ] = 0;
				matrix.elements[ 7 ] = 0;
				matrix.elements[ 11 ] = 0;
				matrix.elements[ 15 ] = 1;

				style = getObjectCSSMatrix( matrix );

			} else {

				style = getObjectCSSMatrix( object.matrixWorld );

			}

			var element = object.element;

			element.style.WebkitTransform = style;
			element.style.MozTransform = style;
			element.style.oTransform = style;
			element.style.transform = style;

			if ( element.parentNode !== cameraElement ) {

				cameraElement.appendChild( element );

			}

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			renderObject( object.children[ i ], camera );

		}

	};

	this.render = function ( scene, camera ) {
		//console.log("Enter css render");

		var fov = 0.5 / Math.tan( THREE.Math.degToRad( camera.fov * 0.5 ) ) * _height;

		domElement.style.WebkitPerspective = fov + "px";
		domElement.style.MozPerspective = fov + "px";
		domElement.style.oPerspective = fov + "px";
		domElement.style.perspective = fov + "px";

		scene.updateMatrixWorld();

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		var style = "translate3d(0,0," + fov + "px)" + getCameraCSSMatrix( camera.matrixWorldInverse ) +
			" translate3d(" + _widthHalf + "px," + _heightHalf + "px, 0)";

		cameraElement.style.WebkitTransform = style;
		cameraElement.style.MozTransform = style;
		cameraElement.style.oTransform = style;
		cameraElement.style.transform = style;

		renderObject( scene, camera );

	};

};


return THREE;

});

define ('Config',[],function () {
    
    var _mode = "stereopolis";
    
    /**
     * Manages the global configuration of iTOWNS
     * @export Config
     */
    
    var Config = {
        
        init : function (conf){
            _mode = conf;
        },
        
        dataURL:{
            defaultUrlMetaDataProviderPos  : "php/getInfosFromPos.php?",
            defaultUrlMetaDataProviderName : "php/getInfosFromName.php?",
            defaultUrlImageFile            : "",
            defaultUrlMetaProviderSensor   : "php/getSensorsInfos.php",
            defaultUrlBuildingFootprint    : "http://wxs.ign.fr/",
            defaultUrlDTM                  : "php/getDTM.php?",
            defaultUrlPointCloud           : "http://www.itowns.fr/viewer/",
            defaultUrl3DBuilding           : "http://www.itowns.fr/viewer/Bati3D_LOB/Version4LODS/"
        },
        
        
        phpDir : "php/", //"http://www.itowns.fr/php2/",

        set conf(val) { 
            if (val === "dell") {
                _mode = "dell";
            }
            else {
                _mode = "stereopolis";
            }
        },
        serverList : ["stereopolis", "dell"],
        server : {
            dell : {
                url : "http://DEL1101W001", //
                iipService : ""
            },
            stereopolis : {
                url : "http://www.itowns.fr",
                iipService : ""
            },
            get url () { return this[_mode].url; },
            get iipService() { return this[_mode].iipService; },
        },
        geoAPIKey : ""
    };
    
    return Config;
});

// Nouvelle cle all Services (WMS/WMTS, orthoPARIS) itowns.fr 8c7lypm4agbrdinqtj2u6q8i  (expire le 20/11/2016)
// ClÃ© localhost all Services (WMS/WMTS, orthoPARIS): ngpro6r3fk4d49q5eqihgn18 (expire le 20/11/2016)
;
define('RequestManager',['jquery', 'Config'],function($, Config) {
    
    //PRIVATE MEMBERS******************************************************************************************
    //*********************************************************************************************************
    
    // ATTRIBUTES
    //*************************************
   
    //var GEOPORTAL_CLASSES = ['OpenLayers','Geoportal'],
    DEBUG = true;
  
    //Web processing service
    var _capabilitiesWPS     = null;
    var _serviceWPS          = [];
    var _processWPS          = null;
    
    // METHODS
    //*************************************
    function printRequestError(jqxhr, textStatus, error){
        
        msg = textStatus + ', ' + error;
        console.error(msg);
    }
    
    //END OF PRIVATE MEMBERS***********************************************************************************
    //*********************************************************************************************************
    
    /**
     * Manages request sent to the web server
     * @author Alexandre Devaux IGN
     * @export RequestManager
     */
    var RequestManager = {
    
         init : function (){
            $.ajaxSetup({
               timeout : Config.requestTimeout 
            });
        },
    
        /**
         * Returns the information of the panoramic contained in the given array.
         * @param {String[]} queryResult The resulting string returned by the PHP script splitted in an array.
         * Elements of this array are formatted like this "information_name=information_value". The 2 last
         * elements of this array must contains, first, the number of fields in the SQL request, second, the 
         * number of rows returned by the SQL request.
         * @param {Number} [numPano] The number of wanted panoramic information
         * 
         * @return {Object[]} An array containing literal object which are information on the panoramic.  
        */
        getPanoInfo : function (queryResult, numPano) {

            numPano = numPano || parseInt(queryResult[queryResult.length-1].split("=")[1]);
            var numFields = parseInt(queryResult[queryResult.length-2].split("=")[1]);

            var fieldNames = [];
            for (var i=0;i<numFields;i++) {
                fieldNames.push(queryResult[i].split("=")[0]);
            }

            var info = [];

            for (i=0; i<numPano; i++) {
                var panInfo = {};
                var offset = i*numFields;
                for (var j=0;j < numFields;j++) {
                    var fieldName = fieldNames[j];
                    var val = queryResult[offset+j].split("=")[1];
                    if (fieldName !== "filename" && fieldName.match(/time/) === null && fieldName.match(/addr/) === null){
                         val = parseFloat(val);
                    }
                    panInfo[fieldName] = val;
                }
                
                panInfo.url = Config.server.url+Config.server.iipService+"/"+panInfo.filename+".jp2";
                info.push(panInfo);
            }
            return info;
        },

        sendCommand : function(url,resultHandler, json){
            
            json = json || false;
            
            if (json === true){
                $.getJSON(url, function (data){
                    resultHandler(data);
                })
                .fail(printRequestError);
            }
            else { //keep for compatibility
                var jqxhr = $.get(url, function (data){
                    if (data.length > 0) {
                        var arrayResult = data.trim().split("&");   
                        resultHandler(arrayResult);
                    }
                    else if (DEBUG === true){
                        console.warn("Result of query is empty");
                    }
                });
                jqxhr.fail(printRequestError);
            }
        }
    };
        
    return RequestManager;

});

define('Utils',['RequestManager', 'geoportail'], function (RequestManager) {
    
    /**
     * Tools used by iTOWNS modules
     * @exports Utils
     * @author Mathieu Benard IGN
     */
    
     //--------- Ray casting---------------
     var _tp = [];
         _P = function(x,y){
		this.x = x;
		this.y = y;
		this.flag = false;
         }
         _P.prototype.toString = function(){
		return "Point ["+this.x+", "+this.y+"]";
	 }
	 _P.dist = function(a,b){
		var dx = b.x-a.x;
		var dy = b.y-a.y;
		return Math.sqrt(dx*dx + dy*dy);
	 }
     //--------------------------------------
     var Utils = {
         
         
         snd : null,   // Sound player (for fun)
         snd2: null,  // When mixing another sound
        /**
         * Return the hexadecimal reprensentation of an integer (expressed in base 10)
         */ 
        
        
        toHex : function (number, min) 
        {
          var hexes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
          var hex = '';
          var min = min || 2;
          var nibble;

          do {
              nibble = number & 0x0f;
              number = number >> 4;
              hex = hexes[nibble] + hex;
            } while( number );

            if( hex.length < min ) {
                hex = new Array(min-hex.length+1).join('0') + hex;
            }

            return '0x'+hex;
        },
        
        /**
         * Get the total offset (top, left) of DOM element, including his parents offset
         * 
         * @param {Object} element The DOM element 
         * @return : {Object} Object with properties top and left (calculated offset)
         */
        getOffset : function (element)
        {
            var top = 0, left = 0;
            do {
                top += element.offsetTop;
                left += element.offsetLeft;
            } while (element = element.offsetParent); 

            return { top: top,left: left};
        },
        
        rad2Deg: function(rad)
        {
            return (180*rad/Math.PI)%360;  
        },
        
        deg2Rad: function(deg)
        {
            return (Math.PI*deg/180)%(2*Math.PI);
        },
        
        /**
         * @return {Number} absolute difference between the two given angles wich must be in radian and belong
         * to [0,2Ï[
         */ 
        angleDiff: function(angle1,angle2) {
            var dif = angle1 - angle2;
            
            if (dif < - Math.PI) {
                dif += 2*Math.PI;
            }
            else if (dif > Math.PI){
                dif -= 2*Math.PI;
            }
            
            return Math.abs(dif);  
        },
        
       parseParams : function ()
        {
            var params= {};

            var tmp= window.location.search.substr(1).split("&");  // Adresse ex: http://www.itowns.fr/viewer/laserADVIewer.html?date=2008_05_05&hour=14&seconds=350&easting=655550.2&northing=6866565.3
            for (i=0; i<tmp.length; i++)
            {
                data=tmp[i].split("=");
                params[data[0].toLowerCase()]=data[1];		
            }
              //http://localhost/termob3/?easting=652630.51&northing=6861728.03&mobile=false&nc=false
            params.panoname = params.panoname || "TerMob2-130116_0923-00-00002_0000623";   
            params.easting = params.easting || 651110;
            params.northing = params.northing || 6861835;
            params.heading = params.heading || 0;
            params.duree = params.duree || "25";
            params.particlesize = params.particlesize || "0.01";
            params.mobile = params.mobile =="true" || false;
            params.nc = params.nc =="true" || false;   // nodecontroller to control camera from phone accelerometer
            
         
            if (typeof (params.debug) === "undefined" || params.debug !== "true") {
                params.debug = false;
            }
            else {
                params.debug = true;
            }
             
            //dinhnq : to initialize Opendata Modules
            
           // params.easting = params.easting || "655550.2";
           // params.northing = params.northing || "6866565.3";
           // params.altitude = params.altitude || "0.0";    
            return params;
        },
        
        /**
        * @todo Clean it (global var)
        */ 
        getInitialInfoAndLoad : function (infoArray) {
            
            if (typeof (infoArray) === "undefined") {
                var req = new IT.RequestGIS("php/getInfoFromName.php?panoname=" + params.panoname);
                req.sendCommand(IT.Utils.getInitialInfoAndLoad);
            }
            else {

                var info = {};
                info.easting = infoArray[0].split("=")[1];
                info.northing = infoArray[1].split("=")[1];
                info.altitude = infoArray[2].split("=")[1];
                info.heading = infoArray[3].split("=")[1];
                info.pitch = infoArray[4].split("=")[1];
                info.roll = infoArray[5].split("=")[1];
                
                var time = infoArray[6].split("=")[1].split(":");               
                info.hour = time[0];
                info.second = parseInt(time[1])*60 + parseInt(time[2])
                info.near_address_num = infoArray[7].split("=")[1];
                info.near_address_name = infoArray[8].split("=")[1];
                info.date = infoArray[9].split("=")[1].replace(/-/g,"_").trim();
                
                var currentPanoX = pano.panoInfo.easting;
                var currentPanoY = pano.panoInfo.altitude;
                var currentPanoZ = pano.panoInfo.northing;
                pano.name = params.panoname;
                pano.url = serverInfos.url+serverInfos.iipService+"/"+params.panoname+".jp2";

                pano.panoInfo.easting = info.easting;
                pano.panoInfo.northing = info.northing;
                pano.panoInfo.altitude = info.altitude;
                pano.panoInfo.pan_xml_heading_pp = info.heading;
                pano.panoInfo.pan_xml_pitch_pp =info.pitch;
                pano.panoInfo.pan_xml_roll_pp = info.roll;
                pano.loadUrl(pano.url);
                
                console.log(pano.panoInfo.easting - initialInfo['easting']);
                pano.updateGlobalPano(new THREE.Vector3(pano.panoInfo.easting - initialInfo['easting'],
                                                            pano.panoInfo.altitude - initialInfo['altitude'],
                                                            pano.panoInfo.northing - initialInfo['northing']),
                                          new THREE.Vector3(IT.Utils.deg2Rad(pano.panoInfo.pan_xml_roll_pp),
                                                            IT.Utils.deg2Rad(pano.panoInfo.pan_xml_heading_pp),
                                                            IT.Utils.deg2Rad(pano.panoInfo.pan_xml_pitch_pp)));
                                                            
       
                var translation = {
                    x : pano.panoInfo.easting  - currentPanoX,
                    y : pano.panoInfo.altitude - currentPanoY,
                    z : pano.panoInfo.northing - currentPanoZ
                }
               
                translatX += translation.x;
                translatY += translation.y;
                translatZ += translation.z;

              
                camera.position.x = translatX;
                camera.position.y = translatY;
                camera.position.z = translatZ;
                
                    //translating the current position on the map if it has not been done yet
                 if (map) {
                      map.movePositionOnMap(translation);   
                 }

                IT.Utils.cameraLookAtPosition(intersectionX,intersectionY, intersectionZ,camera.position.x,camera.position.y,camera.position.z);
                //this.cameraLookAtPosition(0,0,this.camera.position.x,this.camera.position.z);
                //IT.Utils.getInitialInfoAndLoad
                
            }  
        },
        
       /**
        * Function that make the cam look at a special 3D (2D) point knowing his future position. 
        * x1,z1 target of intersection , x2 z2 position of cam after translation in center of pano.
        * @todo : Clean it (delete global var uses)
        */
       cameraLookAtPosition: function(x1,y1,z1,x2,y2,z2,headingCorrection){


           var alpha = Math.atan2(x1 - x2, z1 - z2);
           var d = 100000;
           anglecameraLon = alpha;
           var x = -distTarget * Math.sin(anglecameraLon);
           var z = -distTarget * Math.cos(anglecameraLon);
           
           var base = Math.sqrt((x1 - x2)*(x1 - x2) + (z1 - z2)*(z1 - z2));
           var beta = Math.atan2( y1 - y2, base);
           console.log(beta);
           anglecameraLat = - beta;
           var y = - distTarget * Math.sin(beta);

           camrotxwanted = x;
           camrotywanted = y;
           camrotzwanted = z;
       },
       
       outputMatrix4 : function(mat){
           console.debug(mat.elements[0]+" "+mat.elements[4]+" "+mat.elements[8]+" "+mat.elements[12]+"\n"+ 
           mat.elements[1]+" "+mat.elements[5]+" "+mat.elements[9]+" "+mat.elements[13]+"\n"+
           mat.elements[2]+" "+mat.elements[6]+" "+mat.elements[10]+" "+mat.elements[14]+"\n"+
           mat.elements[3]+" "+mat.elements[7]+" "+mat.elements[11]+" "+mat.elements[15]);
        },
        
        inDivArea : function(x,y,divID){
            var divMap = $(divID)[0];
            var isInDiv = false;                
            var divOffset = Utils.getOffset(divMap);

            if (x >= divOffset.left && x <= (divOffset.left + divMap.offsetWidth) && 
                y >= divOffset.top  && y <= (divOffset.top  + divMap.offsetHeight))
            {
                isInDiv = true; 
            }
            return isInDiv;
        },
        
        clamp : function (val, range) {
          if (val < range.min) {
              val = rangemin;
          }
          
          if (val > max){
              val = max;
          }
          
          return val;
        },
        
        clampMin : function (val, min){
          if (val < min) {
              return min;
          }
          else {
              return val;
          }  
        },
        
        clampMax : function (val, max){
          if (val > max) {
              return max;
          }
          else {
              return val;
          }
        },
        
        /**
         * Convert 2D coordinates from screen space ranging from [0..window.innerWidth] in x and [0..window.innerHeight]
         * in y to Normalized Device Coordinates (NDC) ranging from [-1..1] in x and [-1..1] in y
         * @return {Object} Converted point (x,y) 
         */
        toNDC : function (x,y){
            return {
                x : (x / (window.innerWidth)) * 2 - 1,
                y : - (y / (window.innerHeight)) * 2 + 1
            };
        },
        
        /**
         * toNDC inverse function (i.e convert from NDC space to screen space)
         * @return {Object} Converted point (x,y)
         * @see toNDC 
         */
        toScreenSpace : function (x,y) {
            return {
                x : (x + 1)/2 * window.innerWidth,
                y : -(y - 1)/2 * window.innerHeigth
            }; 
        },
        
        notYetImplemented : function () {
            throw new Error("Not yet implented !");
        },
        
        noPanoramic : function () {
            alert("No panoramic found at that position");
        },
        
        
        
       loadTexture: function( path ) {

                var texture = new THREE.Texture( texture_placeholder );
                var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: true } );

                var image = new Image();
                image.onload = function () {

                        texture.needsUpdate = true;
                        material.map.image = this;

                        render();

                };
                image.src = path;

                return material;

        },

        // SAVE Good old THREE matrix functions
        translate: function ( matrix,v ) {
 
            var te = matrix.elements;
            var x = v.x, y = v.y, z = v.z;

            te[12] = te[0] * x + te[4] * y + te[8] * z + te[12];
            te[13] = te[1] * x + te[5] * y + te[9] * z + te[13];
            te[14] = te[2] * x + te[6] * y + te[10] * z + te[14];
            te[15] = te[3] * x + te[7] * y + te[11] * z + te[15];

            return matrix;
           }, 
           
        rotateX: function ( matrix,angle ) {

		var te = matrix.elements;
		var m12 = te[4];
		var m22 = te[5];
		var m32 = te[6];
		var m42 = te[7];
		var m13 = te[8];
		var m23 = te[9];
		var m33 = te[10];
		var m43 = te[11];
		var c = Math.cos( angle );
		var s = Math.sin( angle );

		te[4] = c * m12 + s * m13;
		te[5] = c * m22 + s * m23;
		te[6] = c * m32 + s * m33;
		te[7] = c * m42 + s * m43;

		te[8] = c * m13 - s * m12;
		te[9] = c * m23 - s * m22;
		te[10] = c * m33 - s * m32;
		te[11] = c * m43 - s * m42;

		return matrix;

	},
        
         rotateY: function ( matrix,angle ) {

             var te = matrix.elements;
             var m11 = te[0];
             var m21 = te[1];
             var m31 = te[2];
             var m41 = te[3];
             var m13 = te[8];
             var m23 = te[9];
             var m33 = te[10];
             var m43 = te[11];
             var c = Math.cos( angle );
             var s = Math.sin( angle );

             te[0] = c * m11 - s * m13;
             te[1] = c * m21 - s * m23;
             te[2] = c * m31 - s * m33;
             te[3] = c * m41 - s * m43;

             te[8] = c * m13 + s * m11;
             te[9] = c * m23 + s * m21;
             te[10] = c * m33 + s * m31;
             te[11] = c * m43 + s * m41;

             return matrix;
            }, 
            
          rotateZ: function ( matrix,angle ) {

		var te = matrix.elements;
		var m11 = te[0];
		var m21 = te[1];
		var m31 = te[2];
		var m41 = te[3];
		var m12 = te[4];
		var m22 = te[5];
		var m32 = te[6];
		var m42 = te[7];
		var c = Math.cos( angle );
		var s = Math.sin( angle );

		te[0] = c * m11 + s * m12;
		te[1] = c * m21 + s * m22;
		te[2] = c * m31 + s * m32;
		te[3] = c * m41 + s * m42;

		te[4] = c * m12 - s * m11;
		te[5] = c * m22 - s * m21;
		te[6] = c * m32 - s * m31;
		te[7] = c * m42 - s * m41;

		 return matrix;
	},
            
            rotateByAxis: function ( matrix,axis, angle ) {

		var te = matrix.elements;

		// optimize by checking axis

		if ( axis.x === 1 && axis.y === 0 && axis.z === 0 ) {

			return this.rotateX( matrix,angle );

		} else if ( axis.x === 0 && axis.y === 1 && axis.z === 0 ) {

			return this.rotateY( matrix,angle );

		} else if ( axis.x === 0 && axis.y === 0 && axis.z === 1 ) {

			return this.rotateZ( matrix,angle );

		}

		var x = axis.x, y = axis.y, z = axis.z;
		var n = Math.sqrt(x * x + y * y + z * z);

		x /= n;
		y /= n;
		z /= n;

		var xx = x * x, yy = y * y, zz = z * z;
		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var oneMinusCosine = 1 - c;
		var xy = x * y * oneMinusCosine;
		var xz = x * z * oneMinusCosine;
		var yz = y * z * oneMinusCosine;
		var xs = x * s;
		var ys = y * s;
		var zs = z * s;

		var r11 = xx + (1 - xx) * c;
		var r21 = xy + zs;
		var r31 = xz - ys;
		var r12 = xy - zs;
		var r22 = yy + (1 - yy) * c;
		var r32 = yz + xs;
		var r13 = xz + ys;
		var r23 = yz - xs;
		var r33 = zz + (1 - zz) * c;

		var m11 = te[0], m21 = te[1], m31 = te[2], m41 = te[3];
		var m12 = te[4], m22 = te[5], m32 = te[6], m42 = te[7];
		var m13 = te[8], m23 = te[9], m33 = te[10], m43 = te[11];

		te[0] = r11 * m11 + r21 * m12 + r31 * m13;
		te[1] = r11 * m21 + r21 * m22 + r31 * m23;
		te[2] = r11 * m31 + r21 * m32 + r31 * m33;
		te[3] = r11 * m41 + r21 * m42 + r31 * m43;

		te[4] = r12 * m11 + r22 * m12 + r32 * m13;
		te[5] = r12 * m21 + r22 * m22 + r32 * m23;
		te[6] = r12 * m31 + r22 * m32 + r32 * m33;
		te[7] = r12 * m41 + r22 * m42 + r32 * m43;

		te[8] = r13 * m11 + r23 * m12 + r33 * m13;
		te[9] = r13 * m21 + r23 * m22 + r33 * m23;
		te[10] = r13 * m31 + r23 * m32 + r33 * m33;
		te[11] = r13 * m41 + r23 * m42 + r33 * m43;

		return matrix;

	},
        //dinhnq-- invers matrix, need for opendata module
        /*
         * The inverse of a 2x2 matrix:
            | a11 a12 |-1             |  a22 -a12 |
            | a21 a22 |    =  1/DET * | -a21  a11 |
            with DET  =  a11a22-a12a21
         */
        invMatrix2x2 : function(a,b,c,d)
        {
               //A = [a,b;c,d] => inv(A) = (1/detA)[d,-b;-c,a]
               var ret = new Array(4);
               var detA = 1/(a*d-b*c);
               ret[0] = detA*d; ret[1]  = -detA*b;
               ret[2] = -detA*c; ret[3] = detA*a;
               return ret;
        },
        
        /*
         * The inverse of a 3x3 matrix:
        | a11 a12 a13 |-1             |   a33a22-a32a23  -(a33a12-a32a13)   a23a12-a22a13  |
        | a21 a22 a23 |    =  1/DET * | -(a33a21-a31a23)   a33a11-a31a13  -(a23a11-a21a13) |
        | a31 a32 a33 |               |   a32a21-a31a22  -(a32a11-a31a12)   a22a11-a21a12  |
        with DET  =  a11(a33a22-a32a23)-a21(a33a12-a32a13)+a31(a23a12-a22a13)
        */        
                
        invMatrix3x3 : function(a11,a12,a13,a21,a22,a23,a31,a32,a33){
               detA = 1/(a11(a33*a22 - a32*a23) - a21(a33*a12-a32*a13) + a31*(a23*a12-a22*a13));
               var ret = new Array(9);
               ret[0] = detA*(a33*a22 - a32*a23);
               ret[1] = -detA*(a33*a12 - a32*a13);
               ret[2] = detA*(a23*a12 - a22*a13);
               ret[3] = -detA*(a33*a21 - a31*a23)
               ret[4] = detA*(a33*a11 - a31*a13);
               ret[5] = -detA*(a23*a11 - a21*a13);
               ret[6] = detA*(a32*a21 - a31*a22);
               ret[7] = -detA*(a32*a11 - a31*a12);
               ret[8] = detA*(a22*a11 - a21*a12);
               return ret;
        },
                
        invMatrix4x4: function(matrix, result){
              var result = new Array(16);
              var tmp_0 = matrix[10] * matrix[15];
              var tmp_1 = matrix[14] * matrix[11];
              var tmp_2 = matrix[6] * matrix[15];
              var tmp_3 = matrix[14] * matrix[7];
              var tmp_4 = matrix[6] * matrix[11];
              var tmp_5 = matrix[10] * matrix[7];
              var tmp_6 = matrix[2] * matrix[15];
              var tmp_7 = matrix[14] * matrix[3];
              var tmp_8 = matrix[2] * matrix[11];
              var tmp_9 = matrix[10] * matrix[3];
              var tmp_10 = matrix[2] * matrix[7];
              var tmp_11 = matrix[6] * matrix[3];
              var tmp_12 = matrix[8] * matrix[13];
              var tmp_13 = matrix[12] * matrix[9];
              var tmp_14 = matrix[4] * matrix[13];
              var tmp_15 = matrix[12] * matrix[5];
              var tmp_16 = matrix[4] * matrix[9];
              var tmp_17 = matrix[8] * matrix[5];
              var tmp_18 = matrix[0] * matrix[13];
              var tmp_19 = matrix[12] * matrix[1];
              var tmp_20 = matrix[0] * matrix[9];
              var tmp_21 = matrix[8] * matrix[1];
              var tmp_22 = matrix[0] * matrix[5];
              var tmp_23 = matrix[4] * matrix[1];
  
              var t0 = ((tmp_0 * matrix[5] + tmp_3 * matrix[9] + tmp_4 * matrix[13]) - (tmp_1 * matrix[5] + tmp_2 * matrix[9] + tmp_5 * matrix[13]));
              var t1 = ((tmp_1 * matrix[1] + tmp_6 * matrix[9] + tmp_9 * matrix[13]) - (tmp_0 * matrix[1] + tmp_7 * matrix[9] + tmp_8 * matrix[13]));
              var t2 = ((tmp_2 * matrix[1] + tmp_7 * matrix[5] + tmp_10 * matrix[13]) - (tmp_3 * matrix[1] + tmp_6 * matrix[5] + tmp_11 * matrix[13]));
              var t3 = ((tmp_5 * matrix[1] + tmp_8 * matrix[5] + tmp_11 * matrix[9]) - (tmp_4 * matrix[1] + tmp_9 * matrix[5] + tmp_10 * matrix[9]));
  
              var d1 = (matrix[0] * t0 + matrix[4] * t1 + matrix[8] * t2 + matrix[12] * t3);
              if (Math.abs(d1) < 1e-5) {
                 console.log("Warning can't inverse matrix " + matrix);
                 if (result !== undefined) {
                        return false;
                 } else {
                        result =[1.0, 0.0, 0.0, 0.0,
                                 0.0, 1.0, 0.0, 0.0,
                                 0.0, 0.0, 1.0, 0.0,
                                 0.0, 0.0, 0.0, 1.0];;
                 }
             }
             var d = 1.0 / d1;
  
             var out_00 = d * t0;
             var out_01 = d * t1;
             var out_02 = d * t2;
             var out_03 = d * t3;
  
             var out_10 = d * ((tmp_1 * matrix[4] + tmp_2 * matrix[8] + tmp_5 * matrix[12]) - (tmp_0 * matrix[4] + tmp_3 * matrix[8] + tmp_4 * matrix[12]));
             var out_11 = d * ((tmp_0 * matrix[0] + tmp_7 * matrix[8] + tmp_8 * matrix[12]) - (tmp_1 * matrix[0] + tmp_6 * matrix[8] + tmp_9 * matrix[12]));
             var out_12 = d * ((tmp_3 * matrix[0] + tmp_6 * matrix[4] + tmp_11 * matrix[12]) - (tmp_2 * matrix[0] + tmp_7 * matrix[4] + tmp_10 * matrix[12]));
             var out_13 = d * ((tmp_4 * matrix[0] + tmp_9 * matrix[4] + tmp_10 * matrix[8]) - (tmp_5 * matrix[0] + tmp_8 * matrix[4] + tmp_11 * matrix[8]));
  
             var out_20 = d * ((tmp_12 * matrix[7] + tmp_15 * matrix[11] + tmp_16 * matrix[15]) - (tmp_13 * matrix[7] + tmp_14 * matrix[11] + tmp_17 * matrix[15]));
             var out_21 = d * ((tmp_13 * matrix[3] + tmp_18 * matrix[11] + tmp_21 * matrix[15]) - (tmp_12 * matrix[3] + tmp_19 * matrix[11] + tmp_20 * matrix[15]));
             var out_22 = d * ((tmp_14 * matrix[3] + tmp_19 * matrix[7] + tmp_22 * matrix[15]) - (tmp_15 * matrix[3] + tmp_18 * matrix[7] + tmp_23 * matrix[15]));
             var out_23 = d * ((tmp_17 * matrix[3] + tmp_20 * matrix[7] + tmp_23 * matrix[11]) - (tmp_16 * matrix[3] + tmp_21 * matrix[7] + tmp_22 * matrix[11]));
  
             var out_30 = d * ((tmp_14 * matrix[10] + tmp_17 * matrix[14] + tmp_13 * matrix[6]) - (tmp_16 * matrix[14] + tmp_12 * matrix[6] + tmp_15 * matrix[10]));
             var out_31 = d * ((tmp_20 * matrix[14] + tmp_12 * matrix[2] + tmp_19 * matrix[10]) - (tmp_18 * matrix[10] + tmp_21 * matrix[14] + tmp_13 * matrix[2]));
             var out_32 = d * ((tmp_18 * matrix[6] + tmp_23 * matrix[14] + tmp_15 * matrix[2]) - (tmp_22 * matrix[14] + tmp_14 * matrix[2] + tmp_19 * matrix[6]));
             var out_33 = d * ((tmp_22 * matrix[10] + tmp_16 * matrix[2] + tmp_21 * matrix[6]) - (tmp_20 * matrix[6] + tmp_23 * matrix[10] + tmp_17 * matrix[2]));
  
             result[0] = out_00;
             result[1] = out_01;
             result[2] = out_02;
             result[3] = out_03;
             result[4] = out_10;
             result[5] = out_11;
             result[6] = out_12;
             result[7] = out_13;
             result[8] = out_20;
             result[9] = out_21;
             result[10] = out_22;
             result[11] = out_23;
             result[12] = out_30;
             result[13] = out_31;
             result[14] = out_32;
             result[15] = out_33;
             return result;
       },
               
       //----------Ray Casting------------------
       //modify from http://polyk.ivank.net
       //cast a ray to edge of threejs poly linestring 
        Raycast : function(p, la, x, y, dx, dy, isc)
        {
                    
                    var l = p.length;
                    var a1 = new _P(0,0),  
                        a2 = new _P(0,0), 
                        b1 = new _P(0,0), 
                        b2 = new _P(0,0),
                        c  = new _P(0,0);
                    //ray line    
                    a1.x = x; a1.y = y;
                    a2.x = x+dx; a2.y = y+dy;
		
    		    if(isc==null) isc = {dist: 0, edge:0, line :{x1:0,y1:0,x2:0,y2:0}, 
                                intersectPt : {x:0,y:0},norm:{x:0, y:0}, refl:{x:0, y:0}};
                    isc.dist = Infinity;
                    var j;
	 	    for(var i=0; i<l; i+=2)
		    {
			j = i/2;
                        if(la[j]===la[j+1]){
                            b1.x = p[i  ];  b1.y = p[i+1];
                            b2.x = p[i+2];  b2.y = p[i+3];
                            var nisc = this.RayLineIntersection(a1, a2, b1, b2, c);
                            if(nisc) this.updateISC(dx, dy, a1, b1, b2, c, i/2, isc,nisc);
                        }    
                    }
 	
                    return (isc.dist != Infinity) ? isc : null;
	},
        
        //cast on threejs linestring
        Raycast2 : function(p, v1, v2)
        {
                    
                    var l = p.length;
                    var a1 = new _P(0,0),  
                        a2 = new _P(0,0), 
                        b1 = new _P(0,0), 
                        b2 = new _P(0,0),
                        c  = new _P(0,0);
                    //ray line    
                    a1.x = v1.x; a1.y = v1.z;
                    a2.x = v2.x; a2.y = v2.z;
		
    		    var isc = {dist: 0, edge:0, line :{x1:0,y1:0,x2:0,y2:0}, 
                                intersectPt : {x:0,y:0},norm:{x:0, y:0}, refl:{x:0, y:0}};
                    isc.dist = Infinity;
	 	    for(var i=0; i<l; i+=2)
		    {
                            b1.x = p[i].x;  b1.y = p[i].z;
                            b2.x = p[i+1].x;  b2.y = p[i+1].z;
                            var nisc = this.RayLineIntersection(a1, a2, b1, b2, c);
                            if(nisc) this.updateISC(v2.x, v2.y, a1, b1, b2, c, i/2, isc,nisc);
                    }
 	
                    return (isc.dist != Infinity) ? isc : null;
	},
                
        RayLineIntersection : function(a1, a2, b1, b2, c)
        {
		var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
		var day = (a1.y-a2.y), dby = (b1.y-b2.y);

		var Den = dax*dby - day*dbx;
		if (Den == 0) return null;	// parallel
		
		var A = (a1.x * a2.y - a1.y * a2.x);
		var B = (b1.x * b2.y - b1.y * b2.x);
		
		var I = c;
		var iDen = 1/Den;
		I.x = ( A*dbx - dax*B ) * iDen;
		I.y = ( A*dby - day*B ) * iDen;
		
		if(!this.InRect(I, b1, b2)) return null;
		if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null; 
		if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null; 
		return I;
	},        
                      
        InRect : function(a, b, c)
        {
                    if	(b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
                    if	(b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));
		
                    if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
		    && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y)) 
		    return true;
		 return false;
	 },
         updateISC : function(dx, dy, a1, b1, b2, c, edge, isc,I)
         {
                    var nrl = _P.dist(a1, c);
		    if(nrl<isc.dist)
		    {
			var ibl = 1/_P.dist(b1, b2);
			var nx = -(b2.y-b1.y)*ibl;
			var ny =  (b2.x-b1.x)*ibl;
			var ddot = 2*(dx*nx+dy*ny);
			isc.dist = nrl;
			isc.norm.x = nx;  
			isc.norm.y = ny; 
			isc.refl.x = -ddot*nx+dx;
			isc.refl.y = -ddot*ny+dy;
			isc.edge = edge;
                        isc.line.x1 = b1.x;
                        isc.line.y1 = b1.y;
                        isc.line.x2 = b2.x;
                        isc.line.y2 = b2.y;
                        isc.intersectPt.x = I.x;
                        isc.intersectPt.y = I.y;
	            }
	 },
        
        //project point on closest egde of poly
        //note: p is poly linestring of threejs    
        projectPointOnLine : function(p, pt)
	{
		var l = p.length;
		var a1 = new _P(0,0),
		    b1 = new _P(0,0),
                    b2 = new _P(0,0),
                    c  = new _P(0,0);
		a1.x = pt.x; a1.y = pt.z;
		
		var isc = {dist:Infinity, edge:0,line :{x1:0,y1:0,x2:0,y2:0}, point:{x:0, y:0}, norm:{x:0, y:0}};
		//var j;
		for(var i=0; i<l; i+=2)
		{
                        b1.x = p[i].x;  b1.y   = p[i].z;
        		b2.x = p[i+1].x;  b2.y = p[i+1].z;
	  		this.pointLineDist(a1, b1, b2, i>>1, isc);
		}
		
		var idst = 1/isc.dist;
		isc.norm.x = (pt.x-isc.point.x)*idst;
		isc.norm.y = (pt.z-isc.point.y)*idst;
		return isc;
	},
        pointLineDist : function(p, a, b, edge, isc)
	{
		var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;
		
		var A = x - x1;
		var B = y - y1;
		var C = x2 - x1;
		var D = y2 - y1;

		var dot = A * C + B * D;
		var len_sq = C * C + D * D;
		var param = dot / len_sq;

		var xx, yy;

		if (param < 0 || (x1 == x2 && y1 == y2)) {
			xx = x1;
			yy = y1;
		}
		else if (param > 1) {
			xx = x2;
			yy = y2;
		}
		else {
			xx = x1 + param * C;
			yy = y1 + param * D;
		}

		var dx = x - xx;
		var dy = y - yy;
		var dst = Math.sqrt(dx * dx + dy * dy);
		if(dst<isc.dist)
		{
			isc.dist = dst;
			isc.edge = edge;
			isc.point.x = xx;
			isc.point.y = yy;
                        isc.line.x1 = a.x;
                        isc.line.y1 = a.y;
                        isc.line.x2 = b.x;
                        isc.line.y2 = b.y;
		}
	},
        
        //slice poly into two parts, used this function to delete 
        //artifacts from OpenData line string ray casting!
        slice : function(p, ax, ay, bx, by)
	{
		if(this.ContainsPoint(p, ax, ay) || this.ContainsPoint(p, bx, by)) return [p.slice(0)];

		var a = new _P(ax, ay);
		var b = new _P(bx, by);
		var iscs = [];	// intersections
		var ps = [];	// points
		for(var i=0; i<p.length; i+=2) ps.push(new _P(p[i], p[i+1]));
		
		for(var i=0; i<ps.length; i++)
		{
			var isc = new _P(0,0);
			isc = this._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);
			
			if(isc)
			{
				isc.flag = true;
				iscs.push(isc);
				ps.splice(i+1,0,isc);
				i++;
			}
		}
		if(iscs.length == 0) return [p.slice(0)];
		var comp = function(u,v) {return _P.dist(a,u) - _P.dist(a,v); }
		iscs.sort(comp);
		
		var pgs = [];
		var dir = 0;
		while(iscs.length > 0)
		{
			var n = ps.length;
			var i0 = iscs[0];
			var i1 = iscs[1];
			var ind0 = ps.indexOf(i0);
			var ind1 = ps.indexOf(i1);
			var solved = false;
			
			if(this._firstWithFlag(ps, ind0) == ind1) solved = true;
			else
			{
				i0 = iscs[1];
				i1 = iscs[0];
				ind0 = ps.indexOf(i0);
				ind1 = ps.indexOf(i1);
				if(this._firstWithFlag(ps, ind0) == ind1) solved = true;
			}
			if(solved)
			{
				dir--;
				var pgn = this._getPoints(ps, ind0, ind1);
				pgs.push(pgn);
				ps = this._getPoints(ps, ind1, ind0);
				i0.flag = i1.flag = false;
				iscs.splice(0,2);
				if(iscs.length == 0) pgs.push(ps);
			}
			else { dir++; iscs.reverse(); }
			if(dir>1) break;
		}
		var result = [];
		for(var i=0; i<pgs.length; i++)
		{
			var pg = pgs[i];
			var npg = [];
			for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
			result.push(npg);
		}
		return result;
	},
        
        /*TODO: use this function to check if line string points are inside poly which
         *created from Bati 3D d'OpenData. The idea is that we do ray casting with Bati 3D
         * to detect front of building (facades), a poly is created from these facades. Finally, we
         * check if the lines are inside the poly which permet to hide invisible lines from scene*/            
        containsPoint : function(p, px, py)
	{
		var n = p.length>>1;
		var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
		var depth = 0;
		for(var i=0; i<n; i++)
		{
			ax = bx;  ay = by;
			bx = p[2*i  ] - px;
			by = p[2*i+1] - py;
			if(ay< 0 && by< 0) continue;	// both "up" or both "donw"
			if(ay>=0 && by>=0) continue;	// both "up" or both "donw"
			if(ax< 0 && bx< 0) continue; 
			
			var lx = ax + (bx-ax)*(-ay)/(by-ay);
			if(lx>0) depth++;
		}
		return (depth & 1) == 1;
	},
        
        //px, py sont coords d'emprise du sol        
        extractLineStringInsidePoly : function(px,py,l) {
             var lines = [];
             if(px.length !==py.length){
                     console.warn("poly bounding box have wrong structure!!!");
                     return false;
             }else{
                 var p = [];
                 for(var i = 0; i < px.length; i++) {p.push(px[i]);p.push(py[i])} 
                 for(var i = 0; i < l.length-4; i+=4){
                     if(this.containsPoint(p,l[i],l[i+1])&&this.containsPoint(p,l[i+2],l[i+3])){
                         lines.push(l[i]); lines.push(l[i+1]);
                         lines.push(l[i+2]); lines.push(l[i+3]);
                     }
                 }
                 
             }
             return lines;
        },         
                
        convex : function(ax, ay, bx, by, cx, cy){
		return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;
	},        
        
        polyIsConvex : function(p){
		if(p.length<6) return true;
		var l = p.length - 4;
		for(var i=0; i<l; i+=2)
			if(!this.convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
		if(!this.convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
		if(!this.convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
		return true;
	},
        
        getLineIntersection : function(a1, a2, b1, b2, c){
		var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
		var day = (a1.y-a2.y), dby = (b1.y-b2.y);

		var Den = dax*dby - day*dbx;
		if (Den == 0) return null;	// parallel
		
		var A = (a1.x * a2.y - a1.y * a2.x);
		var B = (b1.x * b2.y - b1.y * b2.x);
		
		var I = c;
		I.x = ( A*dbx - dax*B ) / Den;
		I.y = ( A*dby - day*B ) / Den;
		
		if(this.InRect(I, a1, a2) && this.InRect(I, b1, b2)) return I;
		return null;
	},
        getAreaPoly : function(p){
		if(p.length <6) return 0;
		var l = p.length - 2;
		var sum = 0;
		for(var i=0; i<l; i+=2)
			sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);
		sum += (p[0]-p[l]) * (p[l+1]+p[1]);
		return - sum * 0.5;
	},
        removDuplicateArray : function(arr){
            var temp = {};
            for (var i = 0; i < arr.length; i++)
            temp[arr[i]] = true;
            var r = [];
                for (var k in temp)
                r.push(k);
                return r;
        },
        
        checkSign: function(a,b){
            return (( a * b) >= 0);
        },
                
        //this function returns commun point if two lines are intersected.
        //it is different from Raycast* function where the point is located 
        //from two vectors. 
        getLineIntersection2 : function(p1,p2,p3,p4){
            var x1 = p1.x, y1 = p1.y, x2 = p2.x,  y2 = p2.y,
                x3 = p3.x, y3 = p3.y, x4 = p4.x,  y4 = p4.y;    
            
            var a1, a2, b1, b2, c1, c2;
            var r1, r2 , r3, r4;
            var denom, offset, num;

            // Compute a1, b1, c1, where line joining points 1 and 2
            // is "a1 x + b1 y + c1 = 0".
            a1 = y2 - y1;
            b1 = x1 - x2;
            c1 = (x2 * y1) - (x1 * y2);

            // Compute r3 and r4.
            r3 = ((a1 * x3) + (b1 * y3) + c1);
            r4 = ((a1 * x4) + (b1 * y4) + c1);

            // Check signs of r3 and r4. If both point 3 and point 4 lie on
            // same side of line 1, the line segments do not intersect.
            if ((r3 != 0) && (r4 != 0) && this.checkSign(r3, r4)){
                    return -1;
            }

            // Compute a2, b2, c2
            a2 = y4 - y3;
            b2 = x3 - x4;
            c2 = (x4 * y3) - (x3 * y4);

           // Compute r1 and r2
            r1 = (a2 * x1) + (b2 * y1) + c2;
            r2 = (a2 * x2) + (b2 * y2) + c2;

           // Check signs of r1 and r2. If both point 1 and point 2 lie
           // on same side of second line segment, the line segments do
           // not intersect.
            if ((r1 != 0) && (r2 != 0) && (this.checkSign(r1, r2))){
                return -1;
            }

            //Line segments intersect: compute intersection point.
            denom = (a1 * b2) - (a2 * b1);

            if (denom == 0) {
               return -1;
            }

            if (denom < 0){ 
               offset = -denom / 2; 
            } 
            else {
               offset = denom / 2 ;
            }

            // The denom/2 is to get rounding instead of truncating. It
            // is added or subtracted to the numerator, depending upon the
            // sign of the numerator.
            var point = {x :0, y :0, dist : 0};
            num = (b1 * c2) - (b2 * c1);
            if (num < 0){
                point.x = (num - offset) / denom;
            }else {
                point.x = (num + offset) / denom;
            }

            num = (a2 * c1) - (a1 * c2);
            if (num < 0){
                point.y = ( num - offset) / denom;
            }else {
                point.y = (num + offset) / denom;
            }
            point.dist =  Math.sqrt((point.x - p1.x)*(point.x - p1.x) + (point.y - p1.y)*(point.y - p1.y)); 
            // lines_intersect
            return point;
        },
                  
        getIntersectLinePoly : function(p, pt1, pt2)
        {
                    
              var l = p.length;
              var a1 = new _P(0,0),  
                  a2 = new _P(0,0), 
                  b1 = new _P(0,0), 
                  b2 = new _P(0,0),
                  I  = new _P(0,0);
                  //ray line    
                  a1.x = pt1.x; a1.y = pt1.z;
                  a2.x = pt2.x; a2.y = pt2.z;
              var min_dist = Infinity;    
 	      for(var i=0; i<l; i+=2){
                      b1.x = p[i].x;  b1.y = p[i].z;
                      b2.x = p[i+1].x;  b2.y = p[i+1].z;
                      var isc = this.getLineIntersection2(a1, a2, b1, b2);
                      if(isc !== -1){ //check if intersect
                             //console.warn(nrl);
                             if(isc.dist < min_dist){
                                  I.x = isc.x;
                                  I.y = isc.y;
                             }
                             min_dist = isc.dist;
                      }
              }
 	
              return I;
	},        
        
        lambert93ToWGS : function (lambertCoords){
            var wgsLonLat = new OpenLayers.LonLat(lambertCoords.x, lambertCoords.y);
            wgsLonLat.transform(new OpenLayers.Projection("EPSG:2154"), new OpenLayers.Projection("CRS:84"));
            return wgsLonLat;
        },
        
        wgsToLambert93 : function (wgsCoords){
            var lambertCoords = new OpenLayers.LonLat(wgsCoords.lon, wgsCoords.lat);
            lambertCoords.transform(new OpenLayers.Projection("CRS:84"), new OpenLayers.Projection("EPSG:2154"));
            return {x : lambertCoords.lon, y : lambertCoords.lat};
        },
        
        
        // http://fr.wikipedia.org/wiki/MÃÂ©thode_de_Cardan  Thanks Bredif
        cardan_cubic_roots: function(a,b,c,d){
            
            if(a==0) return this.quadratic_roots(b,c,d);
            var vt=-b/(3*a);
            var a2 = a*a;
            var b2 = b*b;
            var a3 = a*a2;
            var b3 = b*b2;
            var p=c/a-b2/(3*a2);
            var q=b3/(a3*13.5)+d/a-b*c/(3*a2);
            if(p==0)
            {
                    var x = this.cubic_root(-q)+vt;
                    return [x,x,x];
            }
            var p3_4_27=p*p*p*4/27;
            var del=q*q+p3_4_27;

            if(del > 0)
            {
                    var sqrt_del=Math.sqrt(del);
                    var u=this.cubic_root((-q+sqrt_del)/2);
                    var v=this.cubic_root((-q-sqrt_del)/2);
                    return [u+v+vt];
            }
            else if (del==0)
            {
                    var z0 =3*q/p;
                    var x0 = vt + z0;
                    var x12= vt - z0*0.5;
                    return [x0,x12,x12];
            }
            else // (del < 0)
            {
                    var kos=Math.acos(-q/Math.sqrt(p3_4_27));
                    var r=2*Math.sqrt(-p/3)
                    return [
                            r*Math.cos((kos          )/3)+vt,
                            r*Math.cos((kos+  Math.PI)/3)+vt,
                            r*Math.cos((kos+2*Math.PI)/3)+vt
                    ];
            }
    },

    quadratic_roots: function(a,b,c){
            var delta = b*b-4*a*c;
            if(delta<0) return [];
            var x0 = -b/(2*a);
            if(delta==0) return [x0];
            var sqr_delta_2a = Math.sqrt(delta)/(2*a);
            return [x0-sqr_delta_2a,x0+sqr_delta_2a];
    },

    sgn: function(x) {
        return (x>0) - (x< 0); 
    },

    cubic_root: function(x) {
        return this.sgn(x)*Math.pow(Math.abs(x),1/3); 
    },
 
     
    // Return sun position with azimuth and altitude in rad       
    getSunPosition:function() {

        var m = Math,
          PI = m.PI,
          sin = m.sin,
          cos = m.cos,
          tan = m.tan,
          asin = m.asin,
          atan = m.atan2;

        var rad = PI/180,
          dayMs = 1000*60*60*24,
          J1970 = 2440588,
          J2000 = 2451545,
          e = rad*23.4397; // obliquity of the Earth

        function toJulian(date) {
          return date.valueOf()/dayMs - 0.5+J1970;
        }
        function toDays(date) {
          return toJulian(date)-J2000;
        }
        function getRightAscension(l, b) {
          return atan(sin(l)*cos(e) - tan(b)*sin(e), cos(l));
        }
        function getDeclination(l, b) {
          return asin(sin(b)*cos(e) + cos(b)*sin(e)*sin(l));
        }
        function getAzimuth(H, phi, dec) {
          return atan(sin(H), cos(H)*sin(phi) - tan(dec)*cos(phi));
        }
        function getAltitude(H, phi, dec) {
          return asin(sin(phi)*sin(dec) + cos(phi)*cos(dec)*cos(H));
        }
        function getSiderealTime(d, lw) {
          return rad * (280.16 + 360.9856235*d) - lw;
        }
        function getSolarMeanAnomaly(d) {
          return rad * (357.5291 + 0.98560028*d);
        }
        function getEquationOfCenter(M) {
          return rad * (1.9148*sin(M) + 0.0200 * sin(2*M) + 0.0003 * sin(3*M));
        }
        function getEclipticLongitude(M, C) {
          var P = rad*102.9372; // perihelion of the Earth
          return M+C+P+PI;
        }

        return function getSunPosition(date, lat, lon) {
          var lw = rad*-lon,
            phi = rad*lat,
            d = toDays(date),
            M = getSolarMeanAnomaly(d),
            C = getEquationOfCenter(M),
            L = getEclipticLongitude(M, C),
            D = getDeclination(L, 0),
            A = getRightAscension(L, 0),
            t = getSiderealTime(d, lw),
            H = t-A;
          
          return {
            altitude: getAltitude(H, phi, D),
            azimuth: getAzimuth(H, phi, D)+ PI// - PI/2 // origin: north !!! not like original Mourner code but more classical ref
          };
    };
    

  },
  
      // Return scene coordinate ({x,y,z}) of sun
      getSunPositionInScene: function(date,lat,lon){
          
            if(lat == undefined){
                var currentPosWGS84 = require("Cartography").convertCoordVec3(require("Cartography").getCurrentPosition(),"EPSG:2154", "CRS:84"); 
                lat = currentPosWGS84.z;
                lon = currentPosWGS84.x;
            }
            var sun = Utils.getSunPosition()(date,lat,lon);
            var length = 2000 ; // distance of the sun from the earth
            var direction={x:0,y:0};
            direction.x = Math.sin(sun.azimuth) * length;
            direction.y = Math.cos(sun.azimuth) * length;
            var realalti = Math.sin(sun.altitude) * length;

            //console.log(direction, realalti);

            return {x:direction.x,y:realalti, z:direction.y};
      }

        
        
    };
      
    return Utils;
});
      
        
       

/**
 * @author alteredq / http://alteredqualia.com/
 * 
 * @Tuned A.D IGN   
 *   Careful RGBA format for target !!!
 */
define('lib/postprocessing/EffectComposer',['lib/three'],function(THREE){
THREE.EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var width = window.innerWidth || 1;
		var height = window.innerHeight  || 1;
		var parameters = { minFilter: THREE.LinearMipMapLinear, magFilter: THREE.LinearMipMapLinear, format: THREE.RGBAFormat, stencilBuffer: false, antialias: true};

		renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

	this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

};

THREE.EffectComposer.prototype = {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;
	},

	addPass: function ( pass ) {

		this.passes.push( pass );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},
        
        // ITOWNS ADDED
        removePass: function(index){
            
            index = index || this.passes.length -1;
            this.passes.splice( index, 1);
        },

	render: function ( delta ) {

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( !pass.enabled ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( pass instanceof THREE.MaskPass ) {

				maskActive = true;

			} else if ( pass instanceof THREE.ClearMaskPass ) {

				maskActive = false;

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			renderTarget = this.renderTarget1.clone();

			renderTarget.width = window.innerWidth;
			renderTarget.height = window.innerHeight;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		var renderTarget = this.renderTarget1.clone();

		renderTarget.width = width;
		renderTarget.height = height;

		this.reset( renderTarget );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MaskPass = function ( scene, camera ) {

	this.scene = scene;
	this.camera = camera;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

THREE.MaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		// don't update color or depth

		context.colorMask( false, false, false, false );
		context.depthMask( false );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		context.enable( context.STENCIL_TEST );
		context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
		context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
		context.clearStencil( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// re-enable update of color and depth

		context.colorMask( true, true, true, true );
		context.depthMask( true );

		// only render where stencil is set to 1

		context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

	}

};


THREE.ClearMaskPass = function () {

	this.enabled = true;

};

THREE.ClearMaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		context.disable( context.STENCIL_TEST );

	}

};



/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

THREE.CopyShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join("\n")

};


/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function ( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	this.renderToScreen = false;

	this.enabled = true;
	this.needsSwap = true;
	this.clear = false;

};

THREE.ShaderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer;

		}

		THREE.EffectComposer.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );

		} else {

			renderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, this.clear );

		}

	}

};


/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Screen-space ambient occlusion shader
 * - ported from
 *   SSAO GLSL shader v1.2
 *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)
 *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)
 * - modifications
 * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)
 * - made fog more compatible with three.js linear fog
 * - refactoring and optimizations
 */

THREE.SSAOShader = {

	uniforms: {

		"tDiffuse":     { type: "t", value: null },
		"tDepth":       { type: "t", value: null },
		"size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
		"cameraNear":   { type: "f", value: 1 },
		"cameraFar":    { type: "f", value: 100 },
		"fogNear":      { type: "f", value: 5 },
		"fogFar":       { type: "f", value: 100 },
		"fogEnabled":   { type: "i", value: 0 },
		"onlyAO":       { type: "i", value: 0 },
		"aoClamp":      { type: "f", value: 0.3 },
		"lumInfluence": { type: "f", value: 0.9 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float cameraNear;",
		"uniform float cameraFar;",

		"uniform float fogNear;",
		"uniform float fogFar;",

		"uniform bool fogEnabled;",  // attenuate AO with linear fog
		"uniform bool onlyAO;",      // use only ambient occlusion pass?

		"uniform vec2 size;",        // texture width, height
		"uniform float aoClamp;",    // depth clamp - reduces haloing at screen edges

		"uniform float lumInfluence;",  // how much luminance affects occlusion

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDepth;",

		"varying vec2 vUv;",

		// "#define PI 3.14159265",
		"#define DL 2.399963229728653",  // PI * ( 3.0 - sqrt( 5.0 ) )
		"#define EULER 2.718281828459045",

		// helpers

		"float width = size.x;",   // texture width
		"float height = size.y;",  // texture height

		"float cameraFarPlusNear = cameraFar + cameraNear;",
		"float cameraFarMinusNear = cameraFar - cameraNear;",
		"float cameraCoef = 2.0 * cameraNear;",

		// user variables

		"const int samples = 8;",     // ao sample count
		"const float radius = 5.0;",  // ao radius

		"const bool useNoise = false;",      // use noise instead of pattern for sample dithering
		"const float noiseAmount = 0.0003;", // dithering amount

		"const float diffArea = 0.4;",   // self-shadowing reduction
		"const float gDisplace = 0.4;",  // gauss bell center

		"const vec3 onlyAOColor = vec3( 1.0, 0.7, 0.5 );",
		// "const vec3 onlyAOColor = vec3( 1.0, 1.0, 1.0 );",


		// RGBA depth

		"float unpackDepth( const in vec4 rgba_depth ) {",

			"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"float depth = dot( rgba_depth, bit_shift );",
			"return depth;",

		"}",

		// generating noise / pattern texture for dithering

		"vec2 rand( const vec2 coord ) {",

			"vec2 noise;",

			"if ( useNoise ) {",

				"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
				"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",

				"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",

			"} else {",

				"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );",
				"float gg = fract( coord.t * ( height / 2.0 ) );",

				"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",

			"}",

			"return ( noise * 2.0  - 1.0 ) * noiseAmount;",

		"}",

		"float doFog() {",

			"float zdepth = unpackDepth( texture2D( tDepth, vUv ) );",
			"float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );",

			"return smoothstep( fogNear, fogFar, depth );",

		"}",

		"float readDepth( const in vec2 coord ) {",

			// "return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );",
			"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );",


		"}",

		"float compareDepths( const in float depth1, const in float depth2, inout int far ) {",

			"float garea = 2.0;",                         // gauss bell width
			"float diff = ( depth1 - depth2 ) * 100.0;",  // depth difference (0-100)

			// reduce left bell width to avoid self-shadowing

			"if ( diff < gDisplace ) {",

				"garea = diffArea;",

			"} else {",

				"far = 1;",

			"}",

			"float dd = diff - gDisplace;",
			"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );",
			"return gauss;",

		"}",

		"float calcAO( float depth, float dw, float dh ) {",

			"float dd = radius - depth * radius;",
			"vec2 vv = vec2( dw, dh );",

			"vec2 coord1 = vUv + dd * vv;",
			"vec2 coord2 = vUv - dd * vv;",

			"float temp1 = 0.0;",
			"float temp2 = 0.0;",

			"int far = 0;",
			"temp1 = compareDepths( depth, readDepth( coord1 ), far );",

			// DEPTH EXTRAPOLATION

			"if ( far > 0 ) {",

				"temp2 = compareDepths( readDepth( coord2 ), depth, far );",
				"temp1 += ( 1.0 - temp1 ) * temp2;",

			"}",

			"return temp1;",

		"}",

		"void main() {",

			"vec2 noise = rand( vUv );",
			"float depth = readDepth( vUv );",

			"float tt = clamp( depth, aoClamp, 1.0 );",

			"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );",
			"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );",

			"float pw;",
			"float ph;",

			"float ao;",

			"float dz = 1.0 / float( samples );",
			"float z = 1.0 - dz / 2.0;",
			"float l = 0.0;",

			"for ( int i = 0; i <= samples; i ++ ) {",

				"float r = sqrt( 1.0 - z );",

				"pw = cos( l ) * r;",
				"ph = sin( l ) * r;",
				"ao += calcAO( depth, pw * w, ph * h );",
				"z = z - dz;",
				"l = l + DL;",

			"}",

			"ao /= float( samples );",
			"ao = 1.0 - ao;",

			"if ( fogEnabled ) {",

				"ao = mix( ao, 1.0, doFog() );",

			"}",

			"vec3 color = texture2D( tDiffuse, vUv ).rgb;",

			"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );",
			"float lum = dot( color.rgb, lumcoeff );",
			"vec3 luminance = vec3( lum );",

			"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // mix( color * ao, white, luminance )

			"if ( onlyAO ) {",

				"final = onlyAOColor * vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // ambient occlusion only

			"}",

			"gl_FragColor = vec4( final, 1.0 );",

		"}"

	].join("\n")

};


/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

};

THREE.RenderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		this.scene.overrideMaterial = this.overrideMaterial;

		if ( this.clearColor ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.render( this.scene, this.camera, readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

		}

		this.scene.overrideMaterial = null;

	}

};

THREE.CloudShader = function(){
    
    var _materialCloud = new THREE.ShaderMaterial( {
        
            uniforms: {

                        "map": { type: "t", value:  THREE.ImageUtils.loadTexture( 'images/cloud10.png')  },
                        "fogColor":    { type: "v3", value: new THREE.Vector3( 0.27,0.5,0.70 ) },
                        "fogNear":   { type: "f", value: -100 },
                        "fogFar":    { type: "f", value: 3000 }

                },

            vertexShader: [

                        "varying vec2 vUv;",

                        "void main() {",

                                "vUv = uv;",
                                "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

                        "}"

                ].join("\n"),

                fragmentShader: [
                                "uniform sampler2D map;",

                                "uniform vec3 fogColor;",
                                "uniform float fogNear;",
                                "uniform float fogFar;",

                                "varying vec2 vUv;",

                                "void main() {",

              
                                         "float depth = gl_FragCoord.z / gl_FragCoord.w;",
                                        "float fogFactor = smoothstep( fogNear, fogFar, depth );",

                                        "gl_FragColor = texture2D( map, vUv );",
                                        "gl_FragColor.w *= pow( gl_FragCoord.z, 20.0 );",
                                        "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
                                      

                        "}"

                ].join("\n")
                
             });
        
        
            this.showClouds = function(){
            
                console.log("showClouds");
                var geometry = new THREE.Geometry();

                var texture = THREE.ImageUtils.loadTexture( 'images/cloud10.png', null);//, animate );
                texture.magFilter = THREE.LinearMipMapLinearFilter;
                texture.minFilter = THREE.LinearMipMapLinearFilter;

                //var fog = new THREE.Fog( 0x4584b4, - 100, 3000 );
                
                var plane = new THREE.Mesh( new THREE.PlaneGeometry( 64, 64 ) );

                for ( var i = 0; i < 8000; i++ ) {

                        plane.position.x = Math.random() * 1000 - 500;
                        plane.position.y =  Math.random() * Math.random() * 200 + 15;
                        plane.position.z = Math.random() * 1000 - 500;//i;//Math.random() *10 - i/800;
                        plane.rotation.z = Math.random() * Math.PI;
                        //plane.rotation.y = Math.random() * Math.PI;
                        //plane.rotation.x = Math.random() * Math.PI;
                        plane.scale.x = plane.scale.y = Math.random() * Math.random() * 1.5 + 0.5;

                        THREE.GeometryUtils.merge( geometry, plane );

                }
                
                _materialCloud.depthWrite= false,
                     _materialCloud.depthTest= false,
                     _materialCloud.transparent=true;
                    _materialCloud.side = THREE.DoubleSide;
                    
                    
                var mesh = new THREE.Mesh( geometry, _materialCloud );

             //   scene.add( mesh );

          //      mesh = new THREE.Mesh( geometry, _materialCloud );
           //     mesh.position.z = - 8000;
             //   scene.add( mesh );
             
             
                return mesh;
            };
        
   };

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Dot screen shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

THREE.DotScreenShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"tSize":    { type: "v2", value: new THREE.Vector2( 256, 256 ) },
		"center":   { type: "v2", value: new THREE.Vector2( 0.5, 0.5 ) },
		"angle":    { type: "f", value: 1.57 },
		"scale":    { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform vec2 center;",
		"uniform float angle;",
		"uniform float scale;",
		"uniform vec2 tSize;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",
                

		"float pattern() {",

			"float s = sin( angle ), c = cos( angle );",

			"vec2 tex = vUv * tSize - center;",
			"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;",

			"return ( sin( point.x ) * sin( point.y ) ) * 4.0;",

		"}",

		"void main() {",

			"vec4 color = texture2D( tDiffuse, vUv );",

			"float average = ( color.r + color.g + color.b ) / 3.0;",

			"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );",

		"}"

	].join("\n")
};


/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

THREE.RGBShiftShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"amount":   { type: "f", value: 0.005 },
		"angle":    { type: "f", value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float amount;",
		"uniform float angle;",

		"varying vec2 vUv;",

		"void main() {",

			"vec2 offset = amount * vec2( cos(angle), sin(angle));",
			"vec4 cr = texture2D(tDiffuse, vUv + offset);",
			"vec4 cga = texture2D(tDiffuse, vUv);",
			"vec4 cb = texture2D(tDiffuse, vUv - offset);",
			"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",

		"}"

	].join("\n")
};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]
 * - based on Nvidia example
 * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass
 */

THREE.BleachBypassShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 base = texture2D( tDiffuse, vUv );",

			"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );",
			"float lum = dot( lumCoeff, base.rgb );",
			"vec3 blend = vec3( lum );",

			"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );",

			"vec3 result1 = 2.0 * base.rgb * blend;",
			"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );",

			"vec3 newColor = mix( result1, result2, L );",

			"float A2 = opacity * base.a;",
			"vec3 mixRGB = A2 * newColor.rgb;",
			"mixRGB += ( ( 1.0 - A2 ) * base.rgb );",

			"gl_FragColor = vec4( mixRGB, base.a );",

		"}"

	].join("\n")

};


/**  (ALEX added brightness & contrast)
 * @author tapio / http://tapio.github.com/
 *
 * Hue and saturation adjustment
 * https://github.com/evanw/glfx.js
 * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.
 * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

THREE.HueSaturationShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"hue":        { type: "f", value: 0 },
		"saturation": { type: "f", value: 0. },
                "brightness": { type: "f", value: 1. },
                "contrast": { type: "f", value: 1. }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float hue;",
		"uniform float saturation;",
                "uniform float brightness;",
                "uniform float contrast;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",

			// hue
			"float angle = hue * 3.14159265;",
			"float s = sin(angle), c = cos(angle);",
			"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
			"float len = length(gl_FragColor.rgb);",
			"gl_FragColor.rgb = vec3(",
				"dot(gl_FragColor.rgb, weights.xyz),",
				"dot(gl_FragColor.rgb, weights.zxy),",
				"dot(gl_FragColor.rgb, weights.yzx)",
			");",

			// saturation
			"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
			"if (saturation > 0.0) {",
				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
			"} else {",
				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
			"}",
                        
                        // Constrast
                        "gl_FragColor.rgb = ((gl_FragColor.rgb - 0.5) * max(contrast, 0.)) + 0.5;",
                        
                        // Brightness
                        "gl_FragColor.rgb *= brightness;",

		"}"

	].join("\n")

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Focus shader
 * based on PaintEffect postprocess from ro.me
 * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

THREE.FocusShader = {

	uniforms : {

		"tDiffuse":       { type: "t", value: null },
		"screenWidth":    { type: "f", value: 1024 },
		"screenHeight":   { type: "f", value: 1024 },
		"sampleDistance": { type: "f", value: 0.94 },
		"waveFactor":     { type: "f", value: 0.00125 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float screenWidth;",
		"uniform float screenHeight;",
		"uniform float sampleDistance;",
		"uniform float waveFactor;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 color, org, tmp, add;",
			"float sample_dist, f;",
			"vec2 vin;",
			"vec2 uv = vUv;",

			"add = color = org = texture2D( tDiffuse, uv );",

			"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );",
			"sample_dist = dot( vin, vin ) * 2.0;",

			"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;",

			"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );",
			"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );",

			"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );",

		"}"


	].join("\n")
};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

THREE.BokehShader = {

	uniforms: {

		"tColor":   { type: "t", value: null },
		"tDepth":   { type: "t", value: null },
		"focus":    { type: "f", value: 1.0 },
		"aspect":   { type: "f", value: 1.0 },
		"aperture": { type: "f", value: 0.0025 },
		"maxblur":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"varying vec2 vUv;",

		"uniform sampler2D tColor;",
		"uniform sampler2D tDepth;",

		"uniform float maxblur;",  // max blur amount
		"uniform float aperture;", // aperture - bigger values for shallower depth of field

		"uniform float focus;",
		"uniform float aspect;",

		"void main() {",

			"vec2 aspectcorrect = vec2( 1.0, aspect );",

			"vec4 depth1 = texture2D( tDepth, vUv );",

			"float factor = depth1.x - focus;",

			"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );",

			"vec2 dofblur9 = dofblur * 0.9;",
			"vec2 dofblur7 = dofblur * 0.7;",
			"vec2 dofblur4 = dofblur * 0.4;",

			"vec4 col = vec4( 0.0 );",

			"col += texture2D( tColor, vUv.xy );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );",

			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",

			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );",

			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );",

			"gl_FragColor = col / 41.0;",
			"gl_FragColor.a = 1.0;",

		"}"

	].join("\n")

};

THREE.blurTriangleXDepth = {
    
                    info: {
                        name: 'triangle blur (pass 1)',
                        author: 'Evan Wallace',
                        link: 'https://github.com/evanw/glfx.js'
                    },

                    uniforms: { tDepth: { type: "t", value: 0, texture: null },
                                radius: { type: "f", value: 0.0 },
                                resolutionW: { type: "f", value: 1920 }
                              },

                    controls: {
                                    radius: {min:0, max: 200, step:.05}
                              },

                   vertexShader: [

                            "varying vec2 vUv;",

                            "void main() {",

                                    "vUv = uv;",
                                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

                            "}"

                    ].join("\n"),

                    fragmentShader: [
                        
                        "varying vec2 vUv;",
                        
                        "uniform sampler2D tDepth;",
                        "uniform float radius;",
                        "uniform float resolutionW;",
                        
                        "float random(vec3 scale, float seed) {",
                            "/* use the fragment position for a different seed per-pixel */",
                            "return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);",
                        "}",

                        "void main() {",
                            "vec4 color = vec4(0.0);",
                            "float total = 0.0;",
                            "vec2 delta = vec2(radius / resolutionW, 0);",

                            "/* randomize the lookup values to hide the fixed number of samples */",
                            "float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);",

                            "for (float t = -30.0; t <= 30.0; t++) {",
                                "float percent = (t + offset - 0.5) / 30.0;",
                                "float weight = 1.0 - abs(percent);",
                                "color += texture2D(tDepth, vUv + delta * percent) * weight;",
                                "total += weight;",
                            "}",
                            "gl_FragColor = color / total;",
                        "}",

                    ].join("\n")
                
                };


THREE.blurTriangleX = {
    
                    info: {
                        name: 'triangle blur (pass 1)',
                        author: 'Evan Wallace',
                        link: 'https://github.com/evanw/glfx.js'
                    },

                    uniforms: { tDiffuse: { type: "t", value: 0, texture: null },
                                radius: { type: "f", value: 0.0 },
                                resolutionW: { type: "f", value: 1920 }
                              },

                    controls: {
                                    radius: {min:0, max: 200, step:.05}
                              },

                   vertexShader: [

                            "varying vec2 vUv;",

                            "void main() {",

                                    "vUv = uv;",
                                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

                            "}"

                    ].join("\n"),

                    fragmentShader: [
                        
                        "varying vec2 vUv;",
                        
                        "uniform sampler2D tDiffuse;",
                        "uniform float radius;",
                        "uniform float resolutionW;",
                        
                        "float random(vec3 scale, float seed) {",
                            "/* use the fragment position for a different seed per-pixel */",
                            "return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);",
                        "}",

                        "void main() {",
                            "vec4 color = vec4(0.0);",
                            "float total = 0.0;",
                            "vec2 delta = vec2(radius / resolutionW, 0);",

                            "/* randomize the lookup values to hide the fixed number of samples */",
                            "float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);",

                            "for (float t = -30.0; t <= 30.0; t++) {",
                                "float percent = (t + offset - 0.5) / 30.0;",
                                "float weight = 1.0 - abs(percent);",
                                "color += texture2D(tDiffuse, vUv + delta * percent) * weight;",
                                "total += weight;",
                            "}",
                            "gl_FragColor = color / total;",
                        "}",

                    ].join("\n")
                
                };


THREE.blurTriangleY = {
    
                    info: {
                        name: 'triangle blur (pass 2)',
                        author: 'Evan Wallace',
                        link: 'https://github.com/evanw/glfx.js'
                    },

                    uniforms: {     tDiffuse: { type: "t", value: 0, texture: null },
                                    radius: { type: "f", value: 0.0 },
                                    resolutionH: { type: "f", value: 1080 }
                              },

                    controls: {
                                    radius: {min:0, max: 200, step:.05}
                              },

                    vertexShader: [

                            "varying vec2 vUv;",

                            "void main() {",

                                    "vUv = uv;",
                                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

                            "}"

                    ].join("\n"),

                    fragmentShader: [
                        
                        "varying vec2 vUv;",
                        
                        "uniform sampler2D tDiffuse;",
                        "uniform float radius;",
                        "uniform float resolutionH;",
                        
                        "float randomy(vec3 scale, float seed) {",
                            "/* use the fragment position for a different seed per-pixel */",
                            "return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);",
                        "}",

                        "void main() {",
                            "vec4 color = vec4(0.0);",
                            "float total = 0.0;",
                            "vec2 delta = vec2(0, radius / resolutionH);",

                            "/* randomize the lookup values to hide the fixed number of samples */",
                            "float offset = randomy(vec3(12.9898, 78.233, 151.7182), 0.0);",

                            "for (float t = -30.0; t <= 30.0; t++) {",
                                "float percent = (t + offset - 0.5) / 30.0;",
                                "float weight = 1.0 - abs(percent);",
                                "color += texture2D(tDiffuse, vUv + delta * percent) * weight;",
                                "total += weight;",
                            "}",
                            "gl_FragColor = color / total;",
                        "}",

                    ].join("\n")
                
                };
                
                
THREE.itownsMask = {
    
                    uniforms:{
                        "tDiffuse": { type: "t", value:1, texture: null },  // from previous shader
                        "textureIn": { type: "t", value:0, texture: null },  // Color image,
                        "bias": { type: "f", value: -2.0 },
                        
                    },
                    
                    controls: {
                            bias: { min:-10, max: 10, step:.5}
                    },
                    
                    vertexShader: [

                            "varying vec2 vUv;",

                            "void main() {",

                                    "vUv = uv;",
                                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

                            "}"

                    ].join("\n"),
                    
                    fragmentShader: [

                        "varying vec2 vUv;",

                        "uniform float bias;",
                        "uniform sampler2D tDiffuse;",   // tBlur
                        "uniform sampler2D textureIn;",

                        "void main() {",

                            "vec4 tex_blur = texture2D( tDiffuse, vUv );",
                            "vec4 tex_color = texture2D( textureIn, vUv );",
                            "gl_FragColor = tex_color - 0.2*(vec4(1.) - tex_blur);",//vec4(spatial_imp, 1.0);",//tex_blur;",//vec4(final, 1.0);", //tex_depth;",
                            "gl_FragColor.a = 1.;",
                        "}",
                    
                    ].join("\n")

  }  



  distw =1.0/1920.;
  disth =1.0/1080.;     

  THREE.ItownsSharpening = {

                    info: {
                        name: 'sharpen',
                        author: 'AD'
                    },

                   
                    uniforms:{
                        "tDiffuse": { type: "t", value:0, texture: null },  
                        "bias": { type: "f", value: -2.0 },
                        "kernel" : { type: "iv1", value: [ -1, -1, -1,-1, 17,-1,-1,-1, -1 ] },    // integer array (plain),
                        "screenWidth" : {type: "i", value: 1920 },
		        "screenHeight" : {type: "i", value: 1080 },
                        "offset": { type: "v2v", value: [ 
                            new THREE.Vector2(distw,disth ),new THREE.Vector2( 0.,disth),new THREE.Vector2( -distw,disth),
                            new THREE.Vector2(distw,0. ),new THREE.Vector2( 0.,0.),new THREE.Vector2( -distw,0.),
                            new THREE.Vector2(distw,-disth ),new THREE.Vector2( 0.,-disth),new THREE.Vector2( -distw,-disth)
                            ]
                        }, 
                    },
                    
                    controls: {
                            bias: { min:-10, max: 10, step:.5}
                    },
                    
                    vertexShader: [

                            "varying vec2 vUv;",
                            "void main() {",

                                    "vUv = uv;",
                                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

                            "}"

                    ].join("\n"),
                    
                    fragmentShader: [

                        "varying vec2 vUv;",
                        "uniform float bias;",
                        "uniform sampler2D tDiffuse;",
                        "uniform int kernel[ 9 ];",
                        "uniform vec2 offset[ 9 ];",

                        "void main() {",

                           "vec4 sum = vec4(0.0);",        
                           "for(int i = 0; i < 9; i++) {",
                             "  vec4 color = texture2D(tDiffuse, vUv + offset[i]);",
                             "  sum += color * float(kernel[i]);",
                          "}",

                          "gl_FragColor = sum/9.;",//vec4(spatial_imp, 1.0);",//tex_blur;",//vec4(final, 1.0);", //tex_depth;",
                        "}",
                    
                    ].join("\n")

                };

THREE.unsharpMasking = {

                    info: {
                        name: 'unsharp masking',
                        author: 'ported by thierry tranchina aka @rDad',
                        link: 'http://graphics.uni-konstanz.de/publikationen/2006/unsharp_masking/webseite/'
                    },

                    uniforms:{
                        "tDepth": { type: "t", value:2, texture: null },
                        "tDiffuse": { type: "t", value:1, texture: null },   //  tBlur is the tDiffuse
                        "textureIn": { type: "t", value:0, texture: null },  
                        "bias": { type: "f", value: -2.0 }
                    },
                    
                    controls: {
                            bias: { min:-10, max: 10, step:.5}
                    },
                    
                    vertexShader: [

                            "varying vec2 vUv;",

                            "void main() {",

                                    "vUv = uv;",
                                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

                            "}"

                    ].join("\n"),
                    
                    fragmentShader: [

                        "varying vec2 vUv;",

                        "uniform float bias;",
                        "uniform sampler2D tDepth;",
                        "uniform sampler2D tDiffuse;",   // tBlur
                        "uniform sampler2D textureIn;",

                        "void main() {",

                            "vec4 tex_depth = texture2D( tDepth, vUv );",
                            "vec4 tex_blur = texture2D( tDiffuse, vUv );",
                            "vec4 tex_color = texture2D( textureIn, vUv );",

                            "vec3 spatial_imp = tex_blur.rgb - tex_depth.rgb;",

                            "vec3 final = vec3(1.,1.,1.);",//tex_color.rgb;",
                     //       "if(spatial_imp.r <=0.0) spatial_imp = vec3(0.,0.,0.);",
                            "if(spatial_imp.r>=0.0  &&  spatial_imp.r<0.9/*tex_depth.r >0.2*/)",
                            "{",
                                " final += spatial_imp * bias;",
                            "}",

                          "gl_FragColor = vec4(final, 0.2);",//vec4(spatial_imp, 1.0);",//tex_blur;",//vec4(final, 1.0);", //tex_depth;",

                        "}",
                    
                    ].join("\n")

                };


/**
 * @author alex IGN
 *
*/

THREE.ItownsToneMapping = {

	uniforms: {

		"tColor":   { type: "t", value: null },  // blurred img
                "tDiffuse":   { type: "t", value: null },
		"exposure":   { type: "f", value: 0.125 },
		"brightMax":    { type: "f", value: 0.5 }
	},
        
        vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

    fragmentShader: [


		"uniform sampler2D   tColor;",
                "uniform sampler2D   tDiffuse;",
		"uniform float       exposure;",
		"uniform float       brightMax;",

		"varying vec2  vUv;",
  
              
		"void main() {",


			"	vec4 colorOriginal =  texture2D( tColor, vUv );",
                        "	vec4 colorBlurred  =  texture2D( tDiffuse, vUv );",
                        
                        //"       colorOriginal *=2.;",
                        //"       colorBlurred  *=2.;",
                        "       vec4 newColor = colorOriginal/(colorBlurred+0.2);",
			"	gl_FragColor = vec4( newColor.xyz, 1 );",

                  "}"                    
                
	].join("\n")
		
};

THREE.ItownsDepthShader = {

	uniforms: {

		"tColor":   { type: "t", value: null },
		"tDepth":   { type: "t", value: null },
		"focus":    { type: "f", value: 1 },
		"maxblur":  { type: "f", value: 1.8 },
                "effectIntensity": { type: "f", value: 0.},
                "indice_time": { type: "f", value: 0.}

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float focus;",
		"uniform float maxblur;",

		"uniform sampler2D tColor;",
		"uniform sampler2D tDepth;",
                "uniform float effectIntensity;",
                "uniform float indice_time;",

		"varying vec2 vUv;",
                "float cameraFar = 10000.;",
                "float cameraNear = 0.2;",
                "float fogFar = 200.;",
                "float fogNear = 5.;",

                "float cameraFarPlusNear = cameraFar + cameraNear;",
		"float cameraFarMinusNear = cameraFar - cameraNear;",
		"float cameraCoef = 2.0 * cameraNear;",
                //" vec3 fogColor = vec3(0.93725,0.8196,0.7098);",
                " vec3 fogColor = vec3(0.9725,0.896,0.7598);",
                " vec3 skyColor = vec3(0.613,0.758,0.947);",
                " const float LOG2 = 1.442695;",
                " float fogDensity = 0.0025;",
  
		"void main() {",

                       
                        " vec4 depth = texture2D( tDepth, vUv );",
                        " float factor = depth.x - focus;",

                        " vec4 col = texture2D( tColor, vUv);//, 2.0 * maxblur * abs( focus - depth.x ) ); ",
                                                //" col.a=1.;",
                                                // "if (col.r > 0.9 && col.g > 0.9 && col.b > 0.9) {col = vec4(fogColor,1.);}",// col.r = 0.; col.g = 0.;col.a = 0.;}",
                        " gl_FragColor = col; ",
                                                // " gl_FragColor.a = 1.0;",
                        " float depth2 = (1.-depth.x);", 
                                                // " float fogFactor = exp2( - fogDensity * fogDensity * depth2 * depth2 * LOG2 );",
                                                // " fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
                       // We mix the blue sky and the fog color for ambient
                        " vec4 newAmbientColor = mix( vec4(skyColor,1.), vec4(fogColor, 1. ), effectIntensity / 100. );",
                        
                        "float coefMix = depth2/1.1;",
                      //  "if (col.r > 0.98 && col.g > 0.98 && col.b > 0.98 ) coefMix = 1.;",
                        " gl_FragColor = mix( col, newAmbientColor, coefMix);",
                        
                        // Apply brightness.
                         "gl_FragColor.rgb += 0.1 - effectIntensity/1000.;",

                        // Lightning
                        "if (( effectIntensity == 100. && mod(indice_time,50.) >= 0. && mod(indice_time,50.) <= 0.2)",
                         "  || ( effectIntensity == 100. && mod(indice_time,49.) >= 0. && mod(indice_time,49.) <= 0.2)) ",

                                " gl_FragColor = mix( col, vec4( 1.,1.,1.,1. ), depth2/1.1);",
                  "}"                    
                
	].join("\n")

};


THREE.BufferGeometryUtils = {

	fromGeometry: function geometryToBufferGeometry( geometry, settings ) {

		if ( geometry instanceof THREE.BufferGeometry ) {

			return geometry;

		}

		settings = settings || { 'vertexColors': THREE.NoColors };

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var faceVertexUvs = geometry.faceVertexUvs;
		var vertexColors = settings.vertexColors;
		var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;

		var bufferGeometry = new THREE.BufferGeometry();

		bufferGeometry.attributes = {

			position: {
				itemSize: 3,
				array: new Float32Array( faces.length * 3 * 3 )
			},
			normal: {
				itemSize: 3,
				array: new Float32Array( faces.length * 3 * 3 )
			},
                        materialindice : {
				itemSize: 1,
				array: new Float32Array( faces.length *3 )
			}

		}

		var positions = bufferGeometry.attributes.position.array;
		var normals = bufferGeometry.attributes.normal.array;
                var materialindice = bufferGeometry.attributes.materialindice.array;

		if ( vertexColors !== THREE.NoColors ) {

			bufferGeometry.attributes.color = {
				itemSize: 3,
				array: new Float32Array( faces.length * 3 * 3 )
			};

			var colors = bufferGeometry.attributes.color.array;

		}

		if ( hasFaceVertexUv === true ) {

			bufferGeometry.attributes.uv = {
				itemSize: 2,
				array: new Float32Array( faces.length * 3 * 2 )
			};

			var uvs = bufferGeometry.attributes.uv.array;

		}
                

		var i2 = 0, i3 = 0;
		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];
                        var materialIndiceCurrent = face.materialIndex;
                        var matIndiceNormalized = materialIndiceCurrent - settings.indice;
                       // matIndiceNormalized = Math.random();
      
                        materialindice[i*3]   = matIndiceNormalized;
                        materialindice[i*3+1] = matIndiceNormalized;
                        materialindice[i*3+2] = matIndiceNormalized;
                
               
			var a = vertices[ face.a ];
			var b = vertices[ face.b ];
			var c = vertices[ face.c ];

			positions[ i3     ] = a.x;
			positions[ i3 + 1 ] = a.y;
			positions[ i3 + 2 ] = a.z;
			
			positions[ i3 + 3 ] = b.x;
			positions[ i3 + 4 ] = b.y;
			positions[ i3 + 5 ] = b.z;
			
			positions[ i3 + 6 ] = c.x;
			positions[ i3 + 7 ] = c.y;
			positions[ i3 + 8 ] = c.z;

			var na = face.vertexNormals[ 0 ];
			var nb = face.vertexNormals[ 1 ];
			var nc = face.vertexNormals[ 2 ];

			normals[ i3     ] = na.x;
			normals[ i3 + 1 ] = na.y;
			normals[ i3 + 2 ] = na.z;

			normals[ i3 + 3 ] = nb.x;
			normals[ i3 + 4 ] = nb.y;
			normals[ i3 + 5 ] = nb.z;

			normals[ i3 + 6 ] = nc.x;
			normals[ i3 + 7 ] = nc.y;
			normals[ i3 + 8 ] = nc.z;

			if ( vertexColors === THREE.FaceColors ) {

				var fc = face.color;

				colors[ i3     ] = fc.r;
				colors[ i3 + 1 ] = fc.g;
				colors[ i3 + 2 ] = fc.b;

				colors[ i3 + 3 ] = fc.r;
				colors[ i3 + 4 ] = fc.g;
				colors[ i3 + 5 ] = fc.b;

				colors[ i3 + 6 ] = fc.r;
				colors[ i3 + 7 ] = fc.g;
				colors[ i3 + 8 ] = fc.b;

			} else if ( vertexColors === THREE.VertexColors ) {

				var vca = face.vertexColors[ 0 ];
				var vcb = face.vertexColors[ 1 ];
				var vcc = face.vertexColors[ 2 ];

				colors[ i3     ] = vca.r;
				colors[ i3 + 1 ] = vca.g;
				colors[ i3 + 2 ] = vca.b;

				colors[ i3 + 3 ] = vcb.r;
				colors[ i3 + 4 ] = vcb.g;
				colors[ i3 + 5 ] = vcb.b;

				colors[ i3 + 6 ] = vcc.r;
				colors[ i3 + 7 ] = vcc.g;
				colors[ i3 + 8 ] = vcc.b;

			}

			if ( hasFaceVertexUv === true ) {

				var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
				var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
				var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

				uvs[ i2     ] = uva.x;
				uvs[ i2 + 1 ] = uva.y;
			
				uvs[ i2 + 2 ] = uvb.x;
				uvs[ i2 + 3 ] = uvb.y;
			
				uvs[ i2 + 4 ] = uvc.x;
				uvs[ i2 + 5 ] = uvc.y;

			}

			i3 += 9;
			i2 += 6;

		}

		bufferGeometry.computeBoundingSphere();

		return bufferGeometry;

	}

};

THREE.AnaglyphEffect = function ( renderer,base3D, width, height ) {

        
	var eyeRight = new THREE.Matrix4();
	var eyeLeft = new THREE.Matrix4();
	var focalLength = base3D;
	var _aspect, _near, _far, _fov;
        var _anaglyphOn = true;
       // var _sideBySideOn = false;
        var _arrayEffect = [1,0,0]; // 3 renderings, [Anaglyph,Polarize,SidebySide]
        var _currentEffectNum = 0; // -> anaglyph [0-2]

	var _cameraL = new THREE.PerspectiveCamera();
	_cameraL.matrixAutoUpdate = false;

	var _cameraR = new THREE.PerspectiveCamera();
	_cameraR.matrixAutoUpdate = false;

	var _camera = new THREE.OrthographicCamera( -1, 1, 1, - 1, 0, 1 );

	var _scene = new THREE.Scene();

	var _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

	if ( width === undefined ) width = 512;
	if ( height === undefined ) height = 512;

	var _renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );
	var _renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );

	var _materialAnalgyph = new THREE.ShaderMaterial( {

		uniforms: {

			"mapLeft": { type: "t", value: _renderTargetL },
			"mapRight": { type: "t", value: _renderTargetR }

		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

			"	vUv = vec2( uv.x, uv.y );",
			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform sampler2D mapLeft;",
			"uniform sampler2D mapRight;",
			"varying vec2 vUv;",

			"void main() {",

			"	vec4 colorL, colorR;",
			"	vec2 uv = vUv;",

			"	colorL = texture2D( mapLeft, uv );",
			"	colorR = texture2D( mapRight, uv );",

				// http://3dtv.at/Knowhow/AnaglyphComparison_en.aspx

			"	gl_FragColor = vec4( colorL.g * 0.7 + colorL.b * 0.3, colorR.g, colorR.b, colorL.a + colorR.a ) * 1.1;",

			"}"

		].join("\n")

	} );
        
        // For rendering on 3D screen (1 line on 2)
        var _materialPolarize = new THREE.ShaderMaterial( {

		uniforms: {

			"mapLeft": { type: "t", value: _renderTargetL },
			"mapRight": { type: "t", value: _renderTargetR }

		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

			"	vUv = vec2( uv.x, uv.y );",
			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform sampler2D mapLeft;",
			"uniform sampler2D mapRight;",
			"varying vec2 vUv;",

			"void main() {",

			"	vec2 uv = vUv;",

			"	if ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {",

			"		gl_FragColor = texture2D( mapLeft, uv );",

			"	} else {",

			"		gl_FragColor = texture2D( mapRight, uv );",

			"	}",

			"}"


		].join("\n")

	} );
        
         // For rendering on 3D screen (1 line on 2)
        var _materialSideBySide = new THREE.ShaderMaterial( {

		uniforms: {

			"mapLeft": { type: "t", value: _renderTargetL },
			"mapRight": { type: "t", value: _renderTargetR }

		},

		vertexShader: [

			"varying vec2 vUv;",

			"void main() {",

			"	vUv = vec2( uv.x, uv.y );",
			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform sampler2D mapLeft;",
			"uniform sampler2D mapRight;",
			"varying vec2 vUv;",

			"void main() {",

			"	if ( gl_FragCoord.x  < 960. ) {",

			"		gl_FragColor = texture2D( mapLeft, vec2(vUv.x *2., vUv.y) );",

			"	} else {",

			"		gl_FragColor = texture2D( mapRight, vec2((vUv.x - 0.5) *2., vUv.y) );",

			"	}",

			"}"


		].join("\n")

	} );


        _material = _materialAnalgyph;

	var mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), _material );
	_scene.add( mesh );
        
        /*   // Polarize and anaglyph SAVE
        this.switchMaterial = function(){
            
            _anaglyphOn = !_anaglyphOn;
            
            if (!_anaglyphOn)
                _material = _materialPolarize;    
            else
                _material = _materialAnalgyph;

            _material.uniforms[ "mapLeft" ].value = _renderTargetL;
            _material.uniforms[ "mapRight" ].value = _renderTargetR;
            mesh.material = _material;
        };
     */
        
        // switch between ActiveGlasses and anaglyph
        this.switchMaterial = function(){
            
            _currentEffectNum = (_currentEffectNum+1) % 3;
   
            switch(_currentEffectNum){
            
                case 0:  _material = _materialAnalgyph; break;
                case 1:  _material = _materialPolarize; break;
                case 2:  _material = _materialSideBySide; break;
            }

            _material.uniforms[ "mapLeft" ].value = _renderTargetL;
            _material.uniforms[ "mapRight" ].value = _renderTargetR;
            mesh.material = _material;
        };
        
        
        this.setFocalLength = function(v,camera){
            
            focalLength = v;
            _aspect = camera.aspect;
            _near = camera.near;
            _far = camera.far;
            _fov = camera.fov;

            var projectionMatrix = camera.projectionMatrix.clone();
            var eyeSep = focalLength / 30 * 0.5;
            var eyeSepOnProjection = eyeSep * _near / focalLength;
            var ymax = _near * Math.tan( THREE.Math.degToRad( _fov * 0.5 ) );
            var xmin, xmax;

            // translate xOffset

            eyeRight.elements[12] = eyeSep;
            eyeLeft.elements[12] = -eyeSep;

            // for left eye

            xmin = -ymax * _aspect + eyeSepOnProjection;
            xmax = ymax * _aspect + eyeSepOnProjection;

            projectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );
            projectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );

            _cameraL.projectionMatrix.copy( projectionMatrix );

            // for right eye

            xmin = -ymax * _aspect - eyeSepOnProjection;
            xmax = ymax * _aspect - eyeSepOnProjection;

            projectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );
            projectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );

            _cameraR.projectionMatrix.copy( projectionMatrix );

        }


	this.setSize = function ( width, height ) {

		if ( _renderTargetL ) _renderTargetL.dispose();
		if ( _renderTargetR ) _renderTargetR.dispose();
		_renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );
		_renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );

		_material.uniforms[ "mapLeft" ].value = _renderTargetL;
		_material.uniforms[ "mapRight" ].value = _renderTargetR;

		renderer.setSize( width, height );

	};

	/*
	 * Renderer now uses an asymmetric perspective projection
	 * (http://paulbourke.net/miscellaneous/stereographics/stereorender/).
	 *
	 * Each camera is offset by the eye seperation and its projection matrix is
	 * also skewed asymetrically back to converge on the same projection plane.
	 * Added a focal length parameter to, this is where the parallax is equal to 0.
	 */

	this.render = function ( scene, camera ) {

		scene.updateMatrixWorld();

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		var hasCameraChanged = ( _aspect !== camera.aspect ) || ( _near !== camera.near ) || ( _far !== camera.far ) || ( _fov !== camera.fov );

		if ( hasCameraChanged ) {

			_aspect = camera.aspect;
			_near = camera.near;
			_far = camera.far;
			_fov = camera.fov;

			var projectionMatrix = camera.projectionMatrix.clone();
			var eyeSep = focalLength / 30 * 0.5;
			var eyeSepOnProjection = eyeSep * _near / focalLength;
			var ymax = _near * Math.tan( THREE.Math.degToRad( _fov * 0.5 ) );
			var xmin, xmax;

			// translate xOffset

			eyeRight.elements[12] = eyeSep;
			eyeLeft.elements[12] = -eyeSep;

			// for left eye

			xmin = -ymax * _aspect + eyeSepOnProjection;
			xmax = ymax * _aspect + eyeSepOnProjection;

			projectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );
			projectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );

			_cameraL.projectionMatrix.copy( projectionMatrix );

			// for right eye

			xmin = -ymax * _aspect - eyeSepOnProjection;
			xmax = ymax * _aspect - eyeSepOnProjection;

			projectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );
			projectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );

			_cameraR.projectionMatrix.copy( projectionMatrix );

		}

		_cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
		_cameraL.position.copy( camera.position );
		_cameraL.near = camera.near;
		_cameraL.far = camera.far;

		renderer.render( scene, _cameraL, _renderTargetL, true );

		_cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
		_cameraR.position.copy( camera.position );
		_cameraR.near = camera.near;
		_cameraR.far = camera.far;

		renderer.render( scene, _cameraR, _renderTargetR, true );

		renderer.render( _scene, _camera );

	};

	this.dispose = function() {
		if ( _renderTargetL ) _renderTargetL.dispose();
		if ( _renderTargetR ) _renderTargetR.dispose();
	}

};




THREE.ShaderLib['water'] = {

	uniforms: { "normalSampler":	{ type: "t", value: null },
				"mirrorSampler":	{ type: "t", value: null },
				"alpha":			{ type: "f", value: 1.0 },
				"time":				{ type: "f", value: 0.0 },
				"distortionScale":	{ type: "f", value: 20.0 },
				"noiseScale":		{ type: "f", value: 1.0 },
				"textureMatrix" :	{ type: "m4", value: new THREE.Matrix4() },
				"sunColor":			{ type: "c", value: new THREE.Color(0x7F7F7F) },
				"sunDirection":		{ type: "v3", value: new THREE.Vector3(0.70707, 0.70707, 0) },
				"eye":				{ type: "v3", value: new THREE.Vector3(0, 0, 0) },
				"waterColor":		{ type: "c", value: new THREE.Color(0x555555) },
				"betaVersion":		{ type: "i", value: 0 }
	},

	vertexShader: [
		'uniform mat4 textureMatrix;',
		'uniform float time;',
		'uniform float noiseScale;',
		'uniform sampler2D normalSampler;',
		'uniform int betaVersion;',

		'varying vec4 mirrorCoord;',
		'varying vec3 worldPosition;',
		
		'float getHeight(in vec2 uv)',
		'{',
		'	vec2 uv0 = uv / (103.0 * noiseScale) + vec2(time / 17.0, time / 29.0);',
		'	vec2 uv1 = uv / (107.0 * noiseScale) - vec2(time / -19.0, time / 31.0);',
		'	vec2 uv2 = uv / (vec2(8907.0, 9803.0) * noiseScale) + vec2(time / 101.0, time /  097.0);',
		'	vec2 uv3 = uv / (vec2(1091.0, 1027.0) * noiseScale) - vec2(time / 109.0, time / -113.0);',
		
		'	float v0 = texture2D(normalSampler, uv0).y;',
		'	float v1 = texture2D(normalSampler, uv1).y;',
		'	float v2 = texture2D(normalSampler, uv2).y;',
		'	float v3 = texture2D(normalSampler, uv3).y;',
		
		'	return v0 * 103.0 + v1 * 107.0 + v2 * 9000.0 + v3 * 1000.0 + 20000.0;',
		'}',
		
		'void main()',
		'{',
		'	mirrorCoord = modelMatrix * vec4(position, 1.0);',
		'	worldPosition = mirrorCoord.xyz;',
		
		'	mirrorCoord = textureMatrix * mirrorCoord;',
		'	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
		
		/*'	if(betaVersion > 0)', // This is just a really beta way to add movement on vertices, totally wrong, but fast to implement
		'	{',
		'		gl_Position.y += getHeight(worldPosition.xz) * 0.008;',
		'	}',*/
		'}'
	].join('\n'),

	fragmentShader: [		
		'uniform sampler2D mirrorSampler;',
		'uniform float alpha;',
		'uniform float time;',
		'uniform float distortionScale;',
		'uniform float noiseScale;',
		'uniform sampler2D normalSampler;',
		'uniform vec3 sunColor;',
		'uniform vec3 sunDirection;',
		'uniform vec3 eye;',
		'uniform vec3 waterColor;',

		'varying vec4 mirrorCoord;',
		'varying vec3 worldPosition;',
		
		'void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, in float shiny, in float spec, in float diffuse, inout vec3 diffuseColor, inout vec3 specularColor)',
		'{',
		'	vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));',
		'	float direction = max(0.0, dot(eyeDirection, reflection));',
		'	specularColor += pow(direction, shiny) * sunColor * spec;',
		'	diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;',
		'}',
		
		'vec3 getNoise(in vec2 uv)',
		'{',
		'	vec2 uv0 = uv / (103.0 * noiseScale) + vec2(time / 17.0, time / 29.0);',
		'	vec2 uv1 = uv / (107.0 * noiseScale) - vec2(time / -19.0, time / 31.0);',
		'	vec2 uv2 = uv / (vec2(8907.0, 9803.0) * noiseScale) + vec2(time / 101.0, time /   97.0);',
		'	vec2 uv3 = uv / (vec2(1091.0, 1027.0) * noiseScale) - vec2(time / 109.0, time / -113.0);',
		'	vec4 noise = (texture2D(normalSampler, uv0)) +',
        '		(texture2D(normalSampler, uv1)) +',
        '		(texture2D(normalSampler, uv2)) +',
		'		(texture2D(normalSampler, uv3));',
		'	return noise.xzy * 0.5 - 1.0;',
		'}',
		
		'void main()',
		'{',
		'	vec3 surfaceNormal = (getNoise(worldPosition.xz));',
		'   if( eye.y < worldPosition.y )',
		'		surfaceNormal = surfaceNormal * -1.0;',

		'	vec3 diffuseLight = vec3(0.0);',
		'	vec3 specularLight = vec3(0.0);',

		'	vec3 worldToEye = eye - worldPosition;',
		'	vec3 eyeDirection = normalize(worldToEye);',
		'	sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);',
		
		'	float distance = length(worldToEye);',

		'	vec2 distortion = surfaceNormal.xz * distortionScale * sqrt(distance) * 0.07;',
        '   vec3 mirrorDistord = mirrorCoord.xyz + vec3(distortion.x, distortion.y, 1.0);',
        '   vec3 reflectionSample = texture2DProj(mirrorSampler, mirrorDistord).xyz;',

		'	float theta = max(dot(eyeDirection, surfaceNormal), 0.0);',
		'	const float rf0 = 0.3;',
		'	float reflectance = 0.3 + (1.0 - 0.3) * pow((1.0 - theta), 5.0);',
		'	vec3 scatter = max(0.0, dot(surfaceNormal, eyeDirection)) * waterColor;',
		'	vec3 albedo = mix(sunColor * diffuseLight * 0.3 + scatter, (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);',
        '   vec2 tmp = mirrorCoord.xy / mirrorCoord.z + distortion;',

        '	gl_FragColor = vec4(albedo, alpha);',
		'}'
	].join('\n')

};

THREE.Water = function (renderer, camera, scene, options) {
	
	THREE.Object3D.call(this);
	this.name = 'water_' + this.id;

	function isPowerOfTwo (value) {
		return (value & (value - 1)) === 0;
	};
	function optionalParameter (value, defaultValue) {
		return value !== undefined ? value : defaultValue;
	};

	options = options || {};
	
	this.matrixNeedsUpdate = true;
	
	var width = optionalParameter(options.textureWidth, 512);
	var height = optionalParameter(options.textureHeight, 512);
	this.clipBias = optionalParameter(options.clipBias, -0.0001);
	this.alpha = optionalParameter(options.alpha, 1.0);
	this.time = optionalParameter(options.time, 0.0);
	this.normalSampler = optionalParameter(options.waterNormals, null);
	this.sunDirection = optionalParameter(options.sunDirection, new THREE.Vector3(0.70707, 0.70707, 0.0));
	this.sunColor = new THREE.Color(optionalParameter(options.sunColor, 0xffffff));
	this.waterColor = new THREE.Color(optionalParameter(options.waterColor, 0x7F7F7F));
	this.eye = optionalParameter(options.eye, new THREE.Vector3(0, 0, 0));
	this.distortionScale = optionalParameter(options.distortionScale, 20.0);
	this.noiseScale = optionalParameter(options.noiseScale, 1.0);
	this.betaVersion = optionalParameter(options.betaVersion, 0);
	this.side = optionalParameter(options.side, THREE.FrontSide);
	
	this.renderer = renderer;
	this.scene = scene;
	this.mirrorPlane = new THREE.Plane();
	this.normal = new THREE.Vector3(0, 0, 1);
	this.mirrorWorldPosition = new THREE.Vector3();
	this.cameraWorldPosition = new THREE.Vector3();
	this.rotationMatrix = new THREE.Matrix4();
	this.lookAtPosition = new THREE.Vector3(0, 0, -1);
	this.clipPlane = new THREE.Vector4();
	
	if (camera instanceof THREE.PerspectiveCamera)
		this.camera = camera;
	else  {
		this.camera = new THREE.PerspectiveCamera();
		console.log(this.name + ': camera is not a Perspective Camera!')
	}

	this.textureMatrix = new THREE.Matrix4();

	this.mirrorCamera = this.camera.clone();
	
	this.texture = new THREE.WebGLRenderTarget(width, height);
	this.tempTexture = new THREE.WebGLRenderTarget(width, height);
	
	var mirrorShader = THREE.ShaderLib["water"];
	var mirrorUniforms = THREE.UniformsUtils.clone(mirrorShader.uniforms);

	this.material = new THREE.ShaderMaterial({ 
		fragmentShader: mirrorShader.fragmentShader, 
		vertexShader: mirrorShader.vertexShader, 
		uniforms: mirrorUniforms,
		transparent: true,
		side: this.side
	});

	this.material.uniforms.mirrorSampler.value = this.texture;
	this.material.uniforms.textureMatrix.value = this.textureMatrix;
	this.material.uniforms.alpha.value = this.alpha;
	this.material.uniforms.time.value = this.time;
	this.material.uniforms.normalSampler.value = this.normalSampler;
	this.material.uniforms.sunColor.value = this.sunColor;
	this.material.uniforms.waterColor.value = this.waterColor;
	this.material.uniforms.sunDirection.value = this.sunDirection;
	this.material.uniforms.distortionScale.value = this.distortionScale;
	this.material.uniforms.noiseScale.value = this.noiseScale;
	this.material.uniforms.betaVersion.value = this.betaVersion;
	
	this.material.uniforms.eye.value = this.eye;
	
	if (!isPowerOfTwo(width) || !isPowerOfTwo(height)) 
	{
		this.texture.generateMipmaps = false;
		this.tempTexture.generateMipmaps = false;
	}

	this.updateTextureMatrix();
	this.render();
};

THREE.Water.prototype = Object.create(THREE.Object3D.prototype);

THREE.Water.prototype.renderWithMirror = function (otherMirror) {

	// update the mirror matrix to mirror the current view
	this.updateTextureMatrix();
	this.matrixNeedsUpdate = false;

	// set the camera of the other mirror so the mirrored view is the reference view
	var tempCamera = otherMirror.camera;
	otherMirror.camera = this.mirrorCamera;

	// render the other mirror in temp texture
	otherMirror.renderTemp();
	otherMirror.material.uniforms.mirrorSampler.value = otherMirror.tempTexture;

	// render the current mirror
	this.render();
	this.matrixNeedsUpdate = true;

	// restore material and camera of other mirror
	otherMirror.material.uniforms.mirrorSampler.value = otherMirror.texture;
	otherMirror.camera = tempCamera;

	// restore texture matrix of other mirror
	otherMirror.updateTextureMatrix();
};

THREE.Water.prototype.updateTextureMatrix = function () {


       // console.log("tttttthis",this);
	function sign(x) { return x ? x < 0 ? -1 : 1 : 0; }

	this.updateMatrixWorld();
	this.camera.updateMatrixWorld();

	//this.mirrorWorldPosition.setFromMatrixPosition(this.matrixWorld);
	//this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld);
        this.mirrorWorldPosition = new THREE.Vector3().getPositionFromMatrix(this.matrixWorld);
        this.cameraWorldPosition = new THREE.Vector3().getPositionFromMatrix(this.camera.matrixWorld);

	this.rotationMatrix.extractRotation(this.matrixWorld);

	if( this.mirrorWorldPosition.y > this.cameraWorldPosition.y ) {
		this.normal.set(0, 0, -1);
	}
	else {
		this.normal.set(0, 0, 1);
	}
	this.normal.applyMatrix4(this.rotationMatrix);

	var view = this.mirrorWorldPosition.clone().sub(this.cameraWorldPosition);
	view.reflect(this.normal).negate();
	view.add(this.mirrorWorldPosition);

	this.rotationMatrix.extractRotation(this.camera.matrixWorld);

	this.lookAtPosition.set(0, 0, -1);
	this.lookAtPosition.applyMatrix4(this.rotationMatrix);
	this.lookAtPosition.add(this.cameraWorldPosition);

	var target = this.mirrorWorldPosition.clone().sub(this.lookAtPosition);
	target.reflect(this.normal).negate();
	target.add(this.mirrorWorldPosition);

	this.up.set(0, -1, 0);
	this.up.applyMatrix4(this.rotationMatrix);
	this.up.reflect(this.normal).negate();

	this.mirrorCamera.position.copy(view);
	this.mirrorCamera.up = this.up;
	this.mirrorCamera.lookAt(target);
	this.mirrorCamera.aspect = this.camera.aspect;

	this.mirrorCamera.updateProjectionMatrix();
	this.mirrorCamera.updateMatrixWorld();
	this.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld);

	// Update the texture matrix
	this.textureMatrix.set(0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0);
	this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix);
	this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse);

	// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
	// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
	this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mirrorWorldPosition);
	this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse);

	this.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);

	var q = new THREE.Vector4();
	var projectionMatrix = this.mirrorCamera.projectionMatrix;

	q.x = (sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
	q.y = (sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
	q.z = -1.0;
	q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];

	// Calculate the scaled plane vector
	var c = new THREE.Vector4();
	c = this.clipPlane.multiplyScalar(2.0 / this.clipPlane.dot(q));

	// Replacing the third row of the projection matrix
	projectionMatrix.elements[2] = c.x;
	projectionMatrix.elements[6] = c.y;
	projectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;
	projectionMatrix.elements[14] = c.w;
	
	var worldCoordinates = new THREE.Vector3();
	worldCoordinates = new THREE.Vector3().getPositionFromMatrix(this.camera.matrixWorld);
	this.eye = worldCoordinates;
	this.material.uniforms.eye.value = this.eye;
};

THREE.Water.prototype.render = function () {

	if(this.matrixNeedsUpdate)
		this.updateTextureMatrix();

	this.matrixNeedsUpdate = true;

	// Render the mirrored view of the current scene into the target texture
	if(this.scene !== undefined && this.scene instanceof THREE.Scene)
	{
        this.renderer.render(this.scene, this.mirrorCamera, this.texture, true);
	}

};

THREE.Water.prototype.renderTemp = function () {

	if(this.matrixNeedsUpdate)
		this.updateTextureMatrix();

	this.matrixNeedsUpdate = true;

	// Render the mirrored view of the current scene into the target texture
	if(this.scene !== undefined && this.scene instanceof THREE.Scene)
	{
		this.renderer.render(this.scene, this.mirrorCamera, this.tempTexture, true);
	}

};

THREE.Water.prototype.update=function() {
		this.ms_Water.material.uniforms.time.value += 1.0 / 60.0;
		//this.ms_Controls.update();
		//this.display();
	};



// shared ortho camera

THREE.EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

THREE.EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );

THREE.EffectComposer.scene = new THREE.Scene();
THREE.EffectComposer.scene.add( THREE.EffectComposer.quad );


});



define('GraphicEngine',['lib/three', 'jquery', 'Utils', 'lib/postprocessing/EffectComposer'], function(THREE, $, Utils, EffectComposer) {

    //PRIVATE MEMBERS*****************************************************************************************
    //********************************************************************************************************

    // ATTRIBUTES
    //*************************************

    //Camera properties
    var     _camera = null,
            _view_angle = null,
            _aspect = null,
            _near = null,
            _far = 10000,
            _farFog = 250,
            _yaw = 0,
            _pitch = 0,
            _effectFog = null,
            _toneMapping= null,
            _scaleGlobal = 1,  // TO render faster on mobile for ex use scale subsamp
            _mobileVersion = false,   // Optimize rendering for low power gpu and change texture for bati3d to jpeg
            _effectFogIntensity = 0,
            _speedTurnCam = 0.01,
            _speedTransCam = 0.04, //0.04,
            _cameraHelper = null,
            _orbitCameraOn = false,
            _nodeControllerOn = false,
            _centerOrbit = null,
            _oldCamPos = null,
            _oldTarget = null,
            _camDraw = null,
            _currentTargetPos = null,
            _wantedTargetPos = null,
            _targetDist = null,
            _angleCameraLon = null,
            _angleCameraLat = null,
            // Added for smooth moves
            _translatCam = {x: 0, y: 0.6, z: 0},
            _trip = {x: 0}, // Current distance to do while translating
            _containerId = "#",
            _winWidth = null,
            _winHeight = null,
            _scene = null,
            _axisHelper = null,
            _renderer = null,
            _zero = null,
            _initialized = false,
            // POST PROCESSING
            _lensFlare = null,
            _sunLight = null,
            depthMaterial = null, composer = null,
            depthPassPlugin = null, depthTarget = null, colorTarget = null, material_depth = null,
            _postprocessing = { enabled  : false, guiBool: true},
            _effects = {climate:false, sharpen:false, brightness:false, hdr:false},
            _anaglyph = null,
            _Base3DGlasses = 200,
            _arrEffects = [],
            _msWater = null,
            _renderPass,
    _textPanels = [],
            _grid = null;
    // METHODS
    //*************************************


    _states = {
        ON_GIZMO: false,
        MESH_MANIPULATION: false,
        MULTIMEDIA_MANIPULATION: false
    },
    _statesHandler = {
        MESH_MANIPULATION: function(val) { //display axis
            if (val !== _states["MESH_MANIPULATION"]) {
                _currentGizmo.toggleAxis(val);
                if (val === true) {
                    _currentGizmo.toggleDisplay(false);
                }
                else {
                    GraphicEngine.setGizmoToMesh(_currentGizmo.selectedMesh);
                }
            }
        }
    };

    /*
     * 
     * @returns {undefined}
     */
    function initCamera() {

        _aspect = _winWidth / _winHeight;
        _view_angle = 80;
        _near = 0.2;
        _far = 10000;   // 10000 meters max distance visible (useful for laser buffer)
        _speedTurnCam = 0.1;
        _wantedTargetPos = new THREE.Vector3(0, 0, -100000);
        _currentTargetPos = new THREE.Vector3(0, 0, 0);

        _camera = new THREE.PerspectiveCamera(_view_angle, _aspect, _near, _far);
        _camera.lookAt(new THREE.Vector3(0, 0, 0));
        _camera.position.x = 0;       
        _camera.position.y = 0.6;
        _camera.position.z = 0;  
        _camera.scale = new THREE.Vector3(1, 1, -1);     // -1 for the z to go from user to inside the screen (north)
        _angleCameraLat = 0;
        _angleCameraLon = 0;
        _targetDist = 100000;
    }

    /*
     * 
     * @param {type} geom
     * @param {type} name
     * @returns {GraphicEngine_L1.addGeometry.mesh|GraphicEngine_L1.THREE.Mesh}
     */
    function addGeometry(geom, name) {
        var material = new THREE.MeshPhongMaterial({
            ambient: 0xcccccc
        });
        var mesh = new THREE.Mesh(geom, material);
        mesh.name = name;
        mesh.position = new THREE.Vector3(_camera.position.x, _camera.position.y - 0.6, _camera.position.z + 0.7);
        GraphicEngine.rotateY(_angleCameraLon, mesh);
        _scene.add(mesh);
        return mesh;
    }



    // SHIM
    //*************************************
    // @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window.requestAnimFrame = (function() {
        return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(callback, element) {
                    window.setTimeout(callback, 1000 / 60);
                };
    })();

    //END OF PRIVATE MEMBERS**********************************************************************************
    //********************************************************************************************************

    var GraphicEngine = {
        
        init: function(containerId) {

            _winWidth = window.innerWidth;
            _winHeight = window.innerHeight;

            initCamera();

            _scene = new THREE.Scene();
            _scene.add(_camera);

            // LIGHT
            _scene.add(new THREE.AmbientLight(0xcccccc));

            //render init
            _renderer = new THREE.WebGLRenderer({
            	preserveDrawingBuffer: true,   // required to support .toDataURL()
            	antialias: true,
            	alpha: true
            });
            _renderer.setSize(_winWidth/_scaleGlobal, _winHeight/_scaleGlobal);
            _renderer.setClearColor(new THREE.Color(0x000000, 1.)); // opacity?
            _containerId += containerId;
            $container = $(_containerId);
            $container.append(_renderer.domElement);

            var canvas = _renderer.domElement;
            canvas.id ="canvasWEBGL";
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            canvas.style.zIndex = "-1";

            //grid
            _grid = new THREE.Mesh(
                    new THREE.PlaneGeometry(1000, 1000, 100, 100),
                    new THREE.MeshBasicMaterial({
                        wireframe: true,
                        color: 0xcccccc,
                        side: THREE.DoubleSide
                    }));
            _grid.rotation.x = -Math.PI * 0.5;
            _grid.position.y = -50;

            //manage window resize
            $(window).resize(function() {
                _camera.aspect = window.innerWidth / window.innerHeight;
                _camera.updateProjectionMatrix();
                _winWidth = window.innerWidth/_scaleGlobal;
                _winHeight = window.innerHeight/_scaleGlobal;
                _renderer.setSize(_winWidth, _winHeight);
                var canvas = _renderer.domElement;//document.getElementsByTagName('canvas')[0];
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
            });

            // TEST POSTPROCESSING*********************************
            //if (postprocessing.enabled)
            this.initPostprocessing();

            _initialized = true;
        },

        initPostprocessing: function() {

            composer = new THREE.EffectComposer(_renderer);

            // Depth material
            material_depth = new THREE.MeshDepthMaterial();
            //  material_depth.blending = THREE.NormalBlending;//.NoBlending;
            material_depth.side = THREE.DoubleSide;  // ! important

            // First classic pass not needed here cause in render function we write color to color texture already
            _renderPass = new THREE.RenderPass( _scene, _camera );


            // We create the 2 rendertargets. One for the color and the other for the depth

            var pars = {minFilter: THREE.LinearMipMapLinear, magFilter: THREE.LinearMipMapLinear, format: THREE.RGBAFormat, antialias: true };
                _postprocessing.rtTextureDepth = new THREE.WebGLRenderTarget( _winWidth, _winHeight, pars );
                _postprocessing.rtTextureColor = new THREE.WebGLRenderTarget( _winWidth, _winHeight, pars );


            // Fog Effect
                _effectFog = new THREE.ShaderPass( THREE.ItownsDepthShader); // Our special shader (fog effect initially)
                _effectFog.uniforms[ 'maxblur' ].value = 100.;
                _effectFog.uniforms[ 'tColor' ].value = _postprocessing.rtTextureColor;   // we set the value of color texture to the good render target
                _effectFog.uniforms[ 'tDepth' ].value = _postprocessing.rtTextureDepth;   // here for depth
                _effectFog.uniforms['effectIntensity'].value = _effectFogIntensity;
                _effectFog.uniforms['indice_time'].value = 0.;
                _effectFog.enabled = false;
                _effectFog.renderToScreen = false;
                _arrEffects.push(_effectFog);

                

                 var hueSaturation = new THREE.ShaderPass(THREE.HueSaturationShader);
                 hueSaturation.enabled = false;
                 hueSaturation.renderToScreen = false;
                 _arrEffects.push(hueSaturation);
                 
                
                 composer.addPass( _renderPass );  // Not needed for fog effect cause it uses postprocessing.rtTextureColor from scene global rendering
                 composer.addPass( _effectFog );
                 
                 composer.addPass( hueSaturation );
                

         // Test HDR (ToneMapping)  **************************************************************
                 
                _postprocessing.textureOriginal = new THREE.WebGLRenderTarget( _winWidth, _winHeight, pars );
                _postprocessing.textureBlurred  = new THREE.WebGLRenderTarget( _winWidth, _winHeight, pars );
            
                 var blurOnX = new THREE.ShaderPass(THREE.blurTriangleX);
                 blurOnX.uniforms[ 'radius' ].value = 50.;
                 blurOnX.uniforms[ 'resolutionW' ].value = _winWidth;
                 blurOnX.enabled = false;
                 blurOnX.renderToScreen = false;
                 _arrEffects.push(blurOnX);
                 
                 var blurOnY = new THREE.ShaderPass(THREE.blurTriangleY);
                 blurOnY.uniforms[ 'radius' ].value = 50.;
                 blurOnY.uniforms[ 'resolutionH' ].value = _winHeight;
                 blurOnY.enabled = false;
                 blurOnY.renderToScreen = false;
                 _arrEffects.push(blurOnY);
                 
                 composer.addPass( blurOnX );
                 composer.addPass( blurOnY );
                 //_arrEffects.push(blurOnX); 
                 
                 _toneMapping = new THREE.ShaderPass(THREE.ItownsToneMapping);
                 _toneMapping.uniforms[ 'tColor' ].value = _postprocessing.textureOriginal;
                 _toneMapping.enabled = false;
                 _toneMapping.renderToScreen = false;
                 _arrEffects.push(_toneMapping);
                 composer.addPass(_toneMapping );
                 
                 // moved at the end to sharpen final image
                 var sharpenEffect = new THREE.ShaderPass(THREE.ItownsSharpening);
                 sharpenEffect.enabled = false;
                 sharpenEffect.renderToScreen = false;
                 _arrEffects.push(sharpenEffect);
                 composer.addPass( sharpenEffect );   

         /*
                // UNSHARP MASKING DEPTH BUFFER
             var renderPass = new THREE.RenderPass( _scene, _camera );

             var blurEffectXDepth = new THREE.ShaderPass( THREE.blurTriangleXDepth);
                blurEffectXDepth.uniforms[ 'tDepth' ].value = _postprocessing.rtTextureDepth;
             blurEffectXDepth.uniforms[ 'radius' ].value = 50.;
             blurEffectXDepth.uniforms[ 'resolutionW' ].value = _winWidth;

             var blurEffectY = new THREE.ShaderPass( THREE.blurTriangleY);
         //     blurEffectY.uniforms[ 'textureIn' ].value = _postprocessing.rtTextureColor;
             blurEffectY.uniforms[ 'radius' ].value = 50.;
             blurEffectY.uniforms[ 'resolutionH' ].value = _winHeight;


             var unSharpMaskingEffect = new THREE.ShaderPass( THREE.unsharpMasking);
                unSharpMaskingEffect.uniforms[ 'tDepth' ].value = _postprocessing.rtTextureDepth;
             //  unSharpMaskingEffect.uniforms[ 'tBlur' ].value = 5.;  // Actually the blur is passed in as tDiffuse
                unSharpMaskingEffect.uniforms[ 'textureIn' ].value = _postprocessing.rtTextureColor;

             var blurEffectX2 = new THREE.ShaderPass( THREE.blurTriangleX);
             blurEffectX2.uniforms[ 'radius' ].value = 5.;
             blurEffectX2.uniforms[ 'resolutionW' ].value = _winWidth;

             var blurEffectY2 = new THREE.ShaderPass( THREE.blurTriangleY);
             blurEffectY2.uniforms[ 'radius' ].value = 5.;
             blurEffectY2.uniforms[ 'resolutionH' ].value = _winHeight;

             var itownsMask = new THREE.ShaderPass( THREE.itownsMask);
                itownsMask.uniforms[ 'textureIn' ].value = _postprocessing.rtTextureColor;


             //composer.addPass( renderPass );
             //   composer.addPass( renderPass );
            //    composer.addPass( _effectFog );

             // UNSHARP MASKING DEPTHBUFFER

             composer.addPass( blurEffectXDepth );
             composer.addPass( blurEffectY );
             composer.addPass( unSharpMaskingEffect );
             composer.addPass( blurEffectX2 );
             composer.addPass( blurEffectY2 );
             composer.addPass( itownsMask);

             //blurEffectY2.renderToScreen = true;
             itownsMask.renderToScreen = true;
             //unSharpMaskingEffect.renderToScreen = true;
             // blurEffectY.renderToScreen = true;
             */
        },
        addFogEffect: function(){

             _effectFog.enabled = true;

            /* _effectFog.renderToScreen = true;
             composer.addPass( _effectFog );
             _arrEffects.push(_effectFog);
             _previousEffectRenderedToScreen.renderToScreen  = false;
             _previousEffectRenderedToScreen = _effectFog;
            */
             //_currentEffectRenderedToScreen = _effectFog;
             this.updateEffectRenderToScene();
             _postprocessing.enabled = this.updateEffectRenderToScene();
        },

        removeFogEffect: function(){

            _effectFog.enabled = false;
           // _previousEffectRenderedToScreen.renderToScreen  = false;
           _postprocessing.enabled = this.updateEffectRenderToScene();

        },


        setPostProcessingOn: function(b){
            _postprocessing.enabled = b;
            _postprocessing.guiBool = b;
        },

        addPostProcess: function(){

           _arrEffects[5].enabled = true;
           _postprocessing.enabled = this.updateEffectRenderToScene();
        },


        setAnaglyphOnOff: function(){

            if(_anaglyph == null){
                _anaglyph = new THREE.AnaglyphEffect(_renderer,_Base3DGlasses);
                _anaglyph.setSize(window.innerWidth, window.innerHeight);
            }else{
                _anaglyph = null;
            }
            _postprocessing.enabled = this.updateEffectRenderToScene();
        },


        switch3DGlasses: function(){

            if(_anaglyph)
               _anaglyph.switchMaterial();
        },

        setBase3DGlasses: function(v){
             _Base3DGlasses = v;
             if(_anaglyph)
                _anaglyph.setFocalLength(v,_camera);
        },


        // If no index then remove last postprocess
        removePostProcess: function(index){

           _arrEffects[5].enabled = false;
           _postprocessing.enabled = this.updateEffectRenderToScene();
        },

        addHueSaturation : function(){
            _arrEffects[1].enabled = true;
           _postprocessing.enabled = this.updateEffectRenderToScene();
        },

        removeHueSaturation: function(){
           _arrEffects[1].enabled = false;
           _postprocessing.enabled = this.updateEffectRenderToScene();
        },

        setSaturationValue : function(value){
            if(!_arrEffects[1].enabled) this.addHueSaturation();
            _arrEffects[1].uniforms[ 'saturation' ].value = (value - 100.) /100.;
        },

        setHueValue : function(value){
            if(!_arrEffects[1].enabled) this.addHueSaturation();
            _arrEffects[1].uniforms[ 'hue' ].value = (value -100.) /100.;
        },

        setContrastValue : function(value){
            if(!_arrEffects[1].enabled) this.addHueSaturation();
            _arrEffects[1].uniforms[ 'contrast' ].value = value /100.;
        },

        setBrightnessValue : function(value){
            if(!_arrEffects[1].enabled) this.addHueSaturation();
            _arrEffects[1].uniforms[ 'brightness' ].value = value /100.;
        },

        setToneMapping : function(value){
            if(!_arrEffects[4].enabled) this.addToneMapping();
            //_arrEffects[3].uniforms[ 'saturation' ].value = (value - 100.) /100.;
        },
        
        addToneMapping : function(){
            
            // ADD Hue Saturation TOO
            this.addHueSaturation();
            this.setSaturationValue(26);
            this.setBrightnessValue(170);
            _arrEffects[2].enabled = true;
            _arrEffects[3].enabled = true;
            _arrEffects[4].enabled = true;
            _postprocessing.enabled = this.updateEffectRenderToScene();
        },
        
        removeToneMapping: function(){
           _arrEffects[2].enabled = false;
           _arrEffects[3].enabled = false;
           _arrEffects[4].enabled = false;
           _postprocessing.enabled = this.updateEffectRenderToScene();
           
           // REMOVE HUESATURATION
           // (back to normal)
            this.setSaturationValue(100);
            this.setBrightnessValue(100);
        },
        
        

         // Are we on computer or tablet/phone
           //
        checkIfMobile: function(forceBoolFromURL){

          if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)  || (forceBoolFromURL)){

              _mobileVersion = true;
              _scaleGlobal = 2;

              console.log("mobile version");
            }
        },
        
         /**
         * Change resolution and other optimization for low configuration (switch mode)
         * @returns {Void}
         */
        setReso: function(){
            
            
            
            if(_scaleGlobal==2){  // Change to High Res
                this.setLowReso(0);
            }  else{  // Change to Low Res
                this.setLowReso(1);
            }
            
            this.adaptWindowResolution();
        },
        
        setLowReso: function(b){
            
            if(b){// Change to Low Res
                _scaleGlobal = 2;
                _mobileVersion = true;}
            else{// Change to High Res
                _scaleGlobal = 1;
                _mobileVersion = false;
            }
            
            this.adaptWindowResolution();
        },


        /**
         * Refresh window with right resolution using _scaleGlobal
         * @returns {Void}
         */
      adaptWindowResolution: function(){
                _camera.aspect = window.innerWidth / window.innerHeight;
                _camera.updateProjectionMatrix();
                _winWidth = window.innerWidth/_scaleGlobal;
                _winHeight = window.innerHeight/_scaleGlobal;
                _renderer.setSize(_winWidth, _winHeight);


                var canvas = _renderer.domElement;//document.getElementsByTagName('canvas')[0];

                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                //_renderer.setSize(_winWidth, _winHeight);
            },
            
        setNodeControllerOn: function(b){
             console.log("setNodeControllerOn", b);
            _nodeControllerOn = b;
        },


        getNodeControllerOn: function(){
            console.log("node controller",_nodeControllerOn);
            return _nodeControllerOn;
        },


        render: function() {

            // set up the next call
            requestAnimFrame(GraphicEngine.render);

            // BETA Move camera smoothly between positions
            // tweening
            if(_orbitCameraOn) {

                GraphicEngine.orbitCamera(_centerOrbit);
                GraphicEngine.lookAtScaleOk(_centerOrbit);
            } else{

                _camera.position.x += (_translatCam.x - _camera.position.x) * _speedTransCam;
                _camera.position.z += (_translatCam.z - _camera.position.z) * _speedTransCam;
                _camera.position.y += (_translatCam.y - _camera.position.y) * _speedTransCam;

                _currentTargetPos.x += (_wantedTargetPos.x - _currentTargetPos.x) * _speedTurnCam;
                _currentTargetPos.y += (_wantedTargetPos.y - _currentTargetPos.y) * _speedTurnCam;
                _currentTargetPos.z += (_wantedTargetPos.z - _currentTargetPos.z) * _speedTurnCam;

                _camera.lookAt(_currentTargetPos);
            }

          // _camera.updateProjectionMatrix();


            if ( _postprocessing.enabled ) {

                if(_effects.climate){

                    _renderer.clear();
                     if(_msWater) {_msWater.material.uniforms.time.value += 1.0 / 60.0;_msWater.render();}
                     
                    // Render scene into texture color
                    _scene.overrideMaterial = null;
                    _renderer.render( _scene, _camera, _postprocessing.rtTextureColor, true );

                    // Render depth into texture depth. We change far cam cause of texture depth depedances
                    _camera.far = _farFog;
                    _scene.overrideMaterial = material_depth;

                    _renderer.render( _scene, _camera, _postprocessing.rtTextureDepth, true );
                    _camera.far = _far;
                }

                if(_anaglyph != null) _anaglyph.render(_scene,_camera);
                
                   else{
                      if(_toneMapping.enabled){
                            _renderer.clear();
                            _scene.overrideMaterial = null;
                            _renderer.render( _scene, _camera, _postprocessing.textureOriginal, true );
                      }
                      composer.render(); // Render shader composite to screen

                   }
  
            } else {
              
                 if(_msWater) {_msWater.material.uniforms.time.value += 1.0 / 60.0;_msWater.render();}
                _renderer.render(_scene, _camera);
            }

           //  if(!_mobileVersion) _rendererCSS.render(_cssScene, _camera);    
        },
          /**
         * Render main scene with main cam. No recall animFrame.
         * @returns {Void}
         */
        renderOnce: function(){
            _renderer.render(_scene, _camera);
        },

        //renderer.render(this.sceneRTT, camera, this.rtTexture,true)
        renderToTexture: function(scene, camera, texture, bool) {

            _renderer.render(scene, camera, texture, bool);
        },
        getState: function(state) {
            if (_states.hasOwnProperty(state) === false) {
                throw TypeError("Undefined state " + state + " in graphic engine");
            }
            else {
                return _states[state];
            }
        },
        setState: function(state, value) {
            if (_states.hasOwnProperty(state) === false) {
                throw TypeError("Undefined state " + state + " in graphic engine");
            }
            else {
                if (typeof _statesHandler[state] !== "undefined") {
                    _statesHandler[state](value);
                }
                _states[state] = (value === false || value === true) ? value : false;
            }
        },
        /**
         * Throws a ray from the given mouse coordinate to the forward direction and return an array of objects
         * intersected by the ray in the set of objects from the array given as parameter
         *
         * @param {Number} x The mouse clientX coordinate
         * @param {Number} y The mouse clientY coordinate
         * @param {THREE.Mesh[]} objects Objects tested accross the ray
         * @returns {THREE.Mesh[]} Objects given as parameter and intersected by the ray
         */
        getIntersected: function(x, y, objects) {

            var point = Utils.toNDC(x, y);

            var vector = new THREE.Vector3(point.x, point.y, 1);
            var projector = new THREE.Projector();
            var ray = projector.pickingRay(vector, _camera);

            return ray.intersectObjects(objects);
        },
        addToScene: function(obj) {
            _scene.add(obj);
        },

        

        

        /**
         * Add a collada mesh in the scene (just for demo purpose)
         */
        addDemoMesh: function(model) {

            model.position = new THREE.Vector3(_camera.position.x, _camera.position.y - 0.6, _camera.position.z + 0.7);
            this.rotateY(_angleCameraLon, model);
            model.rotation.x = -Math.PI / 2;

            switch (model.name.split("_")[0]) {
                case "tree": // tree
                    model.scale.multiplyScalar(0.125);
                    break;
                case "bench": // bench
                    model.scale.multiplyScalar(0.01);
                    model.rotation.z = -Math.PI / 4;
                    break;
                case "light": // light
                    model.scale.multiplyScalar(0.125);
                    break;
            }
            _scene.add(model);
        },
        addCube: function(name) {
            return addGeometry(new THREE.CubeGeometry(0.25, 0.25, 0.25), name);
        },
        addSphere: function(name) {
            return  addGeometry(new THREE.SphereGeometry(0.25, 16, 12), name);
        },
        addCylinder: function(name) {
            return addGeometry(new THREE.CylinderGeometry(0.15, 0.15, 0.5, 16, 16), name);
        },
        addTextPanel: function(canvas, position, name, scale) {

            if (typeof canvas === "undefined" || typeof position === "undefined") {
                throw TypeError("one argument is undefined");
            }
            
            var scale = scale || 0.0015;
            var geomPlane = new THREE.PlaneGeometry(canvas.width, canvas.height);
            var material = new THREE.MeshBasicMaterial({
                map: new THREE.Texture(canvas),
                /*overdraw: true,*/
                transparent: true,
                depthTest: false,
                depthWrite: false,
                side: THREE.DoubleSide
            });
            material.map.needsUpdate = true;
            var meshPlane = new THREE.Mesh(geomPlane, material);
            meshPlane.name = name;
            meshPlane.id = name;
            meshPlane.position = new THREE.Vector3(position.x, position.y, position.z);
            //   meshPlane.rotation = _camera.rotation;
            meshPlane.quaternion = _camera.quaternion;
            meshPlane.scale.multiplyScalar(scale);
            _textPanels.push(meshPlane);
            _scene.add(meshPlane);

            return meshPlane;
        },
        
        removeTextPanels: function() {
            var panelsCount = _textPanels.length;
            while (panelsCount > 0) {
                _scene.remove(_textPanels.pop());
                panelsCount--;
            }
        },
        
        
        removeTextPanelFromName: function(nameText){
            
            //_scene.remove(_scene.getObjectByName(nameText, true ));
            _scene.remove(_scene.getObjectById( nameText, true ));
            /*
            var panelsCount = _textPanels.length;
            while (panelsCount > 0) {
                if(_scene)
                _scene.remove(_textPanels.pop());
                panelsCount--;
            }*/
        },
        
        getLastTextPanel: function(){
            
            return _textPanels[_textPanels.length -1];
        },
        removeFromScene: function(obj) {
            _scene.remove(obj);
        },

        drawSphereTest: function(param) {

            var ray, position;

            if (typeof param !== "undefined") {
                ray = param.ray || 50;
                position = param.position;
            }

            var sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(ray, 8, 8),
                    new THREE.MeshBasicMaterial({color: 0xff0000})
                    );

            if (typeof position !== "undefined") {
                sphere.position = position.clone();
            }
            // add the sphere to the scene
            _scene.add(sphere);
        },
        drawRay: function(x, y)
        {
            x = (x / (window.innerWidth)) * 2 - 1;
            y = -(y / (window.innerHeight)) * 2 + 1;

            var vector = new THREE.Vector3(x, y, 1);
            var projector = new THREE.Projector();
            projector.unprojectVector(vector, _camera);

            var geom = new THREE.Geometry();
            geom.vertices.push(_camera.position);
            geom.vertices.push(vector);

            var material = new THREE.LineBasicMaterial({
                color: 0xff0000,
                linewidth: 3
            });

            var line = new THREE.Line(geom, material);
            _scene.add(line);
        },
        drawCam: function()
        {
            if (_camDraw) {
                _scene.remove(_camDraw);
                _camDraw = null;
            }
            else {
                _camDraw = new THREE.CameraHelper(_camera);
                _scene.add(_camDraw);
            }

        },

        drawBB: function(mesh) {

            var existingBB = mesh.getChildByName(mesh.name + "_" + "bb");
            if (existingBB) {
                existingBB.visible = true;
            }
            else {
                mesh.geometry.computeBoundingBox();
                var bb = mesh.geometry.boundingBox;
                var bbGeometry = new THREE.CubeGeometry(bb.max.x - bb.min.x + 0.025,
                        bb.max.y - bb.min.y + 0.025,
                        bb.max.z - bb.min.z + 0.025);
                var bbMesh = new THREE.Mesh(bbGeometry, new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true
                }));
                bbMesh.name = mesh.name + "_" + "bb";
                mesh.add(bbMesh);
            }
        },

        hideBB: function(mesh) {
            var bb = mesh.getChildByName(mesh.name + "_" + "bb");
            if (bb) {
                bb.visible = false;
            }
        },

        switchSceneAxis: function() {
            if (_axisHelper == null) {
                _axisHelper = new THREE.AxisHelper();
                _axisHelper.scale.set(10, 10, 10);
                _scene.add(_axisHelper);
            }
            else {
                _scene.remove(_axisHelper);
                _axisHelper = null;
            }
        },

        /**
         * Apply a rotation to the given object arround the Y axis of the 3D coordinate system,
         * with the camera position as origin
         * @param {Number} angle Rotation angle in radian
         * @param {THREE.Object} object Object to rotate
         */
        rotateY: function(angle, object)
        {
            var tx = _camera.position.x,
                    tz = _camera.position.z;

            /* transfoMatrix = new THREE.Matrix4().translate(new THREE.Vector3(tx, 0, tz));
             transfoMatrix.rotateY(angle);
             transfoMatrix.translate(new THREE.Vector3(-tx, 0, -tz));
             */
            // SINCE R58
            var transfoMatrix = new THREE.Matrix4().makeTranslation(tx, 0, tz);
            transfoMatrix = Utils.rotateY(transfoMatrix, angle);
            transfoMatrix = Utils.translate(transfoMatrix, new THREE.Vector3(-tx, 0, -tz));

            object.position = object.position.applyMatrix4(transfoMatrix);
        },

        translateCamera: function(x, y, z) {
            if (typeof x !== "undefined" && typeof y !== "undefined" && typeof z !== "undefined") {
                var translation = new THREE.Vector3(x, y, z);
                if (THREE.REVISION === '52')
                    _camera.position.addSelf(translation);
                else
                    _camera.position.add(translation); //threejs 56
            }
            else {
                throw TypeError("one or many coordinate is/are undefined");
            }
        },

        // Tweening using variation in render
        translateCameraSmoothly: function(x, y, z) {

            if (typeof x !== "undefined" && typeof y !== "undefined" && typeof z !== "undefined") {

                if(x==-10001){_translatCam.y = y;}else{
                    _translatCam.x = x;
                    _translatCam.y = y;
                    _translatCam.z = z;
                }
            }
            else {
                throw TypeError("one or many coordinate is/are undefined");
            }
        },


        orbitCamera: function(center,speed,alti){

            var speed = speed || 0.001;
           // if (_camera.position.y <80) _camera.position.y = 120;
            //var alti = alti || 120;

            _angleCameraLon += speed;
            var targetDist = 300;//this.getTargetDist();

            var x = -targetDist * Math.sin(_angleCameraLon) + center.x;
            var z = -targetDist * Math.cos(_angleCameraLon) + center.z;
            var y =  targetDist * Math.tan(_angleCameraLat) + center.y;

        //    _currentTargetPos = new THREE.Vector3(x2,y2,z2);
        //    _wantedTargetPos = new THREE.Vector3(x2,y2,z2);

            _translatCam.x = x;
            _translatCam.y = y + 120;
            _translatCam.z = z;

            _currentTargetPos = center.clone() || new THREE.Vector3(-100,0,0);
            _wantedTargetPos = center.clone() || new THREE.Vector3(-100,0,0);

            _camera.position.x += (_translatCam.x - _camera.position.x) * _speedTransCam;
            _camera.position.z += (_translatCam.z - _camera.position.z) * _speedTransCam;
            _camera.position.y += (_translatCam.y - _camera.position.y) * _speedTransCam;

            _currentTargetPos.x += (_wantedTargetPos.x - _currentTargetPos.x) * _speedTurnCam;
            _currentTargetPos.y += (_wantedTargetPos.y - _currentTargetPos.y) * _speedTurnCam;
            _currentTargetPos.z += (_wantedTargetPos.z - _currentTargetPos.z) * _speedTurnCam;


        },



        cameraFollowItinerary: function(arrPos){

        },



        lookAtScaleOk: function(vector){

            vector = vector || new THREE.Vector3(0,0,0);
            var m1 = new THREE.Matrix4();
            // m1.lookAt( _camera.position, vector, _camera.up );
            m1.lookAt( _camera.position, vector, new THREE.Vector3(0,1,0) );
            m1 = Utils.rotateY(m1,Math.PI);
            _camera.quaternion.setFromRotationMatrix( m1 );

        /*

             // lookAt: function() {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

                var eye = _camera.positioj

		//return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[0] = x.x; te[4] = y.x; te[8] = z.x;
			te[1] = x.y; te[5] = y.y; te[9] = z.y;
			te[2] = x.z; te[6] = y.z; te[10] = z.z;



			return this;

		};
  */
       },
       
        setCameraOrthoVerticale: function(pos){
            
            //_posCamOriginale = _camera.position;
            this.translateCameraSmoothly(pos.x,pos.y,pos.z);
            
        },
        setOrbitCameraOn: function(orbitCenter){

            _centerOrbit = orbitCenter || _camera.position.clone();
            // Save current cam pos and ori
             if(!_orbitCameraOn){
                _oldCamPos = _camera.position.clone();
                _oldTarget = _currentTargetPos.clone();
                if (_camera.position.y <80) {_camera.position.y = 120;}
            }else{
                _translatCam = _oldCamPos;
                _currentTargetPos = _oldTarget;
            }

            _orbitCameraOn = !_orbitCameraOn;
        },

        cameraZoom: function(zoomValue) {

            var newFov = _camera.fov + zoomValue;
            if(newFov > 10 && newFov < 160){
                _camera.fov = newFov;
                _camera.updateProjectionMatrix();
            }
        },
        /**
         * Display or hide a grid in the scene according the val param
         */
        toggleGrid: function(val) {
            if (val === true) {
                _scene.add(_grid);
            }
            else {
                _scene.remove(_grid);
            }
        },
        // Function that position a point closer to the cam
        // To avoid the colision with the intersected mesh while
        // drawing another mesh
        // 'v' is original pos vector3, s is the scale (ex 0.05)
        getPositionCloserToCam: function(v, scale) {

            return new THREE.Vector3(v.x - scale * (v.x - _camera.position.x),
                    v.y - scale * (v.y - _camera.position.y),
                    v.z - scale * (v.z - _camera.position.z));
        },

        /**
         * Function that make the cam look at a special 3D point knowing his future position.
         * x1,z1 target of intersection in SCENE COORD! , x2 z2 position of cam after translation in center of pano.
         */
        cameraLookAtPosition: function(x1, y1, z1, x2, y2, z2) {

            var alpha = Math.atan2(x1 - x2, z1 - z2);
            var base = Math.sqrt((x1 - x2) * (x1 - x2) + (z1 - z2) * (z1 - z2));
            var beta = -Math.atan2(y1 - y2, base);

            this.setCameraLonLatAngle(alpha, beta);

            var x = -_targetDist * Math.sin(alpha);
            var z = -_targetDist * Math.cos(alpha);
            var y =  _targetDist * Math.tan(beta);

            this.setWantedCamRotation(x,y,z);


            //_camera.updateProjectionMatrix();
        },


        // alpha in degrees
        cameraLookAtHeading: function(x1, y1, z1, alpha) {

            var alpha = (alpha - 90) / 180 * Math.PI;
            var x = _targetDist * Math.cos(alpha);
            var z = _targetDist * Math.sin(alpha);
            this.cameraLookAtPosition(x1, y1, z1, x, y1, z);

            //  this.setCameraLonLatAngle(alpha,-beta);

        },
        
         // alpha in degrees (yaw = heading)
         // alhpa for yaw, beta for pitch
        cameraLookAtYawPitch: function(x1, y1, z1, alpha, beta) {

            var alpha = (alpha - 90) / 180 * Math.PI;
            var beta = beta /180 * Math.PI;
            var x = _targetDist * Math.cos(alpha);
            var z = _targetDist * Math.sin(alpha);
            var y = _targetDist * Math.tan(beta);
            this.cameraLookAtPosition(x1, y1, z1, x, y, z);

            //  this.setCameraLonLatAngle(alpha,-beta);

        },
        
        cameraLookHorizontally: function(){
            
           /*  this.setCameraLonLatAngle(alpha, beta);

            var x = -_targetDist * Math.sin(alpha);
            var z = -_targetDist * Math.cos(alpha);
            var y =  _targetDist * Math.tan(beta);*/

          //  this.setWantedCamRotation(x,y,z);
          
            // _wantedTargetPos.x = x;

            _angleCameraLat = 0;
            _wantedTargetPos.y = 0;//_wantedTargetPos.y;
          //  _wantedTargetPos.z = z;
        },

        tiltCamera: function(value){

            _camera.rotation.z = value;
            _camera.updateProjectionMatrix();

        },


        getProjectedRay: function(x, y, distance) {
            var coord = Utils.toNDC(x, y);

            var projector = new THREE.Projector();
            var ray = new THREE.Vector3(coord.x, coord.y, 1);
            projector.unprojectVector(ray, _camera);

            if (typeof distance !== "undefined") {
                ray.normalize().multiplyScalar(distance);
            }
            return ray;
        },
        getScene: function() {
            return _scene;
        },
        getContext: function() {
            return _renderer.getContext("experimental-webgl", {preserveDrawingBuffer: true});
        },
        getRenderer: function() {
            return _renderer;
        },

        getCameraPosition: function() {
            return _camera.position.clone();
        },
        getCamera: function() {
            return _camera;
        },
        getSpeedTurnCam: function() {
            return _speedTurnCam;
        },
        getSpeedTransCam: function() {
            return _speedTransCam;
        },
        getTranslatCam: function() {
            return _translatCam;
        },
        getCameraFov: function() {
            return _camera.fov;
        },
        setCameraFov: function(fov) {
           _camera.fov = fov;
           _camera.updateProjectionMatrix();
        },
        getAngleCameraLat: function() {
            return _angleCameraLat;
        },
        getAngleCameraLon: function() {
            return _angleCameraLon;
        },
        setCameraLonLatAngle: function(longitude, lattitude) {
            _angleCameraLon = longitude;
            _angleCameraLat = lattitude;
        },
        setWantedCamRotation: function(x, y, z) {
            _wantedTargetPos.x = x;
            _wantedTargetPos.y = y;
            _wantedTargetPos.z = z;
        },
        // return yaw, pitch in rad
        getCameraYawPitch: function(){
          return {yaw: _angleCameraLon, pitch: _angleCameraLat};  
          //{yaw:(_angleCameraLon % 2*Math.PI)/(2*Math.PI) * 360, pitch:(_angleCameraLat % Math.PI)/Math.PI * 180};  
        },
        getTargetDist: function() {
            return _targetDist;
        },
        getWinWith: function() {
            return _winWidth;
        },
        getWinHeight: function() {
            return _winHeight;
        },
        setZero: function(z) {
            console.log('set Zero at',z);
            if(z instanceof THREE.Vector3){
                _zero = z;
            }else{
                _zero = new THREE.Vector3(z.x,z.y,z.z);
            }    
        },
        getZero: function() {
            return _zero;
        },
        getZeroAsVec3D: function() {
            return new THREE.Vector3(parseFloat(_zero.x), parseFloat(_zero.y), parseFloat(_zero.z));
        },
        getTrip: function() {
            return _trip;
        },
        getClearColor: function(color) {
            return _renderer.getClearColor();
        },
        setSpeedTurnCam: function(value) {
            _speedTurnCam = value;
        },
        setSpeedTransCam: function(value) {
            _speedTransCam = value
        },
        setCameraPosition: function() {
            var numArg = arguments.length;
            if (numArg === 1)
                _camera.position.set(arguments[0].x, arguments[0].y, arguments[0].z);
            else if (numArg === 3)
                _camera.position.set(arguments[0], arguments[1], arguments[2]);
            else
                console.warn('No parameters passe through function' + arguments.callee);
        },

        setClearColor: function(color) {
            _renderer.setClearColor(color);

        },
        // ****Aesthetics************************************

        setFarFog: function(distance) {
            _farFog = distance;
        },
        setIntensityEffect: function(v) {
            _effectFogIntensity = v;
            _effectFog.uniforms['effectIntensity'].value= _effectFogIntensity;
        },
        setTimeEffect: function(t) {
            _effectFog.uniforms['indice_time'].value = t;
        },
        setEffectsClimateOn: function(b){

           if(b){

                this.addFogEffect();
                this.addLensFlare();
            }
            else{
                // We delete map and effects
                this.removeFogEffect();
                this.removeLensFlare();
            }

            _effects.climate = b;
            _effectFog.enabled = b;
            // _postprocessing.enabled = this.checkAtIfAtLeastOneEffectIsOn();
            _scene.overrideMaterial = null;
            _renderer.clear();
            _camera.far = _far;

            _postprocessing.enabled = this.updateEffectRenderToScene();
        },



        setWaterOn: function(){

            // Add light
		var directionalLight = new THREE.DirectionalLight(0xffff55, 1);
		directionalLight.position.set(-600, 300, 600);
		_scene.add(directionalLight);

            // Load textures
		var waterNormals = new THREE.ImageUtils.loadTexture('images/waternormals.jpg');
		waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

		// Create the water effect
		_msWater = new THREE.Water(_renderer, _camera, _scene, {
			textureWidth: 256,
			textureHeight: 256,
			waterNormals: waterNormals,
			alpha: 	1.0,
			sunDirection: directionalLight.position.normalize(),
			sunColor: 0xffffff,
			waterColor: 0x001e0f,
			betaVersion: 0,
			side: THREE.DoubleSide
		});
		var aMeshMirror = new THREE.Mesh(
			new THREE.PlaneGeometry(2000, 2000, 100, 100),
			_msWater.material
		);
		aMeshMirror.add(this.ms_Water);
		aMeshMirror.rotation.x = - Math.PI * 0.5;

		_scene.add(aMeshMirror);
                aMeshMirror.position.y-=6.5;

        },

        updateWater: function(){

                _msWater.material.uniforms.time.value += 1.0 / 60.0;
		//this.ms_Controls.update();
		//this.display();
                //console.log("test",this.ms_Water.material.uniforms.time.value);
                _msWater.render();

		//this.ms_Renderer.render(this.ms_Scene, this.ms_Camera);
        },
        /*
        checkAtIfAtLeastOneEffectIsOn: function(){

            var b = false;
            for(var p in _effects) {
                b = b || _effects[p];
            }
            return b;
        },
        */

       // Fonction to update the effect to render to the scene (last pass enabled)
       // And also return value updated of postprocessing
        updateEffectRenderToScene: function(){

           var found = false;
           var i = _arrEffects.length -1;
           while(!found && i>=0){
               found = _arrEffects[i].enabled == true;
               if(found) _arrEffects[i].renderToScreen = true;
               i--;
           }
           // Then set all the rest to no screenRendering
           while(i>=0){
               _arrEffects[i].renderToScreen = false; i--;
           }
           return (found && _postprocessing.guiBool) || (_anaglyph !=null &&_postprocessing.guiBool) ;
        },

        // lens flares   SUN
        addLensFlare: function() {

            var textureFlare0 = THREE.ImageUtils.loadTexture("../../images/lensflare/lensflare0.png");//images/lensflare/lensflare0.png
            var textureFlare2 = THREE.ImageUtils.loadTexture("../../images/lensflare/lensflare2.png");
            var textureFlare3 = THREE.ImageUtils.loadTexture("../../images/lensflare/lensflare3.png");
                
            // Get real light Position    
            //var currentPosWGS84 = Carto.convertCoordVec3(Carto.getCurrentPosition(),"EPSG:2154", "CRS:84");  
            var v = Utils.getSunPositionInScene(new Date().getTime());
            addLight(0.995, 0.5, 0.9,v.x, v.y, v.z);
            //addLight(0.995, 0.5, 0.9, 200, 200, 0);//-500, 150, 500 );

            function addLight(h, s, l, x, y, z) {
                console.log('sun added at position: ',x,y,z);
                _sunLight = new THREE.PointLight(0xffffff, 1.5, 4500);
                _sunLight.color.setHSL(h, s, l);
                _sunLight.position.set(x, y, z);
                //  _scene.add( _sunLight );

                var flareColor = new THREE.Color(0xffffff);
                flareColor.setHSL(h, s, l + 0.5);

                _lensFlare = new THREE.LensFlare(textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor);

                _lensFlare.add(textureFlare2, 512, 0.0, THREE.AdditiveBlending);
                _lensFlare.add(textureFlare2, 512, 0.0, THREE.AdditiveBlending);
                _lensFlare.add(textureFlare2, 512, 0.0, THREE.AdditiveBlending);

                _lensFlare.add(textureFlare3, 60, 0.6, THREE.AdditiveBlending);
                _lensFlare.add(textureFlare3, 70, 0.7, THREE.AdditiveBlending);
                _lensFlare.add(textureFlare3, 120, 0.9, THREE.AdditiveBlending);
                _lensFlare.add(textureFlare3, 700, 6.0, THREE.AdditiveBlending);

                //lensFlare.customUpdateCallback = lensFlareUpdateCallback;
                _lensFlare.position = _sunLight.position;

                _scene.add(_lensFlare);

            }
        },

        addClouds: function(){

            var clouds = new THREE.CloudShader();
            var mesh = clouds.showClouds();
            _scene.add(mesh);
        },

        removeLensFlare: function() {
            _scene.remove(_lensFlare);
        },
        setLensFlareIntensity: function(intensity) {

            if (_lensFlare) {
                _lensFlare.opacity = 0.6 + (1. - intensity / 100.) / 0.4;
                for (var a = 0; a < _lensFlare.lensFlares.length; ++a) {
                    _lensFlare.lensFlares[a].opacity = _lensFlare.opacity;
                }
            }
        },
        initialized: function() {
            return _initialized;
        },

       

        isMobileEnvironment:function(){
            return _mobileVersion;
        },

        setMobileEnvironment:function(v){
             _mobileVersion = v;
        },
        
        getContainerID: function(){
            return _containerId;
        }
    };

    return GraphicEngine;

});




/**
* @author AD IGN
* Class where we get the Intrinseque parameters of the system. Camera (laser soon).
* load configuration from DB (t_camera INNER JOIN tl_stereopolis_capteurs )
*/


define ('Sensor',['lib/three'], function (THREE) { 

    
     
    function Sensor(infos){
                 
        this.sommet = new THREE.Vector3(); 
        this.mat3d =  new THREE.Matrix4(); // new matrix for faster Transform 

        // ALL JSON FROM DB
        this.infos = infos || { cam_calibration_date: "2008-03-04",
                                cam_cppa: 956.866,
                                cam_disto_cpps: 952.15,
                                cam_disto_lpps: 545.721,
                                cam_disto_r3: -4.56769e-8,
                                cam_disto_r5: 2.68315e-14,
                                cam_disto_r7: 1.82166e-21,
                                cam_focal: 1398.27,
                                cam_height: 1080,
                                cam_id: 13,
                                cam_id_pos: 12,
                                cam_lppa: 544.682,
                                cam_name: "Pike_64",
                                cam_orientation: 3,
                                cam_pixel_size: 0.0000074,
                                cam_serial_number: 268927064,
                                cam_width: 1920,
                                l_s_c_cam_id: 13,
                                l_s_c_l1_x: 0.968579,
                                l_s_c_l1_y: 0.0198464,
                                l_s_c_l1_z: 0.247914,
                                l_s_c_l2_x: 0.0182161,
                                l_s_c_l2_y: -0.999795,
                                l_s_c_l2_z: 0.00886795,
                                l_s_c_l3_x: 0.248039,
                                l_s_c_l3_y: -0.00407329,
                                l_s_c_l3_z: -0.968741,
                                l_s_c_las_id: 0,
                                l_s_c_ste_id: 1,
                                l_s_c_x: 1.41298,
                                l_s_c_y: 0.83044,
                                l_s_c_z: 0.14798};
                    
     };   
     
     
     // Compute matrix for faster Transform after
     Sensor.prototype.setMatrix = function(){
         
         var i = this.infos;
         this.mat3d = new THREE.Matrix4( i.l_s_c_l1_x, i.l_s_c_l1_y, i.l_s_c_l1_z,
                                         i.l_s_c_l2_x, i.l_s_c_l2_y, i.l_s_c_l2_z,
                                         i.l_s_c_l3_x, i.l_s_c_l3_y, i.l_s_c_l3_z
                                        );
                                           
     };
     
     
     Sensor.prototype.setSommet= function(){
         
         var i = this.infos;
         this.sommet = new THREE.Vector3( i.l_s_c_x, i.l_s_c_y, i.l_s_c_z);
                                            
     };
     
     
     Sensor.prototype.transformToItownsRef= function(){
         
     };
     
     
     Sensor.prototype.getAllInfos = function(){
         
         
     };

   
     Sensor.prototype.setId = function(id) {
         this.id = id;
     };
     
     
     Sensor.prototype.setName = function(name) {
         this.name = name;
     };
     

    return Sensor


});
/**
  @license
  when.js - https://github.com/cujojs/when

  MIT License (c) copyright B Cavalier & J Hann

 * A lightweight CommonJS Promises/A and when() implementation
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @version 1.7.1
 */

(function(define) { 
define('lib/when',[],function () {
	var reduceArray, slice, undef;

	//
	// Public API
	//

	when.defer     = defer;     // Create a deferred
	when.resolve   = resolve;   // Create a resolved promise
	when.reject    = reject;    // Create a rejected promise

	when.join      = join;      // Join 2 or more promises

	when.all       = all;       // Resolve a list of promises
	when.map       = map;       // Array.map() for promises
	when.reduce    = reduce;    // Array.reduce() for promises

	when.any       = any;       // One-winner race
	when.some      = some;      // Multi-winner race

	when.chain     = chain;     // Make a promise trigger another resolver

	when.isPromise = isPromise; // Determine if a thing is a promise

	/**
	 * Register an observer for a promise or immediate value.
	 *
	 * @param {*} promiseOrValue
	 * @param {function?} [onFulfilled] callback to be called when promiseOrValue is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} [onRejected] callback to be called when promiseOrValue is
	 *   rejected.
	 * @param {function?} [onProgress] callback to be called when progress updates
	 *   are issued for promiseOrValue.
	 * @returns {Promise} a new {@link Promise} that will complete with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(promiseOrValue, onFulfilled, onRejected, onProgress) {
		// Get a trusted promise for the input promiseOrValue, and then
		// register promise handlers
		return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
	 * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}
	 * whose value is promiseOrValue if promiseOrValue is an immediate value.
	 *
	 * @param {*} promiseOrValue
	 * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
	 *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
	 *   whose resolution value is:
	 *   * the resolution value of promiseOrValue if it's a foreign promise, or
	 *   * promiseOrValue if it's a value
	 */
	function resolve(promiseOrValue) {
		var promise, deferred;

		if(promiseOrValue instanceof Promise) {
			// It's a when.js promise, so we trust it
			promise = promiseOrValue;

		} else {
			// It's not a when.js promise. See if it's a foreign promise or a value.
			if(isPromise(promiseOrValue)) {
				// It's a thenable, but we don't know where it came from, so don't trust
				// its implementation entirely.  Introduce a trusted middleman when.js promise
				deferred = defer();

				// IMPORTANT: This is the only place when.js should ever call .then() on an
				// untrusted promise. Don't expose the return value to the untrusted promise
				promiseOrValue.then(
					function(value)  { deferred.resolve(value); },
					function(reason) { deferred.reject(reason); },
					function(update) { deferred.progress(update); }
				);

				promise = deferred.promise;

			} else {
				// It's a value, not a promise.  Create a resolved promise for it.
				promise = fulfilled(promiseOrValue);
			}
		}

		return promise;
	}

	/**
	 * Returns a rejected promise for the supplied promiseOrValue.  The returned
	 * promise will be rejected with:
	 * - promiseOrValue, if it is a value, or
	 * - if promiseOrValue is a promise
	 *   - promiseOrValue's value after it is fulfilled
	 *   - promiseOrValue's reason after it is rejected
	 * @param {*} promiseOrValue the rejected value of the returned {@link Promise}
	 * @returns {Promise} rejected {@link Promise}
	 */
	function reject(promiseOrValue) {
		return when(promiseOrValue, rejected);
	}

	/**
	 * Trusted Promise constructor.  A Promise created from this constructor is
	 * a trusted when.js promise.  Any other duck-typed promise is considered
	 * untrusted.
	 * @constructor
	 * @name Promise
	 */
	function Promise(then) {
		this.then = then;
	}

	Promise.prototype = {
		/**
		 * Register a callback that will be called when a promise is
		 * fulfilled or rejected.  Optionally also register a progress handler.
		 * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)
		 * @param {function?} [onFulfilledOrRejected]
		 * @param {function?} [onProgress]
		 * @returns {Promise}
		 */
		always: function(onFulfilledOrRejected, onProgress) {
			return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);
		},

		/**
		 * Register a rejection handler.  Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @returns {Promise}
		 */
		otherwise: function(onRejected) {
			return this.then(undef, onRejected);
		},

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @returns {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		yield: function(value) {
			return this.then(function() {
				return value;
			});
		},

		/**
		 * Assumes that this promise will fulfill with an array, and arranges
		 * for the onFulfilled to be called with the array as its argument list
		 * i.e. onFulfilled.spread(undefined, array).
		 * @param {function} onFulfilled function to receive spread arguments
		 * @returns {Promise}
		 */
		spread: function(onFulfilled) {
			return this.then(function(array) {
				// array may contain promises, so resolve its contents.
				return all(array, function(array) {
					return onFulfilled.apply(undef, array);
				});
			});
		}
	};

	/**
	 * Create an already-resolved promise for the supplied value
	 * @private
	 *
	 * @param {*} value
	 * @returns {Promise} fulfilled promise
	 */
	function fulfilled(value) {
		var p = new Promise(function(onFulfilled) {
			// TODO: Promises/A+ check typeof onFulfilled
			try {
				return resolve(onFulfilled ? onFulfilled(value) : value);
			} catch(e) {
				return rejected(e);
			}
		});

		return p;
	}

	/**
	 * Create an already-rejected {@link Promise} with the supplied
	 * rejection reason.
	 * @private
	 *
	 * @param {*} reason
	 * @returns {Promise} rejected promise
	 */
	function rejected(reason) {
		var p = new Promise(function(_, onRejected) {
			// TODO: Promises/A+ check typeof onRejected
			try {
				return onRejected ? resolve(onRejected(reason)) : rejected(reason);
			} catch(e) {
				return rejected(e);
			}
		});

		return p;
	}

	/**
	 * Creates a new, Deferred with fully isolated resolver and promise parts,
	 * either or both of which may be given out safely to consumers.
	 * The Deferred itself has the full API: resolve, reject, progress, and
	 * then. The resolver has resolve, reject, and progress.  The promise
	 * only has then.
	 *
	 * @returns {Deferred}
	 */
	function defer() {
		var deferred, promise, handlers, progressHandlers,
			_then, _progress, _resolve;

		/**
		 * The promise for the new deferred
		 * @type {Promise}
		 */
		promise = new Promise(then);

		/**
		 * The full Deferred object, with {@link Promise} and {@link Resolver} parts
		 * @class Deferred
		 * @name Deferred
		 */
		deferred = {
			then:     then, // DEPRECATED: use deferred.promise.then
			resolve:  promiseResolve,
			reject:   promiseReject,
			// TODO: Consider renaming progress() to notify()
			progress: promiseProgress,

			promise:  promise,

			resolver: {
				resolve:  promiseResolve,
				reject:   promiseReject,
				progress: promiseProgress
			}
		};

		handlers = [];
		progressHandlers = [];

		/**
		 * Pre-resolution then() that adds the supplied callback, errback, and progback
		 * functions to the registered listeners
		 * @private
		 *
		 * @param {function?} [onFulfilled] resolution handler
		 * @param {function?} [onRejected] rejection handler
		 * @param {function?} [onProgress] progress handler
		 */
		_then = function(onFulfilled, onRejected, onProgress) {
			// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
			var deferred, progressHandler;

			deferred = defer();

			progressHandler = typeof onProgress === 'function'
				? function(update) {
					try {
						// Allow progress handler to transform progress event
						deferred.progress(onProgress(update));
					} catch(e) {
						// Use caught value as progress
						deferred.progress(e);
					}
				}
				: function(update) { deferred.progress(update); };

			handlers.push(function(promise) {
				promise.then(onFulfilled, onRejected)
					.then(deferred.resolve, deferred.reject, progressHandler);
			});

			progressHandlers.push(progressHandler);

			return deferred.promise;
		};

		/**
		 * Issue a progress event, notifying all progress listeners
		 * @private
		 * @param {*} update progress event payload to pass to all listeners
		 */
		_progress = function(update) {
			processQueue(progressHandlers, update);
			return update;
		};

		/**
		 * Transition from pre-resolution state to post-resolution state, notifying
		 * all listeners of the resolution or rejection
		 * @private
		 * @param {*} value the value of this deferred
		 */
		_resolve = function(value) {
			value = resolve(value);

			// Replace _then with one that directly notifies with the result.
			_then = value.then;
			// Replace _resolve so that this Deferred can only be resolved once
			_resolve = resolve;
			// Make _progress a noop, to disallow progress for the resolved promise.
			_progress = noop;

			// Notify handlers
			processQueue(handlers, value);

			// Free progressHandlers array since we'll never issue progress events
			progressHandlers = handlers = undef;

			return value;
		};

		return deferred;

		/**
		 * Wrapper to allow _then to be replaced safely
		 * @param {function?} [onFulfilled] resolution handler
		 * @param {function?} [onRejected] rejection handler
		 * @param {function?} [onProgress] progress handler
		 * @returns {Promise} new promise
		 */
		function then(onFulfilled, onRejected, onProgress) {
			// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
			return _then(onFulfilled, onRejected, onProgress);
		}

		/**
		 * Wrapper to allow _resolve to be replaced
		 */
		function promiseResolve(val) {
			return _resolve(val);
		}

		/**
		 * Wrapper to allow _reject to be replaced
		 */
		function promiseReject(err) {
			return _resolve(rejected(err));
		}

		/**
		 * Wrapper to allow _progress to be replaced
		 */
		function promiseProgress(update) {
			return _progress(update);
		}
	}

	/**
	 * Determines if promiseOrValue is a promise or not.  Uses the feature
	 * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
	 * promiseOrValue is a promise.
	 *
	 * @param {*} promiseOrValue anything
	 * @returns {boolean} true if promiseOrValue is a {@link Promise}
	 */
	function isPromise(promiseOrValue) {
		return promiseOrValue && typeof promiseOrValue.then === 'function';
	}

	/**
	 * Initiates a competitive race, returning a promise that will resolve when
	 * howMany of the supplied promisesOrValues have resolved, or will reject when
	 * it becomes impossible for howMany to resolve, for example, when
	 * (promisesOrValues.length - howMany) + 1 input promises reject.
	 *
	 * @param {Array} promisesOrValues array of anything, may contain a mix
	 *      of promises and values
	 * @param howMany {number} number of promisesOrValues to resolve
	 * @param {function?} [onFulfilled] resolution handler
	 * @param {function?} [onRejected] rejection handler
	 * @param {function?} [onProgress] progress handler
	 * @returns {Promise} promise that will resolve to an array of howMany values that
	 * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1
	 * rejection reasons.
	 */
	function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {

		checkCallbacks(2, arguments);

		return when(promisesOrValues, function(promisesOrValues) {

			var toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, progress, len, i;

			len = promisesOrValues.length >>> 0;

			toResolve = Math.max(0, Math.min(howMany, len));
			values = [];

			toReject = (len - toResolve) + 1;
			reasons = [];

			deferred = defer();

			// No items in the input, resolve immediately
			if (!toResolve) {
				deferred.resolve(values);

			} else {
				progress = deferred.progress;

				rejectOne = function(reason) {
					reasons.push(reason);
					if(!--toReject) {
						fulfillOne = rejectOne = noop;
						deferred.reject(reasons);
					}
				};

				fulfillOne = function(val) {
					// This orders the values based on promise resolution order
					// Another strategy would be to use the original position of
					// the corresponding promise.
					values.push(val);

					if (!--toResolve) {
						fulfillOne = rejectOne = noop;
						deferred.resolve(values);
					}
				};

				for(i = 0; i < len; ++i) {
					if(i in promisesOrValues) {
						when(promisesOrValues[i], fulfiller, rejecter, progress);
					}
				}
			}

			return deferred.then(onFulfilled, onRejected, onProgress);

			function rejecter(reason) {
				rejectOne(reason);
			}

			function fulfiller(val) {
				fulfillOne(val);
			}

		});
	}

	/**
	 * Initiates a competitive race, returning a promise that will resolve when
	 * any one of the supplied promisesOrValues has resolved or will reject when
	 * *all* promisesOrValues have rejected.
	 *
	 * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param {function?} [onFulfilled] resolution handler
	 * @param {function?} [onRejected] rejection handler
	 * @param {function?} [onProgress] progress handler
	 * @returns {Promise} promise that will resolve to the value that resolved first, or
	 * will reject with an array of all rejected inputs.
	 */
	function any(promisesOrValues, onFulfilled, onRejected, onProgress) {

		function unwrapSingleResult(val) {
			return onFulfilled ? onFulfilled(val[0]) : val[0];
		}

		return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);
	}

	/**
	 * Return a promise that will resolve only once all the supplied promisesOrValues
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the promisesOrValues.
	 * @memberOf when
	 *
	 * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param {function?} [onFulfilled] resolution handler
	 * @param {function?} [onRejected] rejection handler
	 * @param {function?} [onProgress] progress handler
	 * @returns {Promise}
	 */
	function all(promisesOrValues, onFulfilled, onRejected, onProgress) {
		checkCallbacks(1, arguments);
		return map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Joins multiple promises into a single returned promise.
	 * @returns {Promise} a promise that will fulfill when *all* the input promises
	 * have fulfilled, or will reject when *any one* of the input promises rejects.
	 */
	function join(/* ...promises */) {
		return map(arguments, identity);
	}

	/**
	 * Traditional map function, similar to `Array.prototype.map()`, but allows
	 * input to contain {@link Promise}s and/or values, and mapFunc may return
	 * either a value or a {@link Promise}
	 *
	 * @param {Array|Promise} promise array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param {function} mapFunc mapping function mapFunc(value) which may return
	 *      either a {@link Promise} or value
	 * @returns {Promise} a {@link Promise} that will resolve to an array containing
	 *      the mapped output values.
	 */
	function map(promise, mapFunc) {
		return when(promise, function(array) {
			var results, len, toResolve, resolve, i, d;

			// Since we know the resulting length, we can preallocate the results
			// array to avoid array expansions.
			toResolve = len = array.length >>> 0;
			results = [];
			d = defer();

			if(!toResolve) {
				d.resolve(results);
			} else {

				resolve = function resolveOne(item, i) {
					when(item, mapFunc).then(function(mapped) {
						results[i] = mapped;

						if(!--toResolve) {
							d.resolve(results);
						}
					}, d.reject);
				};

				// Since mapFunc may be async, get all invocations of it into flight
				for(i = 0; i < len; i++) {
					if(i in array) {
						resolve(array[i], i);
					} else {
						--toResolve;
					}
				}

			}

			return d.promise;

		});
	}

	/**
	 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
	 * input may contain promises and/or values, and reduceFunc
	 * may return either a value or a promise, *and* initialValue may
	 * be a promise for the starting value.
	 *
	 * @param {Array|Promise} promise array or promise for an array of anything,
	 *      may contain a mix of promises and values.
	 * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),
	 *      where total is the total number of items being reduced, and will be the same
	 *      in each call to reduceFunc.
	 * @returns {Promise} that will resolve to the final reduced value
	 */
	function reduce(promise, reduceFunc /*, initialValue */) {
		var args = slice.call(arguments, 1);

		return when(promise, function(array) {
			var total;

			total = array.length;

			// Wrap the supplied reduceFunc with one that handles promises and then
			// delegates to the supplied.
			args[0] = function (current, val, i) {
				return when(current, function (c) {
					return when(val, function (value) {
						return reduceFunc(c, value, i, total);
					});
				});
			};

			return reduceArray.apply(array, args);
		});
	}

	/**
	 * Ensure that resolution of promiseOrValue will trigger resolver with the
	 * value or reason of promiseOrValue, or instead with resolveValue if it is provided.
	 *
	 * @param promiseOrValue
	 * @param {Object} resolver
	 * @param {function} resolver.resolve
	 * @param {function} resolver.reject
	 * @param {*} [resolveValue]
	 * @returns {Promise}
	 */
	function chain(promiseOrValue, resolver, resolveValue) {
		var useResolveValue = arguments.length > 2;

		return when(promiseOrValue,
			function(val) {
				val = useResolveValue ? resolveValue : val;
				resolver.resolve(val);
				return val;
			},
			function(reason) {
				resolver.reject(reason);
				return rejected(reason);
			},
			resolver.progress
		);
	}

	//
	// Utility functions
	//

	/**
	 * Apply all functions in queue to value
	 * @param {Array} queue array of functions to execute
	 * @param {*} value argument passed to each function
	 */
	function processQueue(queue, value) {
		var handler, i = 0;

		while (handler = queue[i++]) {
			handler(value);
		}
	}

	/**
	 * Helper that checks arrayOfCallbacks to ensure that each element is either
	 * a function, or null or undefined.
	 * @private
	 * @param {number} start index at which to start checking items in arrayOfCallbacks
	 * @param {Array} arrayOfCallbacks array to check
	 * @throws {Error} if any element of arrayOfCallbacks is something other than
	 * a functions, null, or undefined.
	 */
	function checkCallbacks(start, arrayOfCallbacks) {
		// TODO: Promises/A+ update type checking and docs
		var arg, i = arrayOfCallbacks.length;

		while(i > start) {
			arg = arrayOfCallbacks[--i];

			if (arg != null && typeof arg != 'function') {
				throw new Error('arg '+i+' must be a function');
			}
		}
	}

	/**
	 * No-Op function used in method replacement
	 * @private
	 */
	function noop() {}

	slice = [].slice;

	// ES5 reduce implementation if native not available
	// See: http://es5.github.com/#x15.4.4.21 as there are many
	// specifics and edge cases.
	reduceArray = [].reduce ||
		function(reduceFunc /*, initialValue */) {
			/*jshint maxcomplexity: 7*/

			// ES5 dictates that reduce.length === 1

			// This implementation deviates from ES5 spec in the following ways:
			// 1. It does not check if reduceFunc is a Callable

			var arr, args, reduced, len, i;

			i = 0;
			// This generates a jshint warning, despite being valid
			// "Missing 'new' prefix when invoking a constructor."
			// See https://github.com/jshint/jshint/issues/392
			arr = Object(this);
			len = arr.length >>> 0;
			args = arguments;

			// If no initialValue, use first item of array (we know length !== 0 here)
			// and adjust i to start at second item
			if(args.length <= 1) {
				// Skip to the first real element in the array
				for(;;) {
					if(i in arr) {
						reduced = arr[i++];
						break;
					}

					// If we reached the end of the array without finding any real
					// elements, it's a TypeError
					if(++i >= len) {
						throw new TypeError();
					}
				}
			} else {
				// If initialValue provided, use it
				reduced = args[1];
			}

			// Do the actual reduce
			for(;i < len; ++i) {
				// Skip holes
				if(i in arr) {
					reduced = reduceFunc(reduced, arr[i], i, arr);
				}
			}

			return reduced;
		};

	function identity(x) {
		return x;
	}

	return when;
});
})(typeof define == 'function' && define.amd
	? define
	: function (factory) { typeof exports === 'object'
		? (module.exports = factory())
		: (this.when      = factory());
	}
	// Boilerplate for AMD, Node, and browser global
);
/**
 * Creates a provider for panoramic images
 * @class Manage the panoramic provider (url, request)
 * @author alexandre devaux IGN
 * @requires ThreeJS
 * 
 */ 
 define ('PanoramicProvider',['lib/three', 'Utils', 'Config', 'jquery', 'lib/when'], function ( THREE, Utils, Config, $, when) {
    
        
    var _urlMetaDataProviderPos = "",
        _urlMetaDataProviderName = "",
        _urlImageFile = "",
        _urlMetaProviderSensor = "",
        _currentMetaData = null,
        _localModeProviderPos = false,
        _localImages = false,
        _localPanoramicsMetaData = null,
        _localModeProviderSensor = false;
    
    
    var PanoramicProvider =  {

        init: function(dataURL){
            
            _urlMetaDataProviderPos  = dataURL.urlMetaDataProviderPos  ||  Config.dataURL.defaultUrlMetaDataProviderPos;
            _urlMetaDataProviderName = dataURL.urlMetaDataProviderName ||  Config.dataURL.defaultUrlMetaDataProviderName;
            _urlImageFile            = dataURL.urlImageFile            ||  Config.dataURL.defaultUrlImageFile;
            _urlMetaProviderSensor   = dataURL.urlMetaProviderSensor   ||  Config.dataURL.defaultUrlMetaProviderSensor;
            
            _localModeProviderPos    = _urlMetaDataProviderPos.indexOf("php") < 0;
            _localImages             = _urlImageFile.indexOf("www") < 0;
            _localModeProviderSensor = _urlMetaProviderSensor.indexOf("php") < 0;
        },
        
 
        
        getMetaDataPHPFromPosRequest: function(easting, northing, distance){
            
            return _urlMetaDataProviderPos + "easting=" + easting +
                     "&northing=" + northing + "&distneighbours=" + distance;
             
        },
        
        
        getMetaDataPHPFromPosJSON: function(easting, northing, distance){
            
            var request = this.getMetaDataPHPFromPosRequest(easting, northing, distance);
            $.getJSON( request, function( data ) {
                _currentMetaData = data[0];  // We get the first (and only pano)
                return _currentMetaData;
            });
           
        },
        
        
        
        
        getMetaDataFromPos: function(easting, northing, distance){
            
            if(!_localModeProviderPos){
                var requestURL = this.getMetaDataPHPFromPosRequest(easting, northing, distance);

                return new Promise(function(resolve, reject) {

                  var req = new XMLHttpRequest();
                  req.open('GET', requestURL);

                  req.onload = function() {

                        if (req.status === 200) {
                          resolve(JSON.parse(req.response));//req.response);
                        }
                        else {
                          reject(Error(req.statusText));
                        }
                  };

                  req.onerror = function() {
                        reject(Error("Network Error"));
                  };

                  req.send();
                });
            }
            else{
                  
                if(_localPanoramicsMetaData === null){      // Local mode and not yet loaded
                  
                    var requestURL = _urlMetaDataProviderPos;    // local file/JSON
                    return new Promise(function(resolve, reject) {

                      var req = new XMLHttpRequest();
                      req.open('GET', requestURL);

                      req.onload = function() {

                            if (req.status === 200) {
                                
                                _localPanoramicsMetaData = JSON.parse(req.response);
                                var closestPano = PanoramicProvider.getClosestPanoInMemory(easting, northing, distance);
                                resolve(closestPano);
                            }
                            else {
                              reject(Error(req.statusText));
                            }
                      };

                      req.onerror = function() {
                            reject(Error("Network Error"));
                      };

                      req.send();
                    });
                    
                    }else{          // Trajectory file already loaded
                        
                         var closestPano = PanoramicProvider.getClosestPanoInMemory(easting, northing, distance);
                         return new Promise(function(resolve, reject) {resolve(closestPano);});
                    }
                
            }
        },
        
        // USING MEMORISED TAB or JSON ORI
        getClosestPanoInMemory: function(easting, northing, distance){
            
            var indiceClosest = 0;
            var distMin = 99999;
            for (var i=0; i< _localPanoramicsMetaData.length; ++i){
                
                var p = _localPanoramicsMetaData[i];
                var dist = Math.sqrt( (p.easting - easting) * (p.easting - easting) + (p.northing - northing) * (p.northing - northing) );
                if(dist< distMin) {indiceClosest = i; distMin = dist;}
            }
            return [_localPanoramicsMetaData[indiceClosest]];
        },
        
        
        getUrlImageFile: function(){
            
            return _urlImageFile;
        },
        
        getImageLocal: function(){
          
            return _localImages;
        },
        
        // Return the full request depending if local mode or Database
        getMetaDataSensorURL: function(idChantier){
            
            var urlRequest = ""
            if(_localModeProviderSensor)
                urlRequest = _urlMetaProviderSensor;
            else
                urlRequest = _urlMetaProviderSensor+"?idChantier="+idChantier;
            
            return urlRequest;
        },
        
        getLocalModeProviderSensor: function(){
            
            return _localModeProviderSensor;
        }
        
    };
    return PanoramicProvider;

});

/**
* 
* @author AD IGN
* Class where we get the Extrinseque and Intrinseque parameters of the system. Camera (laser soon).
* Next we will dynamically load configuration from server in case of changes
* @Depends Sensor.js
*/

define ('Ori',['GraphicEngine','lib/three','Utils','Sensor','jquery', 'Config', 'PanoramicProvider'],
function (graphicEngine, THREE, Utils, Sensor, $, Config, PanoramicProvider) {

    // Extrinseque Parameters
     var _MatCam21,   // Orientation matrices for camera, relatif
         _MatCam22,
         _MatCam23,
         _MatCam31,
         _MatCam32,
         _MatCam33,
         _MatCam34,
         _MatCam41,
         _MatCam42,
         _MatCam43,

         // Camera V2
         _MatCam300,
         _MatCam301,
         _MatCam302,
         _MatCam303,
         _MatCam304,
         
         // Som cam V1
         _SomCam21,
         _SomCam22,
         _SomCam23,
         _SomCam31,
         _SomCam32,
         _SomCam33,
         _SomCam34,
         _SomCam41,
         _SomCam42,
         _SomCam43,
     
        // Som cam V2
         _SomCam300,
         _SomCam301,
         _SomCam302,
         _SomCam303,
         _SomCam304,
     
     
     
         // TEMP Camera V1_2
         _MatCam312,
         _MatCam322,
         _MatCam332,
         _MatCam342,

     
         _cam21,   // Orientation matrices for camera, relatif
         _cam22,
         _cam23,
         _cam31,
         _cam32,
         _cam33,
         _cam34,
         _cam41,
         _cam42,
         _cam43,
         
         // TEMP Camera V1_2
         _cam312,
         _cam322,
         _cam332,
         _cam342,
         
         
         // Camera V2
         _cam300,
         _cam301,
         _cam302,
         _cam303,
         _cam304,
 
 
        //Distortion
        _r3_300 = -1.33791587603751819e-07,
        _r5_300 =  3.47540977328314388e-14,
        _r7_300 = -4.44103985918888078e-21,
        _r3_301 = -1.40358671178762456e-07,
        _r5_301 =  3.68704437301178485e-14,
        _r7_301 = -4.70823660788942483e-21,
        _r3_302 = -1.42783482918368782e-07,
        _r5_302 =  3.82282620491304991e-14 ,
        _r7_302 = -5.00364549921599885e-21,
        _r3_303 = -1.43584241381542442e-07,
        _r5_303 =  3.85479524108064982e-14 ,
        _r7_303 = -5.0301787584825994e-21,
        //  r3_304:{type:'f',value: -1.4331013261463578e-07},
        //  r5_304:{type:'f',value:3.77792882615437153e-14},
        //  r7_304:{type:'f',value:-4.83479389959883182e-21},
        //Test ac disto des ori.xml
        _r3_304 = -1.43882500e-007,
        _r5_304 =  3.68830500e-014,
        _r7_304 = -4.51909300e-021;
     
     
     
         // MATRIX TO GO FROM APPLANIX REF TO ITOWNS REF. ***********************
        
                                        
        var _itownsWay =    new THREE.Matrix4( 0, 1, 0, 0,
                                               0, 0,-1, 0,
                                               1, 0, 0, 0,
                                               0, 0, 0, 1 );
                                           
        var Photogram_JMM    = new THREE.Matrix4( 0, 0,-1, 0,
                                                 -1, 0, 0, 0,
                                                  0, 1, 0, 0,
                                                  0, 0, 0, 1);
                                               
        var photgramme_image = new THREE.Matrix4( 1, 0, 0, 0,
                                                  0,-1, 0, 0,
                                                  0, 0,-1, 0,
                                                  0, 0, 0, 1);

        
      // Intrinseque parameters
   
      var arrayCam = [];  // Contains all the cameras
      var arraySensors = []; // Contains all the sensors

      var Ori = {
           
          initiated:false, 
                 
          init: function(){
              
               // NOT YET FULLY USED!
               this.getAllSensorsInfosDBForChantier(1);  // We get info for all sensors from DB
              
               this.getAllMobileMatrices();  // From mobile file
               this.setAllMobileMatricesToItownsRef(); // To itownsREF
               
               this.getAllMobileSommet();    // From mobile file
               this.setAllMobileSommetToItownsRef(); // To itownsREF
               
          },
          
          
          // We get info for all sensors from DB
          getAllSensorsInfosDBForChantier: function(idChantier){

                var that = this;

                $.getJSON(PanoramicProvider.getMetaDataSensorURL(idChantier), function (data){
                           that.handleDBData(data);
                });
                
                /*
                $.getJSON(PanoramicProvider.getMetaDataSensorURL()+"?idChantier="+idChantier, function (data){
                           that.handleDBData(data);
                });
            */
           },


          // Create the cameras from the infos took in the DB, JSON
          // Transform all coordinates in itowns ref
          // Fill the array of Sensors
          
          handleDBData :function(data){

                arrayCam = data;
                for (var i =0; i< data.length; ++i){  // For all DB sens info we create sensor object
                    
                    var s = new Sensor(arrayCam[i]);
                    s.setMatrix(); //Utils.outputMatrix4(s.mat3d);
                    s.setSommet();
                    this.setMatOrientationTotalItownsRef(s);  // Change sensor matrix to iTowns Ref
                    this.setSommetToItownsRef(s);       // Change sensor sommet to iTowns Ref
                    arraySensors.push(s);
                }
                
                this.initiated = true;
                console.log('Orientation module is loaded');

           },

                   
        // Change the matrix of the sensor to itownsRef passing
        // through TS transformation first
        setMatOrientationTotalItownsRef: function(s){

          var out = s.mat3d.clone(); 
          out = new THREE.Matrix4().multiplyMatrices( out.clone(), Photogram_JMM.clone() ); 
          out = new THREE.Matrix4().multiplyMatrices( out.clone(), this.getMatOrientationCapteur(s.infos.cam_orientation));
          out = new THREE.Matrix4().multiplyMatrices( out.clone(), photgramme_image.clone());

          out = new THREE.Matrix4().multiplyMatrices(_itownsWay, out.clone());

          s.mat3d = out;


        },


          // Change sommet coordinate from applanix repere to itowns
          // Xapplan -> Zitowns , Yapplan -> xitowns , Zapplan -> -Y itowns
          // -> matrice projCoord  
          setSommetToItownsRef: function(sensor){

              var projCoord = _itownsWay;
          // THEN in itowns coordinates
              sensor.sommet.applyProjection(projCoord);
          },


         // Global orientation matrix of the vehicule
         // Warning: heading pitch roll not all in right side in itowns ref
         // Pitch and Roll are in opposite
          computeMatOriFromHeadingPitchRoll: function(heading,pitch,roll){
              
              //  console.log(heading,pitch,roll);
                heading = parseFloat(heading) / 180 * Math.PI;  // Deg to Rad // Axe Y
                pitch = parseFloat(pitch)/ 180 * Math.PI;  // Deg to Rad // axe X
                roll = parseFloat(roll)/ 180 * Math.PI;  // Deg to Rad   // axe Z
        /*        var matRotationHead  = new THREE.Matrix4(); 
                var matRotationPitch = new THREE.Matrix4(); 
                var matRotationRoll  = new THREE.Matrix4(); 
                
                matRotationHead = Utils.rotateY( matRotationHead, heading).transpose();
                console.log("matrotationHead");
                Utils.outputMatrix4(matRotationHead);
                matRotationPitch = Utils.rotateX( matRotationPitch, pitch).transpose();
                matRotationRoll = Utils.rotateZ( matRotationRoll, roll).transpose();  // Pitch should be for x
             
             
                var mat1 =  new THREE.Matrix4().multiplyMatrices(matRotationPitch,matRotationRoll );
                console.log("mat1");
                Utils.outputMatrix4(mat1);
                var mat2 = new THREE.Matrix4().multiplyMatrices( matRotationHead,mat1);
                
                console.log("mat2");
                Utils.outputMatrix4(mat2);
                
          */      
                // With quaternion  //set rotation.order to "YXZ", which is equivalent to "heading, pitch, and roll"
                var q = new THREE.Quaternion();
                q.setFromEuler(new THREE.Euler(-pitch,heading,-roll,'YXZ'),true);
                var matTotale = new THREE.Matrix4().makeRotationFromQuaternion(q);//qRoll);//quater);
                //console.log('quater',qRoll);
                return matTotale;//.transpose(); //mat2 //matRotation;
          },
          

          

          // Global orientation matrix of the vehicule
          computeMatOriFromHeadingPitchRollSAVE: function(heading,pitch,roll){
              
                console.log(heading,pitch,roll);
                heading = parseFloat(heading) / 180 * Math.PI;  // Deg to Rad 
                pitch = parseFloat(pitch)/ 180 * Math.PI;  // Deg to Rad
                roll = parseFloat(roll)/ 180 * Math.PI;  // Deg to Rad
                var matRotation = new THREE.Matrix4(); 
                matRotation = Utils.rotateY( matRotation, -heading);
                matRotation = Utils.rotateX( matRotation, pitch);
                matRotation = Utils.rotateZ( matRotation, -roll);  // Pitch should be for x

                return matRotation;
          },
          
          
          
          // return matrix4 of projection using ppa focale etc
          getProjCam: function(num){
              
              
            var proj300 = new THREE.Matrix4(  1150.66785706630299,	0,	0.,	0.,
                                           0.,       1150.66785706630299,	0.,	0.,
                                           1030.29197487242254,  1023.03935469545331,	0.,	1.,
                                           0.,          0.,     0.,	0.);
                                           
            var proj301 = new THREE.Matrix4(  1134.10249915110944,	0,	0.,	0.,
                                           0.,         1134.10249915110944,	0.,	0.,
                                           1036.59553362753832,  1020.60367439771176,	0.,	1.,
                                           0.,          0.,     0.,	0.);
                                           
            var proj302 = new THREE.Matrix4(  1129.96581598065382,	0,	0.,	0.,
                                           0.,       1129.96581598065382,	0.,	0.,
                                           1044.51004790981142, 1023.12591368801895,	0.,	1.,
                                           0.,          0.,     0.,	0.);
                                           
            var proj303 = new THREE.Matrix4(1128.12363890680899,	0,	0.,	0.,
                                           0.,       1128.12363890680899,	0.,	0.,
                                           1027.81789269340265,  1024.17550959203095,	0.,	1.,
                                           0.,          0.,     0.,	0.);
       
           /*   
            var proj304 = new THREE.Matrix4(1128.70551522705205,	0,	0.,	0.,
                                           0.,       1128.70551522705205,	0.,	0.,
                                           1037.71094725878015,  1032.63268273716631,	0.,	1.,
                                           0.,          0.,     0.,	0.);                               
*/
          
              // Test ac la meme calib que celle des ori.xml
              var proj304 = new THREE.Matrix4(1125.964,	0,	0.,	0.,
                                           0.,       1125.964,	0.,	0.,
                                           1036.693,  1036.004,	0.,	1.,
                                           0.,          0.,     0.,	0.);                           

            switch(num){

                case 300: return proj300; 
                case 301: return proj301;
                case 302: return proj302; 
                case 303: return proj303; 
                case 304: return proj304; 
            }                              

         
              
              
          },
          
          
          
          
          // return 3rd degree polynomes for 5 cameras in order 3 cam0, 3 cam 1....
          getAllDistortionsPolynomes: function(){
             
             return [_r3_300,
                     _r5_300,
                     _r7_300,
                     _r3_301,
                     _r5_301,
                     _r7_301,
                     _r3_302,
                     _r5_302,
                     _r7_302,
                     _r3_303,
                     _r5_303,
                     _r7_303,
                     _r3_304,
                     _r5_304,
                     _r7_304];
          },
          
               
          // return 3rd degree polynomes for camera number in parameter
          getDistortionsPolynomesForCam: function(camNum){
              
              var arrAll = this.getAllDistortionsPolynomes();
              
              switch(camNum){

                case 300: return arrAll.slice(0,3); break;
                case 301: return arrAll.slice(3,6); break;
                case 302: return arrAll.slice(6,9); break;
                case 303: return arrAll.slice(9,12); break;
                case 304: return arrAll.slice(12,15);  break;
            }                              

          },
          
            
        getDistortion_r2max: function(distortion){
            // returned the square of the smallest positive root of the derivativeof the distortion polynomial
            // which tells where the distortion might no longer be bijective.
            var roots = Utils.cardan_cubic_roots(7*distortion[2],5*distortion[1],3*distortion[0],1);
            var imax=-1;
                for (var i in roots)
                    if(roots[i]>0 && (imax==-1 || roots[imax]>roots[i])) imax = i;
            if(imax==-1) return Infinity; // no roots : all is valid !
            return roots[imax];
        },
        
        
        //return vec4(r3_30i,r5_30i,r7_30i, r2maxi);
        getDistortionAndR2ForCamAsArray: function(numCam){
            
            var arrDistortion = this.getDistortionsPolynomesForCam(numCam);
            var r2max = this.getDistortion_r2max(arrDistortion);
            arrDistortion.push(r2max);
 
            return arrDistortion;
            
        },
        
         getDistortionAndR2ForCamAsVec4: function(numCam){
             
             var arrDistortion = this.getDistortionsPolynomesForCam(numCam);
             var r2max = this.getDistortion_r2max(arrDistortion);
             
             return new THREE.Vector4(arrDistortion[0],arrDistortion[1],arrDistortion[2],r2max);
         },
        
        // Return an array containing all distortions parameters and max for all cam
        // [_r3_300,_r5_300,_r7_300,r2max300,_r3_301,_r5_301,_r7_301,r2max301,...]
        getArrayDistortionAndR2AllCam: function(){
            
            var arrAll = [];
            arrAll.push.apply(arrAll, this.getDistortionAndR2ForCamAsArray(300));
            arrAll.push.apply(arrAll, this.getDistortionAndR2ForCamAsArray(301));
            arrAll.push.apply(arrAll, this.getDistortionAndR2ForCamAsArray(302));
            arrAll.push.apply(arrAll, this.getDistortionAndR2ForCamAsArray(303));
            arrAll.push.apply(arrAll, this.getDistortionAndR2ForCamAsArray(304));
          
            console.log('arrALL',arrAll);
            return arrAll;
        },
        
        

          
          
          getAllMobileMatrices: function(){

            this.getMatricesMobileV1();
            this.getMatricesMobileV2();
          },
          
          
          
          
          getMatricesMobileV1: function(){
              
           _MatCam21  = new THREE.Matrix4
            (
                0.614489, -0.788913, -0.00449825,0,
                -0.788923, -0.614463,-0.00589333,0,
                0.00188532, 0.00717016, -0.999973 , 0,
                0, 0, 0, 1
            );

            _MatCam22 = new THREE.Matrix4
            (
                0.999984, 0.00328995, -0.00458741, 0, 
                0.00326778, -0.999983, -0.00483175, 0, 
                -0.00460323, 0.00481668, -0.999978, 0, 
                0, 0, 0, 1 
            );

            _MatCam23 = new THREE.Matrix4
            (
                0.613172, 0.789904, -0.00852646,0,
                0.789948, -0.613109 , 0.00896955,0,
                0.00185743,-0.0122353, -0.999923,0,
                0, 0, 0, 1
            );

            _MatCam31 = new THREE.Matrix4
            (
                0.00534745, -0.999975, 0.00473252, 0,
                -0.987799, -0.00601883, -0.155619, 0,
               0.155643, -0.00384262, -0.987806,0,
                0, 0, 0, 1
            );


            _MatCam32 = new THREE.Matrix4
            ( 
                -0.00135681,-0.999999, -0.000100121,0, 
                -0.57632, 0.000700137, 0.817224 ,0,
               -0.817223, 0.00116652, -0.576321, 0, 
                0, 0, 0, 1
            );

            _MatCam33 = new THREE.Matrix4
            ( 
                 -0.00610257, 0.999981, -0.00117247, 0,
                0.568903, 0.00250758, -0.822401 ,	0,
               -0.822382 , -0.00568578, -0.568908, 0,
                0, 0, 0, 1
            );

            _MatCam34 = new THREE.Matrix4
            (
               -0.00545058 , 0.999915,  -0.0118055,0,
                0.988839 , 0.00714723,  0.148818, 0,
                0.14889, -0.0108626, -0.988794, 0,
                0, 0, 0, 1
            );	

            _MatCam41 = new THREE.Matrix4
            (
                -0.61311,  -0.789988, 0.00390962, 0,
               -0.789998,  0.613097,-0.00391649, 0,
                0.000696999, -0.00548983,-0.999985, 0,
                0, 0, 0, 1
            );	

            _MatCam42 = new THREE.Matrix4
            ( 
                -0.999994, -0.00278512,-0.00215781 ,0,
                -0.00276952 , 0.99997, -0.00720311, 0,
                0.0021778 , -0.00719709, -0.999972, 0,
                0, 0, 0, 1
            );														 

            _MatCam43 = new THREE.Matrix4
            (
                -0.615967, 0.787764, -0.00357732, 0,
                0.787772, 0.615965, -0.00180358 , 0,
                0.000782711, -0.00392906, -0.999992,0,
                0, 0, 0, 1
            );
            
           // console.log("_MatCam22",_MatCam22);
           // Utils.outputMatrix4(_MatCam22);
       /*         
         _MatCam312 = new THREE.Matrix4().multiplyMatrices(_MatCam31, this.getMatOrientationCapteur(1));
         _MatCam322 = new THREE.Matrix4().multiplyMatrices(_MatCam32, matRotationCam180degZ);
         _MatCam332 = new THREE.Matrix4().multiplyMatrices(_MatCam33, matRotationCam180degZ);
         _MatCam342 = new THREE.Matrix4().multiplyMatrices(_MatCam34, matRotationCam180degZ);
    */
        },
        
       
        // TEST en dur Matrice BC
        getMatricesMobileV2: function(){

           _MatCam300  = new THREE.Matrix4  // looking up the sky
            (   
                0.000735648, 0.999998  ,0.00205156 , 0,
                -0.00148884 ,0.00205265 , -0.999997, 0,
                -0.999999 ,0.000732591 , 0.00149035 , 0,
                0, 0, 0, 1
            );

            _MatCam301 = new THREE.Matrix4  // Axe truck direction
            (
                0.999983 , 0.0057386 , -0.000383448 , 0, 
                0.00573631 , -0.999967 , -0.00572726 , 0, 
                -0.000416302 , 0.00572497 , -0.999984 , 0, 
                0, 0, 0, 1 
            );

            _MatCam302 = new THREE.Matrix4
            (
                -0.000880418 , -0.999978 , -0.00663636 , 0,
                -0.999989 , 0.0008499 , 0.00460009 , 0,
                -0.00459435 , 0.00664034 , -0.999967 , 0,
                 0, 0, 0, 1
            );

            _MatCam303 = new THREE.Matrix4
            (
                -0.999997 , -0.000499298 , 0.00238871, 0,
                -0.000490943 , 0.999994 , 0.00349722 , 0,
                -0.00239044 , 0.00349604 ,-0.999991 , 0,
                0, 0, 0, 1
            );


            _MatCam304 = new THREE.Matrix4
            ( 
                0.00374348 , 0.999979 ,-0.0053097 , 0,
                0.999988 , -0.00375951 , -0.00301241 , 0,
                -0.0030323 ,-0.00529837 , -0.999981 , 0,
                0, 0, 0, 1
            );
 
        },
       
    
        // 4 different ori of the capteur
        getMatOrientationCapteur: function(numOri){
         
            var ori0 = new THREE.Matrix4( 0,-1, 0, 0,
                                          1, 0, 0, 0,
                                          0, 0, 1, 0,
                                          0, 0, 0, 1);


            var ori1 = new THREE.Matrix4( 0, 1, 0, 0,
                                         -1, 0, 0, 0,
                                          0, 0, 1, 0,
                                          0, 0, 0, 1);


            var ori2 = new THREE.Matrix4(-1, 0, 0, 0,
                                          0,-1, 0, 0,
                                          0, 0, 1, 0,
                                          0, 0, 0, 1);


            var ori3 = new THREE.Matrix4( 1, 0, 0, 0,
                                          0, 1, 0, 0,
                                          0, 0, 1, 0,
                                          0, 0, 0, 1);

            switch(numOri){

                case 0: return ori0;
                case 1: return ori1;
                case 2: return ori2; 
                case 3: return ori3; 
            }                              

         
       },
     
     
        getAllMobileSommet: function(){
            
           this.getMobileSommetV1();
           this.getMobileSommetV2();
           
        },
        
         
        getMobileSommetV1: function(){
             
            _SomCam21 = new THREE.Vector3( -0.0602755,  -0.0957625 , -0.716335);
            _SomCam22 = new THREE.Vector3( -0.0149244 , -6.96779e-05, -0.717489);
            _SomCam23 = new THREE.Vector3( -0.0603178 , 0.0956123, -0.716402);
            _SomCam31 = new THREE.Vector3( -0.144275 , -0.193849,-0.642124);
            _SomCam32 = new THREE.Vector3( -0.142364, -0.175058, -0.814522);
            _SomCam33 = new THREE.Vector3( -0.143022 , 0.172639,-0.816821);
            _SomCam34 = new THREE.Vector3( -0.144903  , 0.195569, -0.642232);
            _SomCam41 = new THREE.Vector3( -0.228293 , -0.0954342, -0.717044);
            _SomCam42 = new THREE.Vector3( -0.271697 , 0.000427889, -0.717008);
            _SomCam43 = new THREE.Vector3( -0.227154 , 0.0962825, -0.716681 );
             
        },
             
        getMobileSommetV2: function(){
            
            // Get from Mobile for a specific chantier (in DB Soon)
            _SomCam300 = new THREE.Vector3(-0.145711, -0.0008142, -0.867);
            _SomCam301 = new THREE.Vector3(-0.0449668, 0.0620361, -0.865681);
            _SomCam302 = new THREE.Vector3(-0.0856818, -0.102837, -0.866901);
            _SomCam303 = new THREE.Vector3(-0.248471, -0.060197, -0.865218);
        //    _SomCam304 = new THREE.Vector3(-0.207387, 0.0996596, -0.863219);
        // Temp with values like ori.xml from mobile not micmac
        _SomCam304 = new THREE.Vector3(-0.20684,0.10192,-0.86520);
      //  _SomCam304 = new THREE.Vector3(-0.10192,0.86520,0.20684); // As it should be after projection

        },
        
        
        // Change sommet coordinate from applanix repere to itowns
        // Xapplan -> Zitowns , Yapplan -> xitowns , Zapplan -> -Y itowns
        // -> matrice projCoord  
        setAllMobileSommetToItownsRef: function(){
            
            var projCoord = _itownsWay;
       
        // THEN in itowns coordinates
        // OLD is the combination of _itownsWay * coord * rotYPI
            _SomCam300 = _SomCam300.applyProjection(projCoord);
            _SomCam301 = _SomCam301.applyProjection(projCoord);
            _SomCam302 = _SomCam302.applyProjection(projCoord);
            _SomCam303 = _SomCam303.applyProjection(projCoord);
            _SomCam304 = _SomCam304.applyProjection(projCoord);
     /*    
         this.applyItownsProjection(_SomCam300);
         this.applyItownsProjection(_SomCam301);
         this.applyItownsProjection(_SomCam302);
         this.applyItownsProjection(_SomCam303);*/
         //   this.applyItownsProjection(_SomCam304);
         //   _SomCam304 = this.applyItownsProjectionTSAndItowns(_SomCam304,2);
            console.log('_SomCam304 after project: ',_SomCam304);
            
            _SomCam21 = _SomCam21.applyProjection(projCoord);
            _SomCam22 = _SomCam22.applyProjection(projCoord);
            _SomCam23 = _SomCam23.applyProjection(projCoord);
            _SomCam31 = _SomCam31.applyProjection(projCoord);
            _SomCam32 = _SomCam32.applyProjection(projCoord);
            _SomCam33 = _SomCam33.applyProjection(projCoord);
            _SomCam34 = _SomCam34.applyProjection(projCoord);
            _SomCam41 = _SomCam41.applyProjection(projCoord);
            _SomCam42 = _SomCam42.applyProjection(projCoord);
            _SomCam43 = _SomCam43.applyProjection(projCoord);
            
        },
        
        
        //Temp
        applyItownsProjection: function(v3){
            
            var x = v3.x;
            var y = v3.y;
            var z = v3.z;
            
            v3.x =  y;
            v3.y = -z;
            v3.z =  x;    
            
        },
        
        
        //Temp
        applyItownsProjectionTSAndItowns: function(v3,numOri){
           
          var out = new THREE.Matrix4();
       //   out = new THREE.Matrix4().multiplyMatrices( out.clone(), Photogram_JMM.clone() );
          //out = new THREE.Matrix4().multiplyMatrices( out.clone(), this.getMatOrientationCapteur(numOri).clone());
       //   out = new THREE.Matrix4().multiplyMatrices( out.clone(), photgramme_image.clone());
          out = new THREE.Matrix4().multiplyMatrices(_itownsWay, out.clone());  
          
          v3.applyProjection(out);
          return v3;
        },
        
        
        
        getBarycentreV2: function(){

            return new THREE.Vector3(
                  (_SomCam300.x+_SomCam301.x+_SomCam302.x+_SomCam303.x+_SomCam304.x)/5,
                  (_SomCam300.y+_SomCam301.y+_SomCam302.y+_SomCam303.y+_SomCam304.y)/5,
                  (_SomCam300.z+_SomCam301.z+_SomCam302.z+_SomCam303.z+_SomCam304.z)/5
              );

        },
        
         
        getBarycentreV1: function(){
            
            return new THREE.Vector3(
                  (_SomCam21.x+_SomCam22.x+_SomCam23.x+_SomCam31.x+_SomCam32.x+
                  _SomCam33.x+_SomCam34.x+_SomCam41.x+_SomCam42.x+_SomCam43.x)/10,
                 (_SomCam21.y+_SomCam22.y+_SomCam23.y+_SomCam31.y+_SomCam32.y+
                  _SomCam33.y+_SomCam34.y+_SomCam41.y+_SomCam42.y+_SomCam43.y)/10,
                 (_SomCam21.z+_SomCam22.z+_SomCam23.z+_SomCam31.z+_SomCam32.z+
                  _SomCam33.z+_SomCam34.z+_SomCam41.z+_SomCam42.z+_SomCam43.z)/10

              );

        },
        
        
        getSommet: function(num){
            
            switch(num){
                
                case 21:   return _SomCam21;     break;
                case 22:   return _SomCam22;     break;
                case 23:   return _SomCam23;     break;
                case 31:   return _SomCam31;     break;
                case 32:   return _SomCam32;     break;
                case 33:   return _SomCam33;     break;
                case 34:   return _SomCam34;     break;
                case 41:   return _SomCam41;     break;
                case 42:   return _SomCam42;     break;
                case 43:   return _SomCam43;     break;
                
                case 300:  return _SomCam300;    break;
                case 301:  return _SomCam301;    break;
                case 302:  return _SomCam302;    break;
                case 303:  return _SomCam303;    break;
                case 304:  return _SomCam304;    break;
         
            }
        },
        
       // Add the Optical coordinate of the cam in the applanix ref
       setMatriceTranslation: function(mat,num){
            
            switch(num){
                
                case 300:  mat.setPosition(new THREE.Vector3(-0.145711, -0.0008142, -0.867));    break;
                case 301:  mat.setPosition(new THREE.Vector3(-0.0449668, -0.0620361, -0.865681)); break;
                case 302:  mat.setPosition(new THREE.Vector3(-0.0856818, -0.102837, -0.866901)); break;
                case 303:  mat.setPosition(new THREE.Vector3(-0.248471, -0.060197, -0.865218));  break;
                case 304:  mat.setPosition(new THREE.Vector3(-0.207387, 0.0996596, -0.863219));  break;
            }
        },
        
        

     
      // From XStereopolisCam. Compute all the transformation to get local
      getMatOrientationTotal: function(num,numOri){

        

        // C++: m_georefRead.GetRotation() * Photogram_JMM * MatOrientationCapteur () * photgramme_image;
        var out = new THREE.Matrix4();
        
        //out = new THREE.Matrix4().multiplyMatrices( camion2eye_matrix, this.getMatCam(num).clone());
        // out = new THREE.Matrix4().multiplyMatrices( camion2eye_matrix, this.getMatCam(num).clone());
       
        var rotZ180 = new THREE.Matrix4(  0, 1, 0, 0,
                                         -1, 0, 0, 0,
                                          0, 0, 1, 0,
                                          0, 0, 0, 1);
                                          
        var rotX180 =   new THREE.Matrix4( 1, 0,  0, 0,
                                           0, -1, 0, 0,
                                           0, 0, -1, 0,
                                           0, 0,  0, 1);          
                                           
        var rotY180 =   new THREE.Matrix4( -1, 0, 0, 0,
                                           0, 1, 0, 0,
                                           0, 0, -1, 0,
                                           0, 0,  0, 1);      
                                           
                                                                                    
        var rotY90 =   new THREE.Matrix4( 0, 0, 1, 0,
                                           0, 1, 0, 0,
                                           -1, 0, 0, 0,
                                           0, 0,  0, 1);    
                                           
        var rotYM90 =   new THREE.Matrix4( 0, 0, -1, 0,
                                           0, 1, 0, 0,
                                           1, 0, 0, 0,
                                           0, 0,  0, 1);                                        
                                           
       var rotXM90 =   new THREE.Matrix4(  1, 0, 0, 0,
                                           0, 0, 1, 0,
                                           0, -1, 0, 0,
                                           0, 0,  0, 1);
                                           
       var rotX90 =   new THREE.Matrix4(   1, 0, 0, 0,
                                           0, 0, -1, 0,
                                           0, 1, 0, 0,
                                           0, 0,  0, 1); 
                                                                                      
       var rotZ90 =   new THREE.Matrix4(   0, -1, 0, 0,
                                           1, 0, 0, 0,
                                           0, 0,  1, 0,
                                           0, 0,  0, 1); 
                                           
       var rotZM90 =   new THREE.Matrix4(  0, 1, 0, 0,
                                           -1, 0, 0, 0,
                                           0, 0,  1, 0,
                                           0, 0,  0, 1); 
                                           
      var MZ =   new THREE.Matrix4(   1, 0,  0, 0,
                                      0, 1,  0, 0,
                                      0, 0, -1, 0,
                                      0, 0,  0, 1);
                                                          
                          
                          
                          
                          
        // C++: m_georefRead.GetRotation() * Photogram_JMM * MatOrientationCapteur () * photgramme_image;
        
        // We swap the Z then we do to rotation rotYM90,rotX90
         //_itownsWay = new THREE.Matrix4().multiplyMatrices(new THREE.Matrix4().multiplyMatrices(rotYM90,rotXM90),MZ);
  //var _itownsWay = new THREE.Matrix4().multiplyMatrices(new THREE.Matrix4().multiplyMatrices(rotZM90,rotX90),MZ);

  
  
      //  out = new THREE.Matrix4().multiplyMatrices(_itownsWay, this.getMatCam(num).clone());    
        out = this.getMatCam(num).clone();    
        out = new THREE.Matrix4().multiplyMatrices( out.clone(), Photogram_JMM.clone() );
        out = new THREE.Matrix4().multiplyMatrices( out.clone(), this.getMatOrientationCapteur(numOri).clone());
        out = new THREE.Matrix4().multiplyMatrices( out.clone(), photgramme_image.clone());

        out = new THREE.Matrix4().multiplyMatrices(_itownsWay, out.clone());    

    //    out = new THREE.Matrix4().multiplyMatrices( out.clone(), rotY180);   // !!!

     
        
        return out;
        
      },
      
      
      
      
      setAllMobileMatricesToItownsRef: function(){
          
                    
          //Cam V1_2
          _MatCam312 = this.getMatOrientationTotal(31,1);
          _MatCam322 = this.getMatOrientationTotal(32,1);
          _MatCam332 = this.getMatOrientationTotal(33,1);
          _MatCam342 = this.getMatOrientationTotal(34,1);
          
          //Cam V1
          _MatCam21 = this.getMatOrientationTotal(21,0);
          _MatCam22 = this.getMatOrientationTotal(22,3);
          _MatCam23 = this.getMatOrientationTotal(23,0);
          _MatCam31 = this.getMatOrientationTotal(31,0);
          _MatCam32 = this.getMatOrientationTotal(32,0);
          _MatCam33 = this.getMatOrientationTotal(33,0);
          _MatCam34 = this.getMatOrientationTotal(34,0);
          _MatCam41 = this.getMatOrientationTotal(41,0);
          _MatCam42 = this.getMatOrientationTotal(42,3);
          _MatCam43 = this.getMatOrientationTotal(43,0);

          //Cam V2
          _MatCam300 = this.getMatOrientationTotal(300,3);
          _MatCam301 = this.getMatOrientationTotal(301,2);
          _MatCam302 = this.getMatOrientationTotal(302,2);
          _MatCam303 = this.getMatOrientationTotal(303,2);
          _MatCam304 = this.getMatOrientationTotal(304,2);

      },


        getMatCam2: function(num){

            // Look in the array of sensors for element with a specific cam id position
            
            return $.grep(arraySensors, function(e){ return e.infos.cam_id_pos == num; })[0];

            },
        
        // Look in the array of sensors for element with a specific cam id position
        getSensorForCamIdPos: function(num){
            
            return $.grep(arraySensors, function(e){ return e.infos.cam_id_pos == num; })[0];
        },
        
        
         getMatCam: function(num){
            
            var mat;
            switch(num){
                
                case 21: mat = _MatCam21; break;
                case 22: mat = _MatCam22; break;
                case 23: mat = _MatCam23; break;
                case 31: mat = _MatCam31; break;
                case 32: mat = _MatCam32; break;
                case 33: mat = _MatCam33; break;
                case 34: mat = _MatCam34; break;
                case 41: mat = _MatCam41; break;
                case 42: mat = _MatCam42; break;
                case 43: mat = _MatCam43; break;
                    
                case 300: mat = _MatCam300; break;
                case 301: mat = _MatCam301; break;
                case 302: mat = _MatCam302; break;
                case 303: mat = _MatCam303; break;
                case 304: mat = _MatCam304; break;
                    
                case 312: mat = _MatCam312; break;
                case 322: mat = _MatCam322; break;
                case 332: mat = _MatCam332; break;
                case 342: mat = _MatCam342; break;
                                    
                    
            }
            return mat;
        }
        
        
        
    
    };
     
     
    return Ori
    
  }
)
         ;
define ( 'Shader',['jquery', 'Utils'],function ( $, Utils) {
		
	var Shader ={
            
            shadersURL : null,//shadersURL;
            shaderNum : null,//shadersURL.length;
            shaders : {},
            loaded: false,
            attributes : {
                    displacementx: {
                          type: 'f', // a float
                          value: [] // an empty array
                    },
                    displacementy: {
                          type: 'f', // a float	
                          value: [] // an empty array
                    },
                    displacementz: {
                          type: 'f', // a float
                          value: [] // an empty array
                    },
                    colorattribute : {
                           type: 'v3',
                           value:[]
                    },
                    uniqueid: {
                          type: 'i',
                          value:[]
                   }
               },


             uniformslaser : {
                        indice_time_laser:{type: 'f',value: 1},
                        currentidwork:{type:'f',value:100.},
                        point_size:{type:'f',value:1.},
                        alpha:{type:'f',value:0.5},
                        colortest:{type:'v3', value: {}},
                        nb_time:{type: 'i',value: 0}
             },         

             init: function(shadersURL){
                 this.shadersURL = shadersURL;
                 this.shaderNum =  shadersURL.length;
             },

             loadShaders : function() {              
                 var loadedShaders = 0;
                 var that = this;

                 function partialLoading(shaderContent, shaderName) {
                     loadedShaders++;
                     that.shaders[shaderName] = shaderContent;

                     //all shader files have been loaded
                     if (loadedShaders === that.shaderNum) {
                         that.loaded = true;
                         console.log("Shaders are loaded");
                     }
                 }

                 for (var i=0; i < that.shaderNum; i++) {
                     var currentShaderURL = that.shadersURL[i];

                     (function(currentShaderURL) {
                         $.ajax({
                             url: currentShaderURL,
                             success: function (data) {
                                 partialLoading($(data).html(),currentShaderURL.substr(currentShaderURL.lastIndexOf('/')+1));
                             },
                             dataType: 'html',
                             error: function () {
                                 console.error("Unable to load shader from file" + currentShaderURL);
                             }
                         });
                     })(currentShaderURL);
                 }
             },
             
             
             
    shaderTextureProjective2VS : [
        
        "#ifdef GL_ES",
        "precision  highp float;",
        "#endif",

        // Those uniforms are 
        // ModelView * Projection * rotation of the rigid sys (Stereopolis)

        "uniform mat4 mvpp_current_0;",
        "uniform mat4 mvpp_current_1;",
        "uniform mat4 mvpp_current_2;",
        "uniform mat4 mvpp_current_3;",
        "uniform mat4 mvpp_current_4;",
        "uniform mat4 mvpp_current_0bis;",
        "uniform mat4 mvpp_current_1bis;",
        "uniform mat4 mvpp_current_2bis;",
        "uniform mat4 mvpp_current_3bis;",
        "uniform mat4 mvpp_current_4bis;",

        "uniform vec4 factorTranslation0;",
        "uniform vec4 factorTranslation1;",
        "uniform vec4 factorTranslation2;",
        "uniform vec4 factorTranslation3;",
        "uniform vec4 factorTranslation4;",
        "uniform vec4 factorTranslation0bis;",
        "uniform vec4 factorTranslation1bis;",
        "uniform vec4 factorTranslation2bis;",
        "uniform vec4 factorTranslation3bis;",
        "uniform vec4 factorTranslation4bis;",

        "uniform int mobileOn;",

        "varying vec4 v_texcoord0;",
        "varying vec4 v_texcoord1;",
        "varying vec4 v_texcoord2;",
        "varying vec4 v_texcoord3;",
        "varying vec4 v_texcoord4;",
        "varying vec4 v_texcoord0bis;",
        "varying vec4 v_texcoord1bis;",
        "varying vec4 v_texcoord2bis;",
        "varying vec4 v_texcoord3bis;",
        "varying vec4 v_texcoord4bis;",

        "vec4 pos;",



        "void main() {",

        "    pos =  vec4(position,1.);",

        "    if(mobileOn==0){",
        "        v_texcoord0 =  mvpp_current_0 * (pos- factorTranslation0);",
        "        v_texcoord1 =  mvpp_current_1 * (pos- factorTranslation1);",
        "        v_texcoord2 =  mvpp_current_2 * (pos- factorTranslation2);",
        "        v_texcoord3 =  mvpp_current_3 * (pos- factorTranslation3);",
        "        v_texcoord4 =  mvpp_current_4 * (pos- factorTranslation4);",
        "    }",

        "    v_texcoord0bis =  mvpp_current_0bis * (pos- factorTranslation0bis);",
        "    v_texcoord1bis =  mvpp_current_1bis * (pos- factorTranslation1bis);",
        "    v_texcoord2bis =  mvpp_current_2bis * (pos- factorTranslation2bis);",
        "    v_texcoord3bis =  mvpp_current_3bis * (pos- factorTranslation3bis);",
        "    v_texcoord4bis =  mvpp_current_4bis * (pos- factorTranslation4bis);",

        "    gl_Position  =  projectionMatrix *  modelViewMatrix * pos;",

        "}"
    ],
    
     shaderTextureProjective2FS : [
         
      
        "#ifdef GL_ES",
        "precision  highp float;",
        "#endif",

        "uniform float alpha;",

        "uniform mat4 mvpp_current_0;",
        "uniform mat4 mvpp_current_1;",
        "uniform mat4 mvpp_current_2;",
        "uniform mat4 mvpp_current_3;",
        "uniform mat4 mvpp_current_4;",
        "uniform mat4 mvpp_current_0bis;",
        "uniform mat4 mvpp_current_1bis;",
        "uniform mat4 mvpp_current_2bis;",
        "uniform mat4 mvpp_current_3bis;",
        "uniform mat4 mvpp_current_4bis;",

        "uniform sampler2D   texture0;",
        "uniform sampler2D   texture1;",
        "uniform sampler2D   texture2;",
        "uniform sampler2D   texture3;",
        "uniform sampler2D   texture4;",
        "uniform sampler2D   texture0bis;",
        "uniform sampler2D   texture1bis;",
        "uniform sampler2D   texture2bis;",
        "uniform sampler2D   texture3bis;",
        "uniform sampler2D   texture4bis;",
        "uniform sampler2D   textureFrontMask;",
        "uniform sampler2D   textureBackMask;",

        "uniform vec4 factorTranslation;",	
        "uniform vec4 factorTranslationbis;",

        "varying vec4 v_texcoord0;",
        "varying vec4 v_texcoord1;",
        "varying vec4 v_texcoord2;",
        "varying vec4 v_texcoord3;",
        "varying vec4 v_texcoord4;",
        "varying vec4 v_texcoord0bis;",
        "varying vec4 v_texcoord1bis;",
        "varying vec4 v_texcoord2bis;",
        "varying vec4 v_texcoord3bis;",
        "varying vec4 v_texcoord4bis;",


        "uniform float indice_time0;",
        "uniform float indice_time1;",
        "uniform float indice_time2;",
        "uniform float indice_time3;",
        "uniform float indice_time4;",

        "uniform vec4 intrinsic300;",
        "uniform vec4 intrinsic301;",
        "uniform vec4 intrinsic302;",
        "uniform vec4 intrinsic303;",
        "uniform vec4 intrinsic304;",
        

        "uniform int blendingOn;",
        "uniform int mobileOn;",
        "uniform int fog;",

        "float width = 2048.0;",
        "float height = 2048.0;",
        "float dist;",


        // Distortion
        "float cpps = 1042.178;",
        "float lpps = 1020.435;",
        "vec2 pps = vec2(cpps,lpps);",

        "vec4 color = vec4(0.,0.,0.,0.);",
        "vec4 colorbis = vec4(0.,0.,0.,0.);",
        "vec4 saveColor = vec4(0.,0.,0.,0.);",

        "vec2 corrected0, corrected1,corrected2,corrected3,corrected4;",
        "vec2 corrected0bis, corrected1bis,corrected2bis,corrected3bis,corrected4bis;",



        // Function to correct coordinate using 3rd degree polynome and max
      " vec2 correctDistortionAndCoord(vec4 dist, vec4 v_texcoord){",
            
      "      vec2 v = v_texcoord.xy/v_texcoord.w - pps;",
      "      float v2 = dot(v,v);",
      "      if(v2>dist.w) return vec2(-2.,-2.); // false;",
      "      float r = v2*(dist.x+v2*(dist.y+v2*dist.z));",
      "      vec2 normCoord = v_texcoord.xy/(v_texcoord.w) + r*v;",
                //float r = v2*(dist.x+v2*(dist.y+v2*dist.z));
                //vec2 normCoord = v_texcoord.xy + r*v*v_texcoord.w;

      "      return vec2(normCoord.x/width , 1. - normCoord.y/height); ",

      "  }",



       " void main(void)",
       " {	",
       "     bool blending = (blendingOn == 1) && (mobileOn==0);",

            // FIRSTLY the previous position for nice transition

        "    if(mobileOn==0){    // If not on light config we compute the rendering for previous pano ",

          "          corrected0 = correctDistortionAndCoord(intrinsic300, v_texcoord0);",

   "                 if ((corrected0.x>=0. && corrected0.x<=1. && corrected0.y>=0. && corrected0.y<=1.) && v_texcoord0.w>0.)",
        "                 color = texture2D(texture0,corrected0); ",
        "            else{",

                       " corrected1 = correctDistortionAndCoord(intrinsic301, v_texcoord1);",

                      "  if ((corrected1.x>=0. && corrected1.x<=1. && corrected1.y>=0. && corrected1.y<=1.) && v_texcoord1.w>0.){",
                      "   color = texture2D(texture1,corrected1); ",
                      "   color.a = 1. - texture2D(textureFrontMask,corrected1).a;",
                      "  }",
                     "   else{",

                       "     corrected2 = correctDistortionAndCoord(intrinsic302, v_texcoord2);",

                        "    if ((corrected2.x>=0. && corrected2.x<=1. && corrected2.y>=0. && corrected2.y<=1.) && v_texcoord2.w>0.)",
                       "        color = texture2D(texture2,corrected2); ",
                      "       else{",



                              "  corrected3 = correctDistortionAndCoord(intrinsic303, v_texcoord3);",


                            "    if ((corrected3.x>=0. && corrected3.x<=1. && corrected3.y>=0. && corrected3.y<=1.) && v_texcoord3.w>0.){",
                           "             color = texture2D(texture3,corrected3); ",
                           "             color.a = 1. - texture2D(textureBackMask,corrected3).a;",
                           "     }",
                          "      else{",

                             "       corrected4 = correctDistortionAndCoord(intrinsic304, v_texcoord4);",

                             "       if ((corrected4.x>=0. && corrected4.x<=1. && corrected4.y>=0. && corrected4.y<=1.) && v_texcoord4.w>0.)",
                            "                        color = texture2D(texture4,corrected4); ",
                             "   }",
                        "    }",
                       " }",
                  "  }",
           " }",
           " saveColor = color;",


// SECONDLY 
        
   
           " corrected0bis = correctDistortionAndCoord(intrinsic300, v_texcoord0bis);",
           " corrected1bis = correctDistortionAndCoord(intrinsic301, v_texcoord1bis);",
           " corrected2bis = correctDistortionAndCoord(intrinsic302, v_texcoord2bis);",
          "  corrected3bis = correctDistortionAndCoord(intrinsic303, v_texcoord3bis);",
          "  corrected4bis = correctDistortionAndCoord(intrinsic304, v_texcoord4bis);",


// CAM 0,300

          "  if ((corrected0bis.x>0. && corrected0bis.x<1. && corrected0bis.y>0. && corrected0bis.y<1.) && v_texcoord0bis.w>0.){",

          "      colorbis = texture2D(texture0bis,corrected0bis);",
                
         "       if(blending){   ",
                    // Blending cam0/cam1
            "        if (((corrected1bis.x>=0. && corrected1bis.x<=1. && corrected1bis.y>=0. && corrected1bis.y<=1.) && v_texcoord1bis.w>0.)&& corrected0bis.x < 0.03){ ",
           "             colorbis = colorbis * (corrected0bis.x/ 0.03) +   texture2D(texture1bis,corrected1bis) * (1.- (corrected0bis.x)/ 0.03);",
                    "}",
                    // Blending cam0/cam2
               "     if (((corrected2bis.x>=0. && corrected2bis.x<=1. && corrected2bis.y>=0. && corrected2bis.y<=1.) && v_texcoord2bis.w>0.)&& corrected0bis.y >0.97){ ",
                "        colorbis = colorbis *  (1. - (corrected0bis.y-0.97)/0.03)  +   texture2D(texture2bis,corrected2bis) * ((corrected0bis.y-0.97)/0.03);",
                "    }",
                    // Blending cam0/cam3",
                "     if (((corrected3bis.x>0. && corrected3bis.x<1. && corrected3bis.y>0. && corrected3bis.y<1.) && v_texcoord3bis.w>0.)&& corrected0bis.x > 0.97){ ",
                 "       colorbis = colorbis *  (1. - (corrected0bis.x-0.97)/0.03)   +   texture2D(texture3bis,corrected3bis) * ((corrected0bis.x-0.97)/0.03);",
                    "}",
                    // Blending cam0/cam4
                 "    if (((corrected4bis.x>=0. && corrected4bis.x<=1. && corrected4bis.y>=0. && corrected4bis.y<=1.) && v_texcoord4bis.w>0.)&& corrected0bis.y < 0.03){ ",
                   "     colorbis = colorbis *  (corrected0bis.y/0.03)  +   texture2D(texture4bis,corrected4bis) * ( 1. - corrected0bis.y/0.03);",
                  "  }",
                  "    if (((corrected1bis.x>=0. && corrected1bis.x<=1. && corrected1bis.y>=0. && corrected1bis.y<=1.) && v_texcoord1bis.w>0.)&& corrected0bis.x < 0.03){ ",
                   "     colorbis = colorbis * (corrected0bis.x/ 0.03) +   texture2D(texture1bis,corrected1bis) * (1.- (corrected0bis.x)/ 0.03);         ",
                   " }",
                "}",
                                 
                //color = indice_time0 * saveColor + (1. - indice_time0) * colorbis; //indice_time21
                "color = indice_time0 * (saveColor - colorbis) + colorbis;",
           " }else",


// CAM 1,301

           "  if ((corrected1bis.x>0. && corrected1bis.x<1. && corrected1bis.y>0. && corrected1bis.y<1.) && v_texcoord1bis.w>0.){ ",

           "            colorbis =  texture2D(texture1bis,corrected1bis); ",
          "             colorbis.a = 1.- texture2D(textureFrontMask,corrected1bis).a; ",

             "          if(blending){ ",
                           // Blending cam1/cam2
             "              if (((corrected2bis.x>=0. && corrected2bis.x<=1. && corrected2bis.y>=0. && corrected2bis.y<=1.) && v_texcoord2bis.w>0.)&& corrected1bis.x> .97){  ",
              "                 colorbis = colorbis * (1. - (corrected1bis.x-0.97)/0.03)  +   texture2D(texture2bis,corrected2bis) * ((corrected1bis.x-0.97)/0.03); ",
               "            } ",
                           // Blending cam1/cam4
              "             if (((corrected4bis.x>=0. && corrected4bis.x<=1. && corrected4bis.y>=0. && corrected4bis.y<=1.) && v_texcoord4bis.w>0.)&& corrected1bis.x< 0.03){  ",
               "                colorbis = colorbis * (corrected1bis.x/0.03)  +   texture2D(texture4bis,corrected4bis) * (1.- (corrected1bis.x)/0.03); ",
              "             } ",
              "         } ",

              "         color = (1. - colorbis.a) * saveColor + colorbis.a * colorbis; ",
               "        color.a = colorbis.a + saveColor.a; ",
                       //color = indice_time1 * saveColor + (1. - indice_time1) * color;
              "         color = indice_time1 * (saveColor - color) + color; ",

         "   }else ",



// CAM 2,302

        "    if ((corrected2bis.x>0. && corrected2bis.x<1. && corrected2bis.y>0. && corrected2bis.y<1.) && v_texcoord2bis.w>0.){ ",
               
          "         colorbis = texture2D(texture2bis,corrected2bis); ",
          "      if(blending){ ",
                     // Blending cam2/cam3
            "         if (((corrected3bis.x>=0. && corrected3bis.x<=1. && corrected3bis.y>=0. && corrected3bis.y<=1.) && v_texcoord3bis.w>0.)&& corrected2bis.x>0.97){  ",
           "              colorbis = colorbis * (1. - (corrected2bis.x-0.97)/0.03)  +   texture2D(texture3bis,corrected3bis) * ((corrected2bis.x-0.97)/0.03); ",
            "         } ",
           "     } ",

                //  BLEND with ground
         "       if(corrected2bis.y>0.97) colorbis = colorbis * (1. - (corrected2bis.y-0.97)/0.03) + saveColor * ((corrected2bis.y-0.97)/0.03); ",

                //color = indice_time2 * saveColor + (1. - indice_time2) * colorbis; 	
         "         color = indice_time2 * (saveColor - colorbis) + colorbis; ",
                    
         "   }else ",

// CAM 3,303

       "     if ((corrected3bis.x>0.01 && corrected3bis.x<0.99 && corrected3bis.y>0. && corrected3bis.y<1.) && v_texcoord3bis.w>0.){ ",
             
        "           colorbis = texture2D(texture3bis,corrected3bis); ",
        "           colorbis.a = 1.- texture2D(textureBackMask,corrected3bis).a; ",

                    // Blending cam3/cam4
         "           if(blending){ ",
         "               if (((corrected4bis.x>=0. && corrected4bis.x<=1. && corrected4bis.y>=0. && corrected4bis.y<=1.) && v_texcoord4bis.w>0.)&& corrected3bis.x>0.97){  ",
          "                  colorbis = colorbis * (1. - (corrected3bis.x-0.97)/0.03)   +   texture2D(texture4bis,corrected4bis) * ((corrected3bis.x-0.97)/0.03); ",
          "              } ",
          "          } ",
                    
         "           color = (1. - colorbis.a) * saveColor + colorbis.a * colorbis; ",
         "           color.a = colorbis.a + saveColor.a; ",
                    //color = indice_time3 * saveColor + (1. - indice_time3) * color;
         "           color = indice_time3 * (saveColor - color) + color; ",

         "       }else ",

// CAM 4,304

        "    if ((corrected4bis.x>0. && corrected4bis.x<1. && corrected4bis.y>0. && corrected4bis.y<1.) && v_texcoord4bis.w>0.){ ",

         "       colorbis = texture2D(texture4bis,corrected4bis);	 ",

                //  BLEND with ground
        "        if(corrected4bis.y>0.97) colorbis = colorbis * (1. - (corrected4bis.y-0.97)/0.03) + saveColor * ((corrected4bis.y-0.97)/0.03); ",

                //color = indice_time4 * saveColor + (1. - indice_time4) * colorbis; 
          "        color = indice_time4 * (saveColor - colorbis) + colorbis; ",
          "  } ",

         "   color.a = alpha; ",
        "    gl_FragColor = color; ",

    "} "         
     
        ],
        
         shaderTextureProjective2LightFS : [
        
      

        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",

        "uniform float alpha;",

        "uniform mat4 mvpp_current_0;",
        "uniform mat4 mvpp_current_1;",
        "uniform mat4 mvpp_current_2;",
        "uniform mat4 mvpp_current_3;",
        "uniform mat4 mvpp_current_4;",
        "uniform mat4 mvpp_current_0bis;",
        "uniform mat4 mvpp_current_1bis;",
        "uniform mat4 mvpp_current_2bis;",
        "uniform mat4 mvpp_current_3bis;",
        "uniform mat4 mvpp_current_4bis;",

        "uniform sampler2D   texture0;",
        "uniform sampler2D   texture1;",
        "uniform sampler2D   texture2;",
        "uniform sampler2D   texture3;",
        "uniform sampler2D   texture4;",
        "uniform sampler2D   texture0bis;",
        "uniform sampler2D   texture1bis;",
        "uniform sampler2D   texture2bis;",
        "uniform sampler2D   texture3bis;",
        "uniform sampler2D   texture4bis;",
        "uniform sampler2D   textureFrontMask;",
        "uniform sampler2D   textureBackMask;",

        "uniform vec4 factorTranslation;	",
        "uniform vec4 factorTranslationbis;",

        "varying vec4 v_texcoord0;",
        "varying vec4 v_texcoord1;",
        "varying vec4 v_texcoord2;",
        "varying vec4 v_texcoord3;",
        "varying vec4 v_texcoord4;",
        "varying vec4 v_texcoord0bis;",
        "varying vec4 v_texcoord1bis;",
        "varying vec4 v_texcoord2bis;",
        "varying vec4 v_texcoord3bis;",
        "varying vec4 v_texcoord4bis;",

        "uniform float indice_time0;",
        "uniform float indice_time1;",
        "uniform float indice_time2;",
        "uniform float indice_time3;",
        "uniform float indice_time4;",

        "uniform vec4 intrinsic300;",
        "uniform vec4 intrinsic301;",
        "uniform vec4 intrinsic302;",
        "uniform vec4 intrinsic303;",
        "uniform vec4 intrinsic304;",
        

        "uniform int blendingOn;",
        "uniform int mobileOn;",
        "uniform int fog;",

        "float width = 2048.0;",
        "float height = 2048.0;",
        "float dist;",


        // Distortion
        "float cpps = 1042.178;",
        "float lpps = 1020.435;",
        "vec2 pps = vec2(cpps,lpps);",

        "vec4 color = vec4(0.38,0.34,0.34,0.5);	",
        "vec4 colorbis = vec4(0.,0.,0.,0.);",
        "vec4 saveColor = vec4(0.,0.,0.,0.);",

        "vec2 corrected0, corrected1, corrected2, corrected3, corrected4;",
        "vec2 corrected0bis, corrected1bis, corrected2bis, corrected3bis, corrected4bis;",



        // Function to correct coordinate using 3rd degree polynome and max
      " vec2 correctDistortionAndCoord(vec4 dist, vec4 v_texcoord){",
            
          "  vec2 v = v_texcoord.xy/v_texcoord.w - pps;",
         "   float v2 = dot(v,v);",
         "   if(v2>dist.w) return vec2(-2.,-2.); // false;",
         "   float r = v2*(dist.x+v2*(dist.y+v2*dist.z));",
         "   vec2 normCoord = v_texcoord.xy/(v_texcoord.w) + r*v;",
                //float r = v2*(dist.x+v2*(dist.y+v2*dist.z));
                //vec2 normCoord = v_texcoord.xy + r*v*v_texcoord.w;

          "  return vec2(normCoord.x/width , 1. - normCoord.y/height); ",

     "   }",



      "  void main(void)",
   "     {	",
    "        bool blending = (blendingOn == 1) && (mobileOn == 0);",


          "   saveColor = color;",


// SECONDLY 
        
   
       "     corrected0bis = correctDistortionAndCoord(intrinsic300, v_texcoord0bis);",
        "    corrected1bis = correctDistortionAndCoord(intrinsic301, v_texcoord1bis);",
        "    corrected2bis = correctDistortionAndCoord(intrinsic302, v_texcoord2bis);",
        "    corrected3bis = correctDistortionAndCoord(intrinsic303, v_texcoord3bis);",
        "    corrected4bis = correctDistortionAndCoord(intrinsic304, v_texcoord4bis);",


// CAM 0,300

  "          if ((corrected0bis.x>0. && corrected0bis.x<1. && corrected0bis.y>0. && corrected0bis.y<1.) && v_texcoord0bis.w>0.){",

         "       colorbis = texture2D(texture0bis,corrected0bis);",
                
     "           if(blending){   ",
                    // Blending cam0/cam1
           "         if (((corrected1bis.x>=0. && corrected1bis.x<=1. && corrected1bis.y>=0. && corrected1bis.y<=1.) && v_texcoord1bis.w>0.)&& corrected0bis.x < 0.03){ ",
            "            colorbis = colorbis * (corrected0bis.x/ 0.03) +   texture2D(texture1bis,corrected1bis) * (1.- (corrected0bis.x)/ 0.03);",
            "        }",
                    // Blending cam0/cam2
              "      if (((corrected2bis.x>=0. && corrected2bis.x<=1. && corrected2bis.y>=0. && corrected2bis.y<=1.) && v_texcoord2bis.w>0.)&& corrected0bis.y >0.97){ ",
              "          colorbis = colorbis *  (1. - (corrected0bis.y-0.97)/0.03)  +   texture2D(texture2bis,corrected2bis) * ((corrected0bis.y-0.97)/0.03);",
             "       }",
                    // Blending cam0/cam3
           "          if (((corrected3bis.x>0. && corrected3bis.x<1. && corrected3bis.y>0. && corrected3bis.y<1.) && v_texcoord3bis.w>0.)&& corrected0bis.x > 0.97){ ",
           "             colorbis = colorbis *  (1. - (corrected0bis.x-0.97)/0.03)   +   texture2D(texture3bis,corrected3bis) * ((corrected0bis.x-0.97)/0.03);",
           "         }",
                    // Blending cam0/cam4
       "              if (((corrected4bis.x>=0. && corrected4bis.x<=1. && corrected4bis.y>=0. && corrected4bis.y<=1.) && v_texcoord4bis.w>0.)&& corrected0bis.y < 0.03){ ",
        "                colorbis = colorbis *  (corrected0bis.y/0.03)  +   texture2D(texture4bis,corrected4bis) * ( 1. - corrected0bis.y/0.03);",
       "             }",
        "              if (((corrected1bis.x>=0. && corrected1bis.x<=1. && corrected1bis.y>=0. && corrected1bis.y<=1.) && v_texcoord1bis.w>0.)&& corrected0bis.x < 0.03){ ",
        "                colorbis = colorbis * (corrected0bis.x/ 0.03) +   texture2D(texture1bis,corrected1bis) * (1.- (corrected0bis.x)/ 0.03);         ",
         "           }",
        "        }",
                                 
                //color = indice_time0 * saveColor + (1. - indice_time0) * colorbis; //indice_time21
         "       color = indice_time0 * (saveColor - colorbis) + colorbis;",
         "  }else",


// CAM 1,301

        "     if ((corrected1bis.x>0. && corrected1bis.x<1. && corrected1bis.y>0. && corrected1bis.y<1.) && v_texcoord1bis.w>0.){",

        "               colorbis =  texture2D(texture1bis,corrected1bis);",
         "              colorbis.a = 1.- texture2D(textureFrontMask,corrected1bis).a;",

          "             if(blending){",
                           // Blending cam1/cam2
             "              if (((corrected2bis.x>=0. && corrected2bis.x<=1. && corrected2bis.y>=0. && corrected2bis.y<=1.) && v_texcoord2bis.w>0.)&& corrected1bis.x> .97){ ",
             "                  colorbis = colorbis * (1. - (corrected1bis.x-0.97)/0.03)  +   texture2D(texture2bis,corrected2bis) * ((corrected1bis.x-0.97)/0.03);",
             "              }",
                           // Blending cam1/cam4
               "            if (((corrected4bis.x>=0. && corrected4bis.x<=1. && corrected4bis.y>=0. && corrected4bis.y<=1.) && v_texcoord4bis.w>0.)&& corrected1bis.x< 0.03){ ",
               "                colorbis = colorbis * (corrected1bis.x/0.03)  +   texture2D(texture4bis,corrected4bis) * (1.- (corrected1bis.x)/0.03);",
               "            }",
               "        }",

               "        color = (1. - colorbis.a) * saveColor + colorbis.a * colorbis;",
               "        color.a = colorbis.a + saveColor.a;",
                       //color = indice_time1 * saveColor + (1. - indice_time1) * color;
               "        color = indice_time1 * (saveColor - color) + color;",

         "   }else",



// CAM 2,302

       "     if ((corrected2bis.x>0. && corrected2bis.x<1. && corrected2bis.y>0. && corrected2bis.y<1.) && v_texcoord2bis.w>0.){",
               
          "         colorbis = texture2D(texture2bis,corrected2bis);",
          "      if(blending){",
                     // Blending cam2/cam3
          "           if (((corrected3bis.x>=0. && corrected3bis.x<=1. && corrected3bis.y>=0. && corrected3bis.y<=1.) && v_texcoord3bis.w>0.)&& corrected2bis.x>0.97){ ",
           "              colorbis = colorbis * (1. - (corrected2bis.x-0.97)/0.03)  +   texture2D(texture3bis,corrected3bis) * ((corrected2bis.x-0.97)/0.03);",
          "           }",
          "      }",

                //  BLEND with ground
           "     if(corrected2bis.y>0.97) colorbis = colorbis * (1. - (corrected2bis.y-0.97)/0.03) + saveColor * ((corrected2bis.y-0.97)/0.03);",

                //color = indice_time2 * saveColor + (1. - indice_time2) * colorbis; 	
          "        color = indice_time2 * (saveColor - colorbis) + colorbis;",
                    
         "   }else",

// CAM 3,303

        "    if ((corrected3bis.x>0.01 && corrected3bis.x<0.99 && corrected3bis.y>0. && corrected3bis.y<1.) && v_texcoord3bis.w>0.){",
             
        "           colorbis = texture2D(texture3bis,corrected3bis);",
        "           colorbis.a = 1.- texture2D(textureBackMask,corrected3bis).a;",

                    // Blending cam3/cam4
         "           if(blending){",
            "            if (((corrected4bis.x>=0. && corrected4bis.x<=1. && corrected4bis.y>=0. && corrected4bis.y<=1.) && v_texcoord4bis.w>0.)&& corrected3bis.x>0.97){ ",
          "                  colorbis = colorbis * (1. - (corrected3bis.x-0.97)/0.03)   +   texture2D(texture4bis,corrected4bis) * ((corrected3bis.x-0.97)/0.03);",
         "               }",
          "          }",
                    
        "            color = (1. - colorbis.a) * saveColor + colorbis.a * colorbis;",
        "            color.a = colorbis.a + saveColor.a;",
                    //color = indice_time3 * saveColor + (1. - indice_time3) * color;
        "            color = indice_time3 * (saveColor - color) + color;",

        "        }else",

// CAM 4,304

       "     if ((corrected4bis.x>0. && corrected4bis.x<1. && corrected4bis.y>0. && corrected4bis.y<1.) && v_texcoord4bis.w>0.){",

       "         colorbis = texture2D(texture4bis,corrected4bis);	",

                //  BLEND with ground
       "         if(corrected4bis.y>0.97) colorbis = colorbis * (1. - (corrected4bis.y-0.97)/0.03) + saveColor * ((corrected4bis.y-0.97)/0.03);",

                //color = indice_time4 * saveColor + (1. - indice_time4) * colorbis; 
       "           color = indice_time4 * (saveColor - colorbis) + colorbis;",
       "     }",

       "     color.a = alpha;",
       "     gl_FragColor = color;",

   " }"
   
     ],
         
       shaderLaserVS :   [
          
      "    #ifdef GL_ES ",
      "    precision mediump float;",
      "    #endif ",

      "    attribute vec3 displacement; ",
      "    attribute float uniqueid; ",


      "    varying vec3 colorpoint;",
      "    uniform float point_size;",
      "    uniform float indice_time_laser;",
      "    uniform float currentidwork;",
      "    uniform float indice_time_laser_tab[160];",

      "    uniform int movementLocked;",

      "    float getSize(float id){",
      "      return (0.5 -indice_time_laser_tab[int(id)]) * 15.;",
      "    }",

      "    void main()",
      "    {",


      "    vec3 newPosition = position;",
      "    gl_PointSize = point_size;     //2.* clamp(6. - (position.y + 2.), 0., 6.); //getSize(uniqueid);//point_size;",

      "    if(movementLocked!=1)",
      "           newPosition = vec3(position.x+ displacement.x*indice_time_laser_tab[int(uniqueid)],",
      "                              position.y+ displacement.y*indice_time_laser_tab[int(uniqueid)],",
      "                              position.z+ displacement.z*indice_time_laser_tab[int(uniqueid)]);",

      "           gl_Position  =  projectionMatrix *  modelViewMatrix * vec4(newPosition,1.);",

      "          colorpoint = color;",

      "      }"
        
       ],
       

       
        shaderLaserFS :   [
        
    "      #ifdef GL_ES ",
    "        precision mediump float;",
    "      #endif",

     "       varying vec3 colorpoint;",
     "       uniform float alpha;",
     "       uniform sampler2D texturePoint;",

      "      void main() ",
     "       {",

       "         gl_FragColor = vec4(colorpoint,alpha);",
 
      "      }	"

        
       ],
       
         shaderBati3DVS :   [

            "#ifdef GL_ES",
            "precision mediump float;",
           " #endif",

           " uniform int textureJPG;",
           " attribute float materialindice;",
           " varying float matindice;",
           " varying vec2 vUv;",
           " varying vec3 vNormal;",
           " varying vec3 pos;",

         "   void main() {",
               " vNormal = normal;",
               " vUv = vec2( uv.x, uv.y );",
               " if(textureJPG ==1) vUv = vec2(vUv.x, 1.- vUv.y);  ",
               " matindice = materialindice;",
               "     pos = position;",
               "   gl_Position  =  projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );",
               "}",
         ],
         
         shaderBati3DFS :   [
             
           " #ifdef GL_ES ",
           " precision highp float;",
           " #endif",


           " uniform sampler2D u_textures[16];",
          "  uniform int textureJPG;",
          "  uniform float alpha;",
           " uniform vec3 light;",

          "  varying float matindice;",
          "  varying vec2 vUv;",
           " varying vec3 vNormal;",
          "  varying vec3 pos;",

          "  vec4 color = vec4(1.,0.,0.,1.);",

          "  void main(void)",
           " {	",
           "         vec2 uv = vUv;",

           "         if (matindice<0.9)      color = texture2D(u_textures[0],uv);",
           "         else if (matindice<1.9) color = texture2D(u_textures[1],uv);",
           "         else if (matindice<2.9) color = texture2D(u_textures[2],uv);",
           "         else if (matindice<3.9) color = texture2D(u_textures[3],uv);",
           "         else if (matindice<4.9) color = texture2D(u_textures[4],uv);",
           "         else if (matindice<5.9) color = texture2D(u_textures[5],uv);",
           "         else if (matindice<6.9) color = texture2D(u_textures[6],uv);",
           "         else if (matindice<7.9) color = texture2D(u_textures[7],uv);",
           "         else if (matindice<8.9) color = texture2D(u_textures[8],uv);",
           "         else if (matindice<9.9) color = texture2D(u_textures[9],uv);",
           "         else if (matindice<10.9) color = texture2D(u_textures[10],uv);",
           "         else if (matindice<11.9) color = texture2D(u_textures[11],uv);",
           "         else if (matindice<12.9) color = texture2D(u_textures[12],uv);",
           "         else if (matindice<13.9) color = texture2D(u_textures[13],uv);",
           "         else if (matindice<14.9) color = texture2D(u_textures[14],uv);",
           "         else if (matindice<15.9) color = texture2D(u_textures[15],uv);",


           "         if(color.r == 0. && color.g ==0.) color =  vec4(vUv.x,vUv.x,vUv.x,0.5);",
                                                                                                //color =  vec4(matindice/2.,1.,1.,1.);
           "        else",
           "               color.a = alpha;",
           "    gl_FragColor = color; //vec4(1.,1.,0.,1.);//texture2D(u_textures[0],uv);",
          " }",
             
             
         ]
             
             
             
             
             
             
         }
 
         return Shader;   
});

/**
* 
* @author AD IGN
* Class generating shaders for projective texturing of MULTIPLE IMAGES in a single shader. This class can be used 
* to texture any mesh. We need to set the matrix of Orientation of the projector
* and its projective camera information.
*/

define ('ProjectiveTexturing2',['GraphicEngine','lib/three','Ori','Shader', 'PanoramicProvider'],
function (graphicEngine, THREE, Ori, Shader, PanoramicProvider) {

            window.requestAnimSelectionAlpha = (function(){
                         return  window.requestAnimationFrame || 
                         window.webkitRequestAnimationFrame   || 
                         window.mozRequestAnimationFrame      || 
                         window.oRequestAnimationFrame        || 
                         window.msRequestAnimationFrame       || 
                         function(callback, element){
                             window.setTimeout(callback, 1000 / 60);
                         };
               })();
    
        var _initiated = false;
        var _alphaP = 1;
        var _shaderMat = null;
	var tabImages = [];  // Get the 20 images (>=10) to pass to shaders . Img at indice 0 is 21, 1 is 22, ... 10 is 21bis, 11 is 22bis... 19 is 43 bis
	var tabTranslations =[];
	var tabRotations=[];
	//initImages();    // Prepare image loading space used in the shaders, 20 img
	var tabMatrices = [];//var matrice21 //proj_cam* mv_current_21* rot21
	var tabMatMVP = [];
        var pat=new RegExp("-[0-9][0-9]-");  // To detect and change camera number
        var _mobileVersion = 0;

        // New cameras
        var _mv_current_300,_mv_current_301,_mv_current_302,_mv_current_303,_mv_current_304;        


        var proj_cam = new THREE.Matrix4(  1129.284,	0,	0.,	0.,
                                           0.,        1129.284,	0.,	0.,
                                           1042.178,  1020.435,	0.,	1.,
                                           0.,          0.,     0.,	0.);
                                           


        var rot21 = new THREE.Matrix4(	1,0,0,0,
                                        0,1,0,0,
                                        0,0,1,0,
                                        0,0,0,1);

        var mat300,mat301,mat302,mat303,mat304;


     
        var ProjectiveTexturing2 = {
         
            imgName:'',
            nbL2Loaded : 0,     // Indicate the number of image loaded at level2 
                             // If 10 then we can load level 3
                             // This technic allow to not load level 3 when navigating fast
                          
                
         init: function(matRot){
             
             this.localImageFiles = PanoramicProvider.getImageLocal();
             _mobileVersion = graphicEngine.isMobileEnvironment() ? 1:0;
             this.initOrientationCameraMatrices();
             this.setRotationHeading(matRot);
             this.initImages();
             this.initMatrices();
             this.initTranslations();
             
             _initiated = true;
         },
         
         
         // Get Orientation matrices for camera, relatif
         // all cam in the same local ref
         initOrientationCameraMatrices: function(){
            
            // New cameras
            _mv_current_300 = Ori.getMatCam(300);
            _mv_current_301 = Ori.getMatCam(301);
            _mv_current_302 = Ori.getMatCam(302);
            _mv_current_303 = Ori.getMatCam(303);
            _mv_current_304 = Ori.getMatCam(304);

         },

                
         // Initialize matrices using global rotation (21) and local for each cam
         initMatrices: function(){
             
            mat300 = new THREE.Matrix4().multiplyMatrices(_mv_current_300,Ori.getProjCam(300));
            mat301 = new THREE.Matrix4().multiplyMatrices(_mv_current_301,Ori.getProjCam(301));
            mat302 = new THREE.Matrix4().multiplyMatrices(_mv_current_302,Ori.getProjCam(302));
            mat303 = new THREE.Matrix4().multiplyMatrices(_mv_current_303,Ori.getProjCam(303));
            mat304 = new THREE.Matrix4().multiplyMatrices(_mv_current_304,Ori.getProjCam(304));
            console.log("mat300mat300",mat300);
            tabMatMVP.push(mat300);
            tabMatMVP.push(mat301);
            tabMatMVP.push(mat302);
            tabMatMVP.push(mat303);
            tabMatMVP.push(mat304);
            
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat300.clone() )).transpose() );//0
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat301.clone() )).transpose() );//1
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat302.clone() )).transpose() );
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat303.clone() )).transpose() );
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat304.clone() )).transpose() );
            
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat300.clone() )).transpose() );//5
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat301.clone() )).transpose() );//6
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat302.clone() )).transpose() );
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat303.clone() )).transpose() );
            tabMatrices.push( (new THREE.Matrix4().multiplyMatrices( rot21.clone(),mat304.clone() )).transpose() );

         },
         
         
         // Init translation using cam pos in applanix ref and global rotation
         initTranslations: function(){
             
             var translation300 = Ori.getSommet(300).clone().applyProjection( rot21.clone()); translation300.w = 1;
             var translation301 = Ori.getSommet(301).clone().applyProjection( rot21.clone()); translation301.w = 1;
             var translation302 = Ori.getSommet(302).clone().applyProjection( rot21.clone()); translation302.w = 1;
             var translation303 = Ori.getSommet(303).clone().applyProjection( rot21.clone()); translation303.w = 1;
             var translation304 = Ori.getSommet(304).clone().applyProjection( rot21.clone()); translation304.w = 1;
             
             tabTranslations.push(translation300);
             tabTranslations.push(translation301);
             tabTranslations.push(translation302);
             tabTranslations.push(translation303);
             tabTranslations.push(translation304);
             tabTranslations.push(translation300);
             tabTranslations.push(translation301);
             tabTranslations.push(translation302);
             tabTranslations.push(translation303);
             tabTranslations.push(translation304);
             
         },
         
         
        // Init Images, Rotations and Translations
	initImages: function(){

            for(var i = 0; i< 10; ++i){
                var img = new Image(); img.crossOrigin = 'anonymous';
                tabImages.push(img);
                tabRotations.push(rot21);
            }
	},
         
         
       createShaderForImage: function(imgUrl,qlt){

            //if(translation==null) translation = new THREE.Vector4(0,0,0,1);
            var indice_time = 0;  // A voir avec la fn de tweening pour smooth alpha
            var pat = new RegExp("-[0-9][0-9]-");  // To detect and change camera number
            var pat2 = new RegExp("-[0-9][0-9][0-9][0-9][0-9][0-9]_");  // To detect date to know image directory
            var date = imgUrl.match(pat2)
            date = String(date).substr(1, 6)+"/";
            var width = 1920;
            var height = 1080;
            var distw = 1.0/width;
            var disth = 1.0/height;
            
            //var arrAllDistoandMax = Ori.getArrayDistortionAndR2AllCam();
            var distoAndMax300 = Ori.getDistortionAndR2ForCamAsVec4(300);
            var distoAndMax301 = Ori.getDistortionAndR2ForCamAsVec4(301);
            var distoAndMax302 = Ori.getDistortionAndR2ForCamAsVec4(302);
            var distoAndMax303 = Ori.getDistortionAndR2ForCamAsVec4(303);
            var distoAndMax304 = Ori.getDistortionAndR2ForCamAsVec4(304);
            
            var wid = _mobileVersion == 1 ? 512:1024;
            
            var urlImage = PanoramicProvider.getUrlImageFile();
            var suffixeImage = this.localImageFiles ? ".jpg" : ".jp2&WID="+wid/4+"&QLT="+qlt+"&CVT=JPEG";
            console.log("localImageFiles: ",this.localImageFiles);
            var uniforms5 = {
                
                
                    //disto_and_max_tab:{type: 'fv1', value: arrAllDistoandMax},
                    intrinsic300: {type:"v4",value:distoAndMax300},
                    intrinsic301: {type:"v4",value:distoAndMax301},
                    intrinsic302: {type:"v4",value:distoAndMax302},
                    intrinsic303: {type:"v4",value:distoAndMax303},
                    intrinsic304: {type:"v4",value:distoAndMax304},
 
                    kernel : { type: "iv1", value: [ -1, -1, -1,-1, 17,-1,-1,-1, -1 ] },    // integer array (plain)
                    offset: { type: "v2v", value: [ 
                            new THREE.Vector2(distw,disth ),new THREE.Vector2( 0.,disth),new THREE.Vector2( -distw,disth),
                            new THREE.Vector2(distw,0. ),new THREE.Vector2( 0.,0.),new THREE.Vector2( -distw,0.),
                            new THREE.Vector2(distw,-disth ),new THREE.Vector2( 0.,-disth),new THREE.Vector2( -distw,-disth)
                        ]
                    }, // Vector2 array

                    blendingOn:{type:'i', value:1},
                    mobileOn:{type:'i', value:_mobileVersion},
                    
                    alpha:{type:'f',value:_alphaP},
                    fog:  { type: "i", value: 0 }, 

                    indice_time0:{type:'f',value:indice_time},
                    indice_time1:{type:'f',value:indice_time},
                    indice_time2:{type:'f',value:indice_time},
                    indice_time3:{type:'f',value:indice_time},
                    indice_time4:{type:'f',value:indice_time},

                    mvpp_current_0:{type: 'm4',value: tabMatrices[0]},
                    mvpp_current_1:{type: 'm4',value: tabMatrices[1]},
                    mvpp_current_2:{type: 'm4',value: tabMatrices[2]},
                    mvpp_current_3:{type: 'm4',value: tabMatrices[3]},
                    mvpp_current_4:{type: 'm4',value: tabMatrices[4]},

                    mvpp_current_0bis:{type: 'm4',value: tabMatrices[5]},
                    mvpp_current_1bis:{type: 'm4',value: tabMatrices[6]},
                    mvpp_current_2bis:{type: 'm4',value: tabMatrices[7]},
                    mvpp_current_3bis:{type: 'm4',value: tabMatrices[8]},
                    mvpp_current_4bis:{type: 'm4',value: tabMatrices[9]},

                    factorTranslation0:{type:"v4",value: tabTranslations[0]},
                    factorTranslation1:{type:"v4",value: tabTranslations[1]},
                    factorTranslation2:{type:"v4",value: tabTranslations[2]},
                    factorTranslation3:{type:"v4",value: tabTranslations[3]},
                    factorTranslation4:{type:"v4",value: tabTranslations[4]},
                    
                    factorTranslation0bis:{type:"v4",value: tabTranslations[0]},
                    factorTranslation1bis:{type:"v4",value: tabTranslations[1]},
                    factorTranslation2bis:{type:"v4",value: tabTranslations[2]},
                    factorTranslation3bis:{type:"v4",value: tabTranslations[3]},
                    factorTranslation4bis:{type:"v4",value: tabTranslations[4]},

                    texture0: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'300'+"-")+suffixeImage)  
                    },
                    texture1: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'301'+"-")+suffixeImage)  
                    },
                    texture2: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'302'+"-")+suffixeImage) 
                    },
                    texture3: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'303'+"-")+suffixeImage) 
                    },
                    texture4: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'304'+"-")+suffixeImage) 
                    },

                    texture0bis: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'300'+"-")+suffixeImage)  
                    },
                    texture1bis: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'301'+"-")+suffixeImage)  
                    },
                    texture2bis: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'302'+"-")+suffixeImage) 
                    },
                    texture3bis: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'303'+"-")+suffixeImage)
                    },
                    texture4bis: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture(urlImage+date+imgUrl.replace(pat,"-"+'304'+"-")+suffixeImage) 
                    },
                    
                    textureFrontMask: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture("images/frontMask3.png")
                    },
                    textureBackMask: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture("images/backMask.png")
                    }

            };
            
            var gl =  graphicEngine.getRenderer().getContext();
            var nbVaryingVec = gl.getParameter(gl.MAX_VARYING_VECTORS);
            console.log("Max Varying Vector on this machine:", nbVaryingVec);  
            var fragmentShader = Shader.shaderTextureProjective2FS;
            if(nbVaryingVec <= 10 ) fragmentShader = Shader.shaderTextureProjective2LightFS;
           
            // create the shader material for Three
            _shaderMat = new THREE.ShaderMaterial({
                    uniforms:     	uniforms5,
                    vertexShader:   Shader.shaderTextureProjective2VS.join("\n"),
                    fragmentShader: fragmentShader.join("\n"),
                    side: THREE.BackSide,   
                    transparent:true
            });
            
            this.tweenAllIndiceTimes();
            
            // Add TO update images resolution and center position of proj
            var vecTrans = Ori.getBarycentreV2(); 
            vecTrans.applyProjection(rot21);
            this.changePanoTextureAfterloading(date+imgUrl,128,50,new THREE.Vector4(0.,0.,0.,1.),rot21,1);
            graphicEngine.translateCameraSmoothly(vecTrans.x,vecTrans.y,vecTrans.z);

            return _shaderMat;
	},

        changePanoTextureAfterloading: function (imgName,wid,qlt,translation,rotation,nbLevel){

             //console.log("changePanoTextureAfterloading");
             this.imgName = imgName;
             this.nbL2Loaded = 0;
             //require("Cartography3D").tweenGeneralOpacity();
                          
             this.chargeOneImageCam(imgName,'texture1',1,wid,qlt,translation,rotation,6,nbLevel);
             this.chargeOneImageCam(imgName,'texture2',2,wid,qlt,translation,rotation,7,nbLevel);
             this.chargeOneImageCam(imgName,'texture3',3,wid,qlt,translation,rotation,8,nbLevel);
             this.chargeOneImageCam(imgName,'texture4',4,wid,qlt,translation,rotation,9,nbLevel);
             this.chargeOneImageCam(imgName,'texture0',0,wid,qlt,translation,rotation,5,nbLevel);
        },
        
          changePanoTextureAfterloadingTurboTruckMode: function (imgName,wid,qlt,translation,rotation,nbLevel){
            
             //console.log("changePanoTextureAfterloading");
             this.imgName = imgName;
             this.nbL2Loaded = 0;
             this.chargeOneImageCam(imgName,'texture1',1,512,85,translation,rotation,6,0);
    
        },
        
        
         // Load an Image(html) then use it as a texture. Wait loading before passing to the shader to avoid black effect
         // Param nbLevel means if we load a better level or not. 0 or 1
        chargeOneImageCam: function (imgName,nameTexture,num,wid,qlt,translation,rotation,numImg,nbLevel){
           
            // We tell the shader that the actual new texture has to become the old one to make a new transition with the real new one just loaded.
            if(_mobileVersion==0){
                _shaderMat.uniforms[nameTexture].value =_shaderMat.uniforms[nameTexture+'bis'].value;
                _shaderMat.uniforms['factorTranslation'+num].value = tabTranslations[numImg];
                _shaderMat.uniforms['mvpp_current_'+num].value = tabMatrices[numImg];
            }

            var translationPlusSom = translation.clone().add((Ori.getSommet(300+num).clone().applyProjection( rotation.clone()))); translationPlusSom.w = 1;
            tabTranslations[numImg] = translationPlusSom; 		
            tabMatrices[numImg] = (new THREE.Matrix4().multiplyMatrices( rotation.clone(),tabMatMVP[numImg - 5].clone()) ).transpose();
              
            // Load the new image
            var img = new Image(); img.crossOrigin = 'anonymous';
            var that = this;
            img.onload = function () { 
                
                _shaderMat.uniforms['indice_time'+num].value = .8; //if(num==1) console.log('now!');
                _shaderMat.uniforms['mvpp_current_'+num+'bis'].value = tabMatrices[numImg];
                _shaderMat.uniforms['factorTranslation'+num+'bis'].value = translationPlusSom;
                
                _shaderMat.uniforms[nameTexture+'bis'].value = new THREE.Texture(this,THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter,THREE.LinearFilter,THREE.RGBFormat);
                _shaderMat.uniforms[nameTexture+'bis'].value.needsUpdate = true;
                if(nbLevel==1 && !that.localImageFiles) that.changeQuality(imgName,nameTexture,num,512,qlt,numImg);  // Load level 2
                //if(graphicEngine.getSpeedTurnCam() != 0.1 && num == 3) graphicEngine.setSpeedTurnCam(0.1);
                if(that.localImageFiles) graphicEngine.setSpeedTurnCam(0.1);
            }; 

            var suffixeImage = this.localImageFiles ? ".jpg" : ".jp2&WID="+wid/4+"&QLT="+qlt+"&CVT=JPEG";
            img.src = PanoramicProvider.getUrlImageFile()+imgName.replace(pat,"-30"+num+"-")+ suffixeImage;
        },
        
        
           // Load Better Quality. Level 2 (512@50) and 3 (1920@80).
           changeQuality: function(imgName,nameTexture,num,wid,qlt){
               
                var that = this;
                var img = new Image(); img.crossOrigin = 'anonymous';
                img.src = "http://www.itowns.fr/cgi-bin/iipsrv.fcgi?FIF=/iipimagesV2/"+imgName.replace(pat,"-30"+num+"-")+".jp2&WID="+wid+"&QLT="+qlt+"&CVT=JPEG";
                img.onload = function () { 
                        //tabImages[num+5] = this;
                        _shaderMat.uniforms[nameTexture+'bis'].value = new THREE.Texture(this,THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter,THREE.LinearFilter,THREE.RGBFormat);
                        _shaderMat.uniforms[nameTexture+'bis'].value.needsUpdate = true;
                        if(qlt == 50) that.nbL2Loaded++; 
                        if(graphicEngine.getSpeedTurnCam() != 0.1 && num == 3) {graphicEngine.setSpeedTurnCam(0.1); } //require("Cartography3D").setOpacity(0.4);
                }
           },
           
               
           
           // Recursive function
           // After load image load next one etc at same level
           changeQualitySerial: function(tabImageToLoad,imgName,wid,qlt){

                    var num = tabImageToLoad.shift(); 
                    var nameTexture = 'texture'+num;
                    var that = this;
                    var img = new Image(); img.crossOrigin = 'anonymous';
                    img.src = "http://www.itowns.fr/cgi-bin/iipsrv.fcgi?FIF=/iipimagesV2/"+imgName.replace(pat,"-30"+num+"-")+".jp2&WID="+wid+"&QLT="+qlt+"&CVT=JPEG";
                    img.onload = function () { 
                        
                        if (that.imgName == imgName){
                            //tabImages[num+5] = this;
                            tabImages[parseInt(num)+5] = this;
                            _shaderMat.uniforms[nameTexture+'bis'].value = new THREE.Texture(this,THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter,THREE.LinearFilter,THREE.RGBFormat);
                            _shaderMat.uniforms[nameTexture+'bis'].value.needsUpdate = true;

                            if(qlt == 50) that.nbL2Loaded++;
                            if(tabImageToLoad.length>0) that.changeQualitySerial(tabImageToLoad,imgName,wid,qlt); 
                       }
                            
                    }  
           },    
           
           
           loadQualityLevel: function(wid,qlt,imgName){

                //setTimeout(function(){ProjectiveTexturing.loadQualityLevelNow(1920,80,imgName);},2000);  
                setTimeout(function(){ProjectiveTexturing2.loadQualityLevelNowSerial(wid,qlt,imgName);},2000);  
           },
           
  
           // Serial launch
           loadQualityLevelNowSerial: function(wid,qlt,imgName){

                if (this.imgName==imgName){    // Means that we are still in the same image
                   //console.log(this.imgName);
                   //console.log('load level3');   // waiting for higher resolution
                   var tabImageToLoad = ['0','1','2','3','4'];
                   this.changeQualitySerial(tabImageToLoad,this.imgName,wid,qlt);
               }

               //this.nbL2Loaded = 0;
           },

           
           // Return a i,j coordinate in the image where it projects from a 3D position. Same as the original GPU code
           groundToImage: function(pos){

                var newpos0 = pos.clone().sub( _shaderMat.uniforms['factorTranslation0bis'].value); 
                var newpos1 = pos.clone().sub( _shaderMat.uniforms['factorTranslation1bis'].value); 
                var newpos2 = pos.clone().sub( _shaderMat.uniforms['factorTranslation2bis'].value); 
                var newpos3 = pos.clone().sub( _shaderMat.uniforms['factorTranslation3bis'].value); 
                var newpos4 = pos.clone().sub( _shaderMat.uniforms['factorTranslation4bis'].value); 
                
                var v_texcoord0bis =  _shaderMat.uniforms['mvpp_current_0bis'].value.multiplyVector4( new THREE.Vector4(newpos0.x, newpos0.y,newpos0.z,1));
                var v_texcoord1bis =  _shaderMat.uniforms['mvpp_current_1bis'].value.multiplyVector4( new THREE.Vector4(newpos1.x, newpos1.y,newpos1.z,1));
                var v_texcoord2bis =  _shaderMat.uniforms['mvpp_current_2bis'].value.multiplyVector4( new THREE.Vector4(newpos2.x, newpos2.y,newpos2.z,1));
                var v_texcoord3bis =  _shaderMat.uniforms['mvpp_current_3bis'].value.multiplyVector4( new THREE.Vector4(newpos3.x, newpos3.y,newpos3.z,1));
                var v_texcoord4bis =  _shaderMat.uniforms['mvpp_current_4bis'].value.multiplyVector4( new THREE.Vector4(newpos4.x, newpos4.y,newpos4.z,1));

                var corrected0bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic300'].value, v_texcoord0bis.clone());
                var corrected1bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic301'].value, v_texcoord1bis.clone());
                var corrected2bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic302'].value, v_texcoord2bis.clone());
                var corrected3bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic303'].value, v_texcoord3bis.clone());
                var corrected4bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic304'].value, v_texcoord4bis.clone());
                
                // z is actually representing w
                var coordImage;
                if(corrected0bis.x > 0 && corrected0bis.y>0 && corrected0bis.z >0)
                        {coordImage = corrected0bis; coordImage.z = 0;}
                 else
                   if(corrected1bis.x > 0 && corrected1bis.y>0 && corrected1bis.z >0)
                        {coordImage = corrected1bis; coordImage.z = 1;}
                  else
                    if(corrected2bis.x > 0 && corrected2bis.y>0 && corrected2bis.z >0)
                        {coordImage = corrected2bis; coordImage.z = 2;}
                  else
                    if(corrected3bis.x > 0 && corrected3bis.y>0 && corrected3bis.z >0)
                        {coordImage = corrected3bis; coordImage.z = 3;}
                  else
                    if(corrected4bis.x > 0 && corrected4bis.y>0 && corrected4bis.z >0)
                        {coordImage = corrected4bis; coordImage.z = 4;}
                
                var pat = new RegExp("-[0-9][0-9]-");  // To detect and change camera number
                console.log(this.imgName);
                var imgName = this.imgName.replace(pat,"-30"+coordImage.z+"-").replace(/^.*[\\\/]/, '');
                var infoIJ = {i: coordImage.x*2048,j: coordImage.y*2048, imgName:imgName};
                return infoIJ;
               
           },
          

        
           correctDistortionAndCoord: function(dist,v_texcoord){
               
                 var cpps = 1042.178;
                 var lpps = 1020.435;
                 var width = 2048.0;
                 var height = 2048.0;
                 // vec2 pps = vec2(cpps,lpps);
            
                //var v = v_texcoord.xy/v_texcoord.w - pps;
                var v_b = new THREE.Vector3(v_texcoord.x/v_texcoord.w - cpps,
                                            v_texcoord.y/v_texcoord.w - lpps,
                                            0);
                            
                var v2 = v_b.dot(v_b);

                if(v2>dist.w) 
                    return new THREE.Vector3(-2.,-2.,-2.); // false;
                
                var  r = v2*(dist.x+v2*(dist.y+v2*dist.z));

                //var  normCoord = v_texcoord.xy/(v_texcoord.w) + r*v;
                var  normCoord = new THREE.Vector3(v_texcoord.x/v_texcoord.w + r*v_b.x,
                                                   v_texcoord.y/v_texcoord.w + r*v_b.y,
                                                   0);

                return new THREE.Vector3(normCoord.x/width , 1. - normCoord.y/height, v_texcoord.w); 
                //vec2(normCoord.x/width , 1. - normCoord.y/height); 
        },
                
           changeDistortion: function(){
            
            if(_shaderMat.uniforms['r3'].value != 0.){
                
                _shaderMat.uniforms['r3'].value = 0.;
                _shaderMat.uniforms['r5'].value = 0.;
                _shaderMat.uniforms['r7'].value = 0.;

                _shaderMat.uniforms['r30'].value = 0.;
                _shaderMat.uniforms['r50'].value = 0.;
                _shaderMat.uniforms['r70'].value = 0.;

            }
            else
                {

                _shaderMat.uniforms['r3'].value = -1.414241e-007;
                _shaderMat.uniforms['r5'].value = 3.56829e-014;
                _shaderMat.uniforms['r7'].value = -4.239262e-021;

                _shaderMat.uniforms['r30'].value = -1.335994e-007;
                _shaderMat.uniforms['r50'].value = 3.335513e-014;
                _shaderMat.uniforms['r70'].value = -3.928705e-021;
            }
              
            _shaderMat.uniforms['r3'].value.needsUpdate = true;
            _shaderMat.uniforms['r5'].value.needsUpdate = true;
            _shaderMat.uniforms['r7'].value.needsUpdate = true;
            _shaderMat.uniforms['r30'].value.needsUpdate = true;
            _shaderMat.uniforms['r50'].value.needsUpdate = true;
            _shaderMat.uniforms['r70'].value.needsUpdate = true;
        },
        
        
        changeBlending: function(){
            
            if( _shaderMat.uniforms['blendingOn'].value == 1)
                   _shaderMat.uniforms['blendingOn'].value = 0;
               else
                   _shaderMat.uniforms['blendingOn'].value = 1;

           _shaderMat.uniforms['blendingOn'].value.needsUpdate = true;
            
        },


       getShaderMat: function(){
          return _shaderMat;  
        },
        
        
        isInitiated: function(){
            return _initiated;
        },
       
        
        tweenGeneralOpacity: function(){
            console.log(" tweenGeneralOpacity");
            var i = _shaderMat.uniforms.alpha.value;
            if(i>0){
                i -= (1- (i-0.01))*0.02;
                if(i<0) i=0;
                _shaderMat.uniforms.alpha.value = i;
            }	
           requestAnimSelectionAlpha(this.tweenGeneralOpacity.bind(this));
        },
        
        tweenGeneralOpacityUp: function(){
            //console.log(" tweenGeneralOpacity", _shaderMat.uniforms.alpha.value);
            var i = _shaderMat.uniforms.alpha.value;
            if(i<1){
                i += ((i+0.01))*0.04;
                if(i>1) i=1;   
                _shaderMat.uniforms.alpha.value = i;
                
                requestAnimSelectionAlpha(this.tweenGeneralOpacityUp.bind(this));
            }	
          
        },
        
        
        setGeneralOpacity: function(value){
            _alphaP = value;
            _shaderMat.uniforms.alpha.value = _alphaP;
        },
        
        
        setFogValue: function(v){
           _shaderMat.uniforms.fog.value = v;
        },
        	
                
	tweenAllIndiceTimes: function (){
           
            this.tweenIndiceTime(0);
            this.tweenIndiceTime(1);
            this.tweenIndiceTime(2);
            this.tweenIndiceTime(3);
            this.tweenIndiceTime(4);
          
            if(this.nbL2Loaded==5 && _mobileVersion==0) {           // Test to load Level 3
                    this.nbL2Loaded=0;
                    this.loadQualityLevel(2048,80,this.imgName);
            }

            requestAnimSelectionAlpha(this.tweenAllIndiceTimes.bind(this));
	},
	
        
	tweenIndiceTime: function (num){

            var i = _shaderMat.uniforms['indice_time'+num].value;
            if(i>0){
                i -= (1- (i-0.01))*0.08;
                if(i<0) i=0;
                _shaderMat.uniforms['indice_time'+num].value = i;
            }	
	},
        
        
        setIndiceTimeCam: function(num,time){
            _shaderMat.uniforms['indice_time'+num].value = time;
        },
	
        
        setRotationHeading: function(rot){
                
           rot21 = rot;
        },
        
        getTabMatrices: function(){
            return tabMatrices;
        }
        
        
     }
     return ProjectiveTexturing2
  }
  
)
         ;
/**
 * Creates a TileTexture object
 * @class Manage TitleTexture loaded into panoramic mesh planes 
 * @author alexandre devaux IGN
 * @requires ThreeJS
 */ 

define ('TileTexture',['lib/three'], function (THREE) { 

    // nbTW,nbTH : number of trianges for w and h for the plane3D
    TileTexture = function(url,layer,formatImg,pos,sizeTileMeters,sizeTilePx,nbTiles,geom,pivotGrid,sideGrid,radiusMarge, key, sizeCell){
        
        var widthMap = nbTiles * sizeTileMeters;
        var heightMap = nbTiles * sizeTileMeters;
        this.canvasTex = document.createElement( 'canvas' );
        this.canvasTex.width = 2048;
        this.canvasTex.height = 2048;
        this.ctxTex = this.canvasTex.getContext( '2d' );
        this.opacity = 1; 
       
        this.xmt = new THREE.MeshBasicMaterial( { map: new THREE.Texture( this.canvasTex ),transparent: false, opacity:this.opacity} );
        this.xmt.side = THREE.DoubleSide;
        this.xmt.map.needsUpdate = true;
        
        this.key = key;
        
        // Create the right mesh
        var _geometry;

        if(geom){

              console.log("Tile texture using DTM",geom);
              _geometry = geom.clone(); // 
              _geometry.faceVertexUvs[0] = [];  // Erace all UVMapping if some exists
            //  var gridLength = 100; // marge = 500; 
              
               // 200 faces per line , 200 row     
             //  var sizeCell = 10; // 10 meters default -> face 4 10*10 m
               var marge = 500; //_radius + 100
               //var radiusMarge = 500;
                                         
               for(var i=0; i<sideGrid -1; ++i){
                 for(var j=0; j<sideGrid -1; ++j){
                                          
                   // if(a < geometry.vertices.length - grid.length -1 && ((a +1) % grid.length !=0)){ 
                   var verticeA = new THREE.Vector3(i*sizeCell-radiusMarge + pivotGrid.x, 0, j*sizeCell - radiusMarge+ pivotGrid.z);
                   var verticeB = new THREE.Vector3((i+1)*sizeCell-radiusMarge+ pivotGrid.x, 0, j*sizeCell - radiusMarge+ pivotGrid.z);
                   var verticeC = new THREE.Vector3(i*sizeCell-radiusMarge+ pivotGrid.x, 0, (j+1)*sizeCell - radiusMarge+ pivotGrid.z);
                   var verticeD = new THREE.Vector3((i+1)*sizeCell-radiusMarge+ pivotGrid.x, 0, (j+1)*sizeCell - radiusMarge+ pivotGrid.z);
                     
                   // We need to know for every vertices its coordinate in the map, and then normalize it
                   // Damn long cause of the projection doesn t respect axes of grid and scale.........
                   var verticeAinMap = new THREE.Vector3(verticeA.x- pos.x,0,verticeA.z - pos.y);
                   var verticeBinMap = new THREE.Vector3(verticeB.x- pos.x,0,verticeB.z - pos.y);
                   var verticeCinMap = new THREE.Vector3(verticeC.x- pos.x,0,verticeC.z - pos.y);
                   var verticeDinMap = new THREE.Vector3(verticeD.x- pos.x,0,verticeD.z - pos.y);

                   //  console.log(verticeAinMap,verticeBinMap,verticeCinMap,verticeDinMap);
                   // NORMALISATION TO UV 0-1

                   verticeAinMap.x /= widthMap;
                   verticeAinMap.z /= heightMap;
                   verticeBinMap.x /= widthMap;
                   verticeBinMap.z /= heightMap;
                   verticeCinMap.x /= widthMap;
                   verticeCinMap.z /= heightMap;
                   verticeDinMap.x /= widthMap;
                   verticeDinMap.z /= heightMap;

                   verticeAinMap.x = (verticeAinMap.x <0 || verticeAinMap.x>1) ? 0 : verticeAinMap.x;
                   verticeAinMap.z = (verticeAinMap.z <0 || verticeAinMap.z>1) ? 0 : verticeAinMap.z;
                   verticeBinMap.x = (verticeBinMap.x <0 || verticeBinMap.x>1) ? 0 : verticeBinMap.x;
                   verticeBinMap.z = (verticeBinMap.z <0 || verticeBinMap.z>1) ? 0 : verticeBinMap.z;
                   verticeCinMap.x = (verticeCinMap.x <0 || verticeCinMap.x>1) ? 0 : verticeCinMap.x;
                   verticeCinMap.z = (verticeCinMap.z <0 || verticeCinMap.z>1) ? 0 : verticeCinMap.z;
                   verticeDinMap.x = (verticeDinMap.x <0 || verticeDinMap.x>1) ? 0 : verticeDinMap.x;
                   verticeDinMap.z = (verticeDinMap.z <0 || verticeDinMap.z>1) ? 0 : verticeDinMap.z;


                    _geometry.faceVertexUvs[0].push( [
                       new THREE.Vector2( verticeAinMap.x, verticeAinMap.z ),
                       new THREE.Vector2( verticeCinMap.x, verticeCinMap.z ),
                       new THREE.Vector2( verticeBinMap.x, verticeBinMap.z ),
                    ] );

                    _geometry.faceVertexUvs[0].push( [
                       new THREE.Vector2( verticeCinMap.x, verticeCinMap.z ),
                       new THREE.Vector2( verticeDinMap.x, verticeDinMap.z ),
                       new THREE.Vector2( verticeBinMap.x, verticeBinMap.z )
                    ] );

                }
             }                                  // Tip: get Vertex from faceIndex
                                                // geometry.vertices[geometry.faces[faceIndex][ String.fromCharCode(97 + vertexIndex) ]];                      
             _geometry.computeFaceNormals(); 
             
        }else{
           console.log("Create new Geometry");
            _geometry = new THREE.Geometry();
            _geometry.vertices.push(new THREE.Vector3(0,0,0),
                                    new THREE.Vector3(0,0,2048),
                                    new THREE.Vector3(2048,0,2048),
                                    new THREE.Vector3(2048,0,0));
                                    
             _geometry.faces.push( new THREE.Face3( 0,1,3) );
             _geometry.faces.push( new THREE.Face3( 1,2,3) );
             _geometry.faceVertexUvs[ 0 ].push( [
                new THREE.Vector2( 0, 0 ),
                new THREE.Vector2( 0, 1 ),
                new THREE.Vector2( 1, 0 )
             ] );
             _geometry.faceVertexUvs[ 0 ].push( [
                new THREE.Vector2( 0, 1 ),
                new THREE.Vector2( 1, 1 ),
                new THREE.Vector2( 1, 0 )
             ] );
           /* _geometry.faces.push( new THREE.Face4( 1,2,3,0) );
            _geometry.faceVertexUvs[ 0 ].push( [
                new THREE.Vector2( 0, 1 ),
                new THREE.Vector2( 1, 1 ),
                new THREE.Vector2( 1, 0 ),
                new THREE.Vector2( 0, 0 )
             ] );
             */
            _geometry.computeFaceNormals(); 
        }
        
        
        // var mat = new THREE.MeshBasicMaterial({color:0xff00ff, wireframe:true});
        this.meshNest = new THREE.Mesh( _geometry,this.xmt);// mat);//this.xmt );   // To be added to the scene
        //this.meshNest.position.y+=0.05;//1;  // To avoid blinking!
        this.meshNest.position.y-=5;//1;  // To avoid blinking!
        this.formatImage = formatImg;
        this.url = url;
        this.layer = layer;
        this.nbLoaded = 0;
        this.tilesList = [];
        console.log(geom);
        
    };
    
    TileTexture.prototype.addTileToTextureNow = function( x, y, img) {
    
            var newTileSideSize = 256;
            var nbTiles = 8
            var yMax = 256* (nbTiles -1);
            this.nbLoaded++;
            this.ctxTex.drawImage( img, x*newTileSideSize, yMax- y*newTileSideSize);//, newTileSideSize,newTileSideSize);
            this.xmt.map.needsUpdate = true;    
            this.loadTilesFromList();
    };
    
    
     TileTexture.prototype.loadTilesFromList = function() {
         
         if(this.tilesList.length>0){
             
            var tileInfo = this.tilesList.shift();
            var that = this;
            var img = new Image();
            img.crossOrigin = "Anonymous";  // Very importan when images are not on local server. 
            (function( x, y, img ) {        // Works if http header contains Access-Control-Allow-Origin: *
                  img.onload = function() {
                      that.addTileToTextureNow( x, y, img ); 
                  };
                  img.onerror = function() {
                    console.error("Image server screwed up for this tile");
                  };
              })( tileInfo.x, tileInfo.y, img);
              img.src = tileInfo.url;
          }
     };
     
    
     TileTexture.prototype.createTilesList = function(pos,sizeTileMeters) {
        
        var nbTilesPerSide = 8; //Math.pow(2, level);
   /*     pos.x += 4*sizeTileMeters;
        pos.y += 4*sizeTileMeters;
          
        for(var x=0; x< nbTilesPerSide/2; ++x){
            for(var y=0; y< nbTilesPerSide/2; ++y){
                
                // Back
                var urlBase = "http://wxs.ign.fr/" + this.key;  //wxs-i
                var x1 = pos.x+ x *sizeTileMeters;
                var y1 = pos.y+ y *sizeTileMeters;
                var x2 = x1+sizeTileMeters;
                var y2 = y1+sizeTileMeters;
                
                urlBase += "/geoportail/r/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&CRS=IGNF:LAMB93&LAYERS="+this.layer;
                urlBase += "&STYLES=normal&WIDTH=256&HEIGHT=256&BBOX="+x1+","+y1+","+x2+","+y2;
                urlBase += "&FORMAT=image%2F"+this.formatImage; 
                                
                this.tilesList.push({url:urlBase,x:x ,y:y});
                
                // Forth
                var urlBase = "http://wxs.ign.fr/" + this.key;  //wxs-i
                var x1 = pos.x+ x *sizeTileMeters;
                var y1 = pos.y- y *sizeTileMeters;
                var x2 = x1+sizeTileMeters;
                var y2 = y1+sizeTileMeters;
                
                urlBase = "http://wxs.ign.fr/" + this.key;  //wxs-i
                urlBase += "/geoportail/r/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&CRS=IGNF:LAMB93&LAYERS="+this.layer;
                urlBase += "&STYLES=normal&WIDTH=256&HEIGHT=256&BBOX="+x1+","+y1+","+x2+","+y2;
                urlBase += "&FORMAT=image%2F"+this.formatImage; 
                                
                this.tilesList.push({url:urlBase,x:x,y:y});
            }
        }
      */  
    
        for(var x=0; x< nbTilesPerSide; ++x){
            for(var y=0; y< nbTilesPerSide; ++y){
                
                    var urlBase = "http://wxs.ign.fr/" + this.key;  //wxs-i
                    var x1 = pos.x+ x *sizeTileMeters;
                    var y1 = pos.y+ y *sizeTileMeters;
                    var x2 = x1+sizeTileMeters;
                    var y2 = y1+sizeTileMeters;

                    urlBase += "/geoportail/r/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&CRS=IGNF:LAMB93&LAYERS="+this.layer;
                    urlBase += "&STYLES=normal&WIDTH=256&HEIGHT=256&BBOX="+x1+","+y1+","+x2+","+y2;
                    urlBase += "&FORMAT=image%2F"+this.formatImage; 

                    this.tilesList.push({url:urlBase,x:x,y:y});

            }
        }
        
    };
    
    
    

       return TileTexture;
    }
);
define('Draw',['lib/three', 'GraphicEngine','Utils','ProjectiveTexturing2', 'Shader'],
    function(THREE, gfxEngine, Utils, ProjectiveTexturing2, Shader) {

    //PRIVATE MEMBERS******************************************************************************************
    //*********************************************************************************************************

    // ATTRIBUTES
    //*************************************

    var _lineMesureAddedToScene = false,
            _geometryLinesMesure,
            _lineMesure,
            // Text for mesuring. Positioned in 3D.
            _canvasText, // Canvas created to show text at 3D Pos while mesuring for example
            _canvasTextCreated = false,
            _xc, // Context 2D of the canvas
            _meshText, // mesh of the plan textured with the text
            _texture,
            _xm, // new THREE.MeshBasicMaterial    material (texture) of the mesh containing the text
            _drawnMesureValue = false, // If the mesure has been drawn to keep many on the screen
            _dist, // Distance mesured
            _textPlaneSize = 2,
            _surfaceType = null,
            _surface = null,
            _surfaceOn = false,
            _materialSurface = null,
            _materialCircle = null,
            _geometrySurface = null,
            _surfaceScale = 1,
            _rectangleMesh = null,
            _arrPtsInliers = [],
            _zebraMesh = null,
            _circleMesh = null,
            _cylinder = null,
            _zebraOn = false,
            _zebraInitiated = false,
            _roadMesh = null,
            _shaderLineMat = null,
            _nbPointsBuffer = 6,
            _bufferGeometryLine = null;  // nb points max per line


    //END OF PRIVATE MEMBERS***********************************************************************************
    //*********************************************************************************************************

    /**
     * Manages drawing functions (Canvas 2D and 3D).
     * @exports Draw
     */
    var Draw = {
        //BoundingBox 3D LIDAR
        tabBoundingBox: [], // Tab of vector3 of the Bounding box
        drawBB: false, // Boolean to start drawing the bb
        drawBB2: false,
        BBCreated: false,
        alphaBB: 0,
        heightBB: 0,
        bg: null, // = new THREE.Geometry(), // bounding box geometry
        BBMesh: null, // Mesh bounding box
        tAtemp: null, ptBtemp: null, ptCtemp: null, ptDtemp: null,
        ptA2: null, ptB2: null, ptC2: null, ptD2: null, point2: null, // New value after repere rotation
        lengthAB: null, lengthAC: null, lengthAPoint: null,
        nbClassLidar: 1.,
        lidarClassDragActive: false,
        infoBB: null,
        tabBB: [],
        tabLines: [],
        tabText: [],
        tabPoints : [],         // Points drawn from user in app
        tabPointsImported: [],  // Points drawn from imported file
        initSurface: function() {

            _surfaceOn = true;
            //meshMaterial.side = THREE.DoubleSide;
            this.initSurfacesType();
            _surface = _rectangleMesh;//_rectangleMesh;
            // _geometrySurface = new THREE.PlaneGeometry(4,2,1); 
            // _surface = THREE.SceneUtils.createMultiMaterialObject(_geometrySurface, _materialSurface);
            //gfxEngine.addToScene(_surface);
        },
        // Bug in visibility. So we play with position
        initSurfacesType: function() {

            _materialSurface = [
                new THREE.MeshBasicMaterial({color: 0xffffff, overdraw: false, depthTest: false, transparent: true, opacity: 0.5}),
                new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: true, depthTest: false, transparent: true, opacity: 0.6})
            ];

            _materialCircle = [
                new THREE.MeshBasicMaterial({color: 0xffffff, overdraw: false, transparent: true, opacity: 0.3}),
                        //new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true,transparent: true,opacity:0.6})
            ];

            var geomPlane = new THREE.PlaneGeometry(4, 2, 1);
            //_rectangleMesh = THREE.SceneUtils.createMultiMaterialObject(geomPlane, _materialSurface);
            _rectangleMesh = new THREE.Mesh(geomPlane, new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color: 0xffffff, wireframe: false, depthTest: false, transparent: true, opacity: 0.5}));
            var geomCircle = new THREE.CircleGeometry(1, 32);
            //_circleMesh    = new THREE.Mesh(geomCircle,new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest:false,transparent: true}));
           _circleMesh = new THREE.Mesh(geomCircle, new THREE.MeshBasicMaterial( { side:THREE.DoubleSide,color: 0xffffff, overdraw: false,depthTest: false, transparent: true, opacity:0.5 } ));
            ////THREE.SceneUtils.createMultiMaterialObject(geomCircle, _materialCircle);

            _circleMesh.position.y = 10000;
            _rectangleMesh.position.y = 10000;
            gfxEngine.addToScene(_rectangleMesh);
            gfxEngine.addToScene(_circleMesh);

           //TEMP
           _cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 12, 1),
                    new THREE.MeshBasicMaterial( { color: 0xffffff,  overdraw: false,depthTest:false,transparent: true, opacity:0.5 } ));
           _cylinder.position.y=40000;
           gfxEngine.addToScene(_cylinder);
           
        },
        
        setSurfaceType: function(surfaceType) {

           if(surfaceType=="Rectangle"){ 
              _surfaceType ="Rectangle"; _surface = _rectangleMesh;_circleMesh.position.y=10000;
                _surface = _rectangleMesh;
                _circleMesh.position.y = 10000;
           }else{
              _surfaceType ="Circle"; _surface = _circleMesh; _rectangleMesh.position.y=10000;
                _surface = _circleMesh;
                _rectangleMesh.position.y = 10000;
           }
        },
        
        // opacity is deducted from scale 
        // when zooming, scale decreases as so the opacity
        // to clear the view for the user
        setSurfaceScaleAndOpacity: function(scale){
            _circleMesh.scale.x = scale;
            _circleMesh.scale.y = scale;
            _rectangleMesh.scale.x = scale;
            _rectangleMesh.scale.y = scale;
            
            _circleMesh.material.opacity = scale > 0.5 ? 0.5:scale*0.8;
            _rectangleMesh.material.opacity = scale > 0.5 ? 0.5:scale*0.8;
        },
        
        drawSurface: function(pos3D, norm) {


            pos3D = gfxEngine.getPositionCloserToCam(pos3D, 0.05);  // To separate from the wall
            if (!_surfaceOn)
                this.initSurface();
            this.setSurfaceVisibility(true);
            _surface.position = pos3D;

            var vec = norm.clone();
            // the cone points up 
            var up = new THREE.Vector3(0, 0, 1);  //(0,1,0);
            var axis = new THREE.Vector3().crossVectors(up, vec);
            
            // we want the cone to point in the direction of the face normal
            // determine an axis to rotate around
            // cross will not work if vec == +up or -up, so there is a special case
            if (vec.y === 1 || vec.y === -1) {
                axis = new THREE.Vector3(1, 0, 0);
            }

            // determine the amount to rotate
            var radians = Math.acos(vec.dot(up));

            // create a rotation matrix that implements that rotation
            var mat = new THREE.Matrix4();
          //  mat.makeRotationAxis(axis, radians);   // !!!! doesnt work very well...
             mat = Utils.rotateByAxis( mat,axis, radians );
            _surface.rotation.setFromRotationMatrix(mat);

            if(_surface.rotation.x==0 || _surface.rotation.x<-3.14) this.setSurfaceType("Rectangle") 
                else this.setSurfaceType("Circle");
           // if(_surface.rotation.y==0) this.setSurfaceType("Circle") 
            //    else this.setSurfaceType("Rectangle");

        },
        
        setSurfaceColor: function(intensity){
            
            var c = new THREE.Color().setHSL( 0, intensity, 0.5 ).getHex();
      
           // _surface.material.color = 0xff00ff;
             _surface.material = new THREE.MeshBasicMaterial( { side:THREE.DoubleSide, color: c, overdraw: false, depthTest: false, transparent: true, opacity:0.7 } );
        },
        
        // Set visibility of the surface (both)
        setSurfaceVisibility: function(b) {

            _rectangleMesh.visible = _circleMesh.visible = b;
            //_surface.visible = b;
        },
        
        // userAdded means we save to tabpoints in order to export in shp or kml those specific points
        drawSphereAt: function(vec3,radius,color,userAdded){
            
            radius = radius || 0.5;
            var id = -1;
            color = color || '#'+Math.floor(Math.random()*16777215).toString(16);
            var sphere = new THREE.SphereGeometry(radius, 8, 8);
            var sphereMesh = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { transparent: true,depthTest:false, opacity: 0.8, color: color}));
            sphereMesh.position = vec3;//new THREE.Vector3(vec3.x,vec2.y,vec3.z);
            gfxEngine.addToScene(sphereMesh);
            if(userAdded){  // Means point added from 3D measure , so in order to save we put in tab
                // Look for id if imported points homolog
                if(this.tabPointsImported.length>0)
                    id = this.searchClosePointsID(vec3);
                this.tabPoints.push(new THREE.Vector4(vec3.x,vec3.y,vec3.z,id));
            }
            return id;
        },
        
        // add points 4D xyzm to tab 
        addPointsFromFile : function(v4){
            
            this.tabPointsImported.push(v4);
        },
        
        searchClosePointsID: function(v3){
            
            var found = false;
            var i=0;
            var idClosestPoint = -1;
            while (!found && i< this.tabPointsImported.length){
                var p = this.tabPointsImported[i];
                
                found = v3.distanceTo(p) < 1.0; // Homolog if 1 meter max distance
                if (found) idClosestPoint = p.w; // id on measure attrtibute
                ++i;
            }
            return idClosestPoint;
        },
        
       
        drawCircleAt: function(tileTexture, i, j, radius) {

            tileTexture.ctxTex.beginPath();
            tileTexture.ctxTex.fillStyle = "#FF4422";
            tileTexture.ctxTex.arc(i, j, 4, 0, 2 * Math.PI);
            tileTexture.ctxTex.fill();
            tileTexture.xmt.map.needsUpdate = true;
        },
        drawVerticalShapeAt: function(pos,note){
          
          _cylinder.position = pos;
          _cylinder.material.opacity = note/100;
          
        },

        /**
         * Draws a line between 2 points 3D (Vector3). used for mesuring distance
         */
        drawLine: function(point1, point2) {

            var point3D1 = null, point3D2 = null;

            if (!_lineMesureAddedToScene) {

                _lineMesureAddedToScene = true;
                //scene.removeObject(scene.objects[i]); removeObject(scene.objects[i],feat);
                _geometryLinesMesure = new THREE.Geometry();
                point3D1 = point1;
                point3D2 = point2;
                _geometryLinesMesure.vertices.push(point3D1);
                _geometryLinesMesure.vertices.push(point3D2);

                var lineMat = new THREE.LineBasicMaterial({color: 0xaaff0f, overdraw: true, transparent: true, depthTest: false, depthWrite: false, linewidth: 4})
                _lineMesure = new THREE.Line(_geometryLinesMesure, lineMat, THREE.LinePieces);
                _lineMesure.dynamic = true;
                _lineMesure.name = "lineMes";
                gfxEngine.addToScene(_lineMesure);
            } else {				// On  modifie un des sommets

                point3D1 = point1;
                point3D2 = point2;
                _lineMesure.geometry.vertices[0] = point3D1;
                _lineMesure.geometry.vertices[1] = point3D2;
                _lineMesure.geometry.verticesNeedUpdate = true;
            }
             this.tabLines.push(_lineMesure);
        },
   
        
        /**
         * Draws a line between 2 points 3D (Vector3). used for measuring distance
         */
        drawOneMoreLine: function(point1, point2) {

            var geometryLinesMesureMore = new THREE.Geometry();
            var point3D1 = point1;
            var point3D2 = point2;
            geometryLinesMesureMore.vertices.push(point3D1);
            geometryLinesMesureMore.vertices.push(point3D2);

            var lineMat = new THREE.LineBasicMaterial({color: 0xaaff0f, overdraw: true, transparent: true, depthTest: false, depthWrite: false, linewidth: 4})
            var lineMesureMore = new THREE.Line(geometryLinesMesureMore, lineMat, THREE.LinePieces);
            lineMesureMore.name = "lineMesMore" + this.tabLines.length;
            gfxEngine.addToScene(lineMesureMore);
            this.tabLines.push(lineMesureMore);
        },
        removeAllMeasures: function() {
            this.removeAllPoints();
            this.removeAllLines();
            this.removeAllText();
        },
        removeAllLines: function() {

            for (var i = 0; i < this.tabLines.length; ++i) {
                gfxEngine.removeFromScene(this.tabLines[i]);
            }
            this.tabLines = [];
        },
        
         getAllLines: function(){
            
                return this.tabLines;
        },
        
        // getLineForShapeFile Style 
        //   var polylineZ =  [
        //                    [[-180.0, 50.0, 10.], [-180, 90.0, 10.], [180.0, 90, 10.], [180, 50.0, 10.]],
        //                     [[-50, 100.0, 10.], [-40, 110, 10.], [50, 110, 10.], [60, 100, 10.]],
        //                     [[-180.0, 350.0, 10.], [-180, 390.0, 10.], [180.0, 390, 10.], [180, 350.0, 10.],[-180.0, 350.0, 10.]]
        //                 ];
        getAllLinesForSHP: function(){
            
               var polylineZ = [];
               var zero = gfxEngine.getZeroAsVec3D(); 
  
               
               for(var i = 0; i< this.tabLines.length; ++i){
                   
                   var l = this.tabLines[i].geometry.vertices;
                   var line = [];
                   for(var j = 0; j< l.length; ++j){
                       var coord = l[j];
                       var tabCoord = [];
                       tabCoord.push(coord.x + zero.x,coord.z+zero.z,coord.y+zero.y);
                       line.push(tabCoord);
                   }
                   polylineZ.push(line);
               }
               return polylineZ;
          //     console.log(polylineZ);
        },
        
        
        
        getAllPointsForSHP: function(){
            
               var pointsZ = [];
               var zero = gfxEngine.getZeroAsVec3D(); 
         
               for(var i = 0; i< this.tabPoints.length; ++i){
                   
                    var coord = this.tabPoints[i];
                    var p3DasArray = [];
                    
                    p3DasArray.push(coord.x + zero.x,coord.z+zero.z,coord.y+zero.y,coord.w);
                    pointsZ.push(p3DasArray);
               }
               return pointsZ;

        },
        
        removeAllText: function() {

            for (var i = 0; i < this.tabText.length; ++i) {
                gfxEngine.removeFromScene(this.tabText[i]);
            }
            this.tabText = [];
        },
        
        removeAllPoints : function(){
            for (var i = 0; i < this.tabPoints.length; ++i) {
                gfxEngine.removeFromScene(this.tabPoints[i]);
            }
            this.tabPoints = [];
        },
       
         
        drawLines: function(lines) {

            var zero = gfxEngine.getZero();
            for (var l in lines) {

                var line = lines[l];
                var v1 = new THREE.Vector3(line.pt1.x - zero.x,
                        line.pt1.y - zero.y,
                        line.pt1.z - zero.z);

                var v2 = new THREE.Vector3(line.pt2.x - zero.x,
                        line.pt2.y - zero.y,
                        line.pt2.z - zero.z);
                this.drawOneMoreLine(v1, v2);
                var dist = v1.distanceTo(v2).toFixed(2);
                this.showTextAtPos3D(dist + "m", v2/*gfxEngine.getPositionCloserToCam(v2,0.02)*/, 50);

            }
        },
        
        
        
        
        // Draw road profiles from alex db
        // ex: "MULTIPOINT Z (1900.89367676 21220.0527344 37.8202588181,1900
        drawProfiles: function(data, gid){

            var _pivotParis6 = {x:649000,y:0,z:6840000};
            var pivot = {x:_pivotParis6.x - gfxEngine.getZeroAsVec3D().x,
                         y:_pivotParis6.y - gfxEngine.getZeroAsVec3D().y,
                         z:_pivotParis6.z - gfxEngine.getZeroAsVec3D().z
            }
            
            for (var p in data){   // for each profile
               
                  var profile = data[p]; 
                  if( profile.gid > gid){ // to draw
                      console.log("profile.gid",profile.gid , "new data from algo!");
                      var ptTG = profile.pt_trottoirs_gauche;
                      var ptC = profile.pt_chaussee;
                      var ptTD = profile.pt_trottoirs_droite;

                      ptTG = ptTG.substring(ptTG.indexOf('(')+1);
                      ptC = ptC.substring(ptC.indexOf('(')+1);
                      ptTD = ptTD.substring(ptTD.indexOf('(')+1);

                      var arrayPtTG = ptTG.split(',');//console.log(arrayPtTG);
                      var arrayPtC = ptC.split(',');
                      var arrayPtTD = ptTD.split(',');

                      this.drawSubProfile(arrayPtTG,0xaa00aa, pivot);
                      this.drawSubProfile(arrayPtC,0x0aa0aa,  pivot);
                      this.drawSubProfile(arrayPtTD,0xaa00aa, pivot);
                 }

            }
            
        },
        
    
        createMeshFromSelectedPoints: function(arrayPoints,projectionNum){
            
             var geometry = new THREE.Geometry();
             for(var i=arrayPoints.length - 4;i< arrayPoints.length; ++i){               
                 geometry.vertices.push(arrayPoints[i]);
             }
             
             geometry.faces.push( new THREE.Face4(0,1,2,3) );
             geometry.computeFaceNormals();
             
                        
           //var mat = new THREE.MeshBasicMaterial({wireframe: true, wireframeLinewidth : 4, depthTest:false, depthWrite : false, color: 0xaaff0f});
           //var mat = new THREE.MeshBasicMaterial({wireframe: false, wireframeLinewidth : 4, depthTest:false, depthWrite : false, color: 0xffffff});
           
             var mat = ProjectiveTexturing2.getShaderMat();
              
           
           
           _roadMesh = new THREE.Mesh(geometry, mat );
           
           _roadMesh.material.side = THREE.DoubleSide; 
           _roadMesh.material.transparent = false;
           
           gfxEngine.addToScene(_roadMesh);
             
            
        },
        
        // FROM DB ALGO POINT EXTRACTED
        createMesh: function(data){

            var _pivotParis6 = {x:649000,y:0,z:6840000};
            var pivot = {x:_pivotParis6.x - gfxEngine.getZeroAsVec3D().x,
                         y:_pivotParis6.y - gfxEngine.getZeroAsVec3D().y,
                         z:_pivotParis6.z - gfxEngine.getZeroAsVec3D().z
            }
            
            
            
            var geometry = new THREE.Geometry();
             
             
            for (var i=0;i<data.length; i+=1){   // for each profile
               
              
                  var profile = data[i];     
                  
         //***TROTTOIR G et D******
                  var ptTG = profile.pt_trottoirs_gauche;
                  var ptC1 = profile.pt_chaussee;
                  var ptTD = profile.pt_trottoirs_droite;
                  
                  ptTG = ptTG.substring(ptTG.indexOf('(')+1);
                  ptC1 = ptC1.substring(ptC1.indexOf('(')+1);
                  ptTD = ptTD.substring(ptTD.indexOf('(')+1);   

                  var arrayPtTG = ptTG.split(',');
                  var arrayPtC1 = ptC1.split(',');
                  var arrayPtTD = ptTD.split(',');
                  
                  var arrayCoordGLeft = arrayPtTG[0].split(' ');
                  var arrayCoordGRight = arrayPtTG[arrayPtTG.length -1].split(' ');
                  
                  var arrayCoordDLeft = arrayPtTD[arrayPtTD.length -1].split(' ');
                  var arrayCoordDRight = arrayPtTD[0].split(' ');
                  
                         // Add right pavement vertices   
                  geometry.vertices.push(new THREE.Vector3(     parseFloat(arrayCoordDLeft[0])+ pivot.x,
                                                                parseFloat(arrayCoordDLeft[2])+ pivot.y,
                                                                parseFloat(arrayCoordDLeft[1])+ pivot.z)
                  ); 
                  geometry.vertices.push(new THREE.Vector3(     parseFloat(arrayCoordDRight[0])+ pivot.x,
                                                                parseFloat(arrayCoordDRight[2])+ pivot.y,
                                                                parseFloat(arrayCoordDRight[1])+ pivot.z)
                  );

                  
            //****CHAUSSEE    ****
               
               // Add chaussee vertices    
                  // We suppose the array of the same size
                  var nbPointsChaussee = arrayPtC1.length;
                  
                  for (var j=0; j< nbPointsChaussee; j++){
                      
                      var arrayCoord = arrayPtC1[j].split(' ');
                      geometry.vertices.push(new THREE.Vector3( parseFloat(arrayCoord[0])+ pivot.x,
                                                                parseFloat(arrayCoord[2])+ pivot.y,
                                                                parseFloat(arrayCoord[1])+ pivot.z)
                      ); 
                  }
                  
                                   
                                 
             // Add left pavement vertices    
                  geometry.vertices.push(new THREE.Vector3(     parseFloat(arrayCoordGLeft[0])+ pivot.x,
                                                                parseFloat(arrayCoordGLeft[2])+ pivot.y,
                                                                parseFloat(arrayCoordGLeft[1])+ pivot.z)
                  );
                  geometry.vertices.push(new THREE.Vector3(     parseFloat(arrayCoordGRight[0])+ pivot.x,
                                                                parseFloat(arrayCoordGRight[2])+ pivot.y,
                                                                parseFloat(arrayCoordGRight[1])+ pivot.z)
                  ); 
                  
                  
                  
         // NOW WE ADD FACES      
            
                if(i>0){    // At least we have 2 profiles already now:  indice = (nbPointsChaussee +4) * 2
                      var nbPointsPerProfile = nbPointsChaussee +4;   //4 for trottoirs G &D (2*2)+
                      
                      for (var a = geometry.vertices.length - (2 * nbPointsPerProfile); a < geometry.vertices.length - nbPointsPerProfile -1; ++a){
                           if( a+nbPointsPerProfile+1 < geometry.vertices.length){
                             geometry.faces.push( new THREE.Face3( a, a+nbPointsPerProfile,a+nbPointsPerProfile+1) );
                             geometry.faces.push( new THREE.Face3( a,a+nbPointsPerProfile+1,a+1) );
                           }  
                      }

                }       
               
            }
            
            
           geometry.computeFaceNormals();
           if(_roadMesh) gfxEngine.removeFromScene(_roadMesh);
           
           //var mat = new THREE.MeshBasicMaterial({wireframe: true, wireframeLinewidth : 4, depthTest:false, depthWrite : false, color: 0xaaff0f});
           var mat = ProjectiveTexturing2.getShaderMat();
              
           _roadMesh = new THREE.Mesh(geometry, mat );
           
           _roadMesh.material.side = THREE.DoubleSide; 
           _roadMesh.material.transparent = false;
      //     _roadMesh.material.side = THREE.DoubleSide;
           
                
           gfxEngine.addToScene(_roadMesh);
  
        },
        
         drawArrPoints : function(arrP){
              var pointGeometry  = new THREE.Geometry();
	      var colors         = [];
              for(var i= 0; i< arrP.length; i++){
                          var color = new THREE.Color(0x00ff00);
                              colors.push(color);
                              pointGeometry.vertices.push(arrP[i]);
              }
              pointGeometry.colors = colors;
              var pMaterial = new THREE.ParticleBasicMaterial( { size: 0.03, vertexColors: true, transparent: true }); // map:sprite
              var ptsNeiBors = new THREE.ParticleSystem(pointGeometry, pMaterial); 
              _arrPtsInliers.push(ptsNeiBors);
              gfxEngine.addToScene(ptsNeiBors);
         },        
        
         drawInliersPoints : function(arrP, indP){
                  var pointGeometry  = new THREE.Geometry();
                  var colors         = [];
                  for(var i= 0; i< indP.length; i++){
                              var color = new THREE.Color(0x0000ff);
                                  colors.push(color);
                                  pointGeometry.vertices.push(arrP[indP[i]]);
                  }
                  pointGeometry.colors = colors;
                  var pMaterial = new THREE.ParticleBasicMaterial( { size: 0.03, vertexColors: true, transparent: true }); // map:sprite
                  var ptsInliers = new THREE.ParticleSystem(pointGeometry, pMaterial);
                   _arrPtsInliers.push(ptsInliers);
                  gfxEngine.addToScene(ptsInliers);
         },
         
        removePtsNeibords : function (){
            for(var i=0; i < _arrPtsInliers.length; i++)
              gfxEngine.removeFromScene(_arrPtsInliers[i]);
        },
        

        // ["1900.76220703 21222.3613281 37.7839419862", "1900.75621167 21222.3610938 37.78426668", "1900.75021631 21222.3608594 37.7845900596", 
        drawSubProfile: function(arr,color, pivot){
            

            var geometryLine = new THREE.Geometry();
            
 
            for (var i=0; i< arr.length-1; i++){
                
                var arrayCoord = arr[i].split(' ');
                geometryLine.vertices.push(new THREE.Vector3( parseFloat(arrayCoord[0])+ pivot.x,
                                                              parseFloat(arrayCoord[2])+ pivot.y,
                                                              parseFloat(arrayCoord[1])+ pivot.z)
                                          );
                                              
                arrayCoord = arr[i+1].split(' ');
                geometryLine.vertices.push(new THREE.Vector3( parseFloat(arrayCoord[0])+ pivot.x,
                                                              parseFloat(arrayCoord[2])+ pivot.y,
                                                              parseFloat(arrayCoord[1])+ pivot.z)
                                          );
                
                
            }
            
            var lineMat = new THREE.LineBasicMaterial( { color: color, overdraw: true, transparent:true, depthTest:false, depthWrite : false, linewidth:2 } )
            var lineAlgo = new THREE.Line(geometryLine,lineMat,THREE.LinePieces);
            gfxEngine.addToScene(lineAlgo);
            
        },
        
        
        drawLinesNotConnected: function(arrLines,color){
            
            var color = color || 0xff00ff;
            var geometryLine = new THREE.Geometry();
            
            for (var i=0; i< arrLines.length-1; i+=2){
               
                var pt1 = arrLines[i];
                geometryLine.vertices.push(pt1);
                                              
                var pt2 = arrLines[i+1];
                geometryLine.vertices.push(pt2);
            }
            
            var lineMat = new THREE.LineBasicMaterial( { color: color, overdraw: true, transparent:true, depthTest:false, depthWrite : false, linewidth:2 } )
            var lineAlgo = new THREE.Line(geometryLine,lineMat,THREE.LinePieces);
            gfxEngine.addToScene(lineAlgo);
            
        },
        
        
        initializeTextCanvas: function() {

            _canvasText = document.createElement("canvas");
            _canvasText.width = _canvasText.height = 350;
            _canvasTextCreated = true;

        },
        setTextToCanvas: function(text, sizeFont) {
            _xc = _canvasText.getContext("2d");
            //_xc.fillStyle ="#dbbd7a";
            //_xc.fill();
            _xc.clearRect(0, 0, _canvasText.width, _canvasText.height);

            _xc.shadowColor = "#000";
            _xc.shadowBlur = 7;
            _xc.fillStyle = "rgba(173,216,230,1)";
            _xc.font = sizeFont.toString() + "pt arial bold";

            var tabText = text.split(";"); 
            for (var i = 0; i < tabText.length; ++i) {
                _xc.fillText(tabText[i], 10, (i + 1) * sizeFont);
            }
        },
        setTextMeshPosition: function(v) {

            _meshText.position = v;
        },
        initializeTextMesh: function(posx, posy, posz) {

            _xm = new THREE.MeshBasicMaterial({map: new THREE.Texture(_canvasText), transparent: true, depthTest: false});
            _xm.map.needsUpdate = true;
            _xm.side = THREE.DoubleSide;
            // depthTest: false,
            //   transparent: true

            _meshText = new THREE.Mesh(new THREE.PlaneGeometry(_textPlaneSize, _textPlaneSize), _xm);
            _meshText.name = "textMes";
            this.setTextMeshPosition(posx, posy, posz);
            _meshText.scale.x = _meshText.scale.y = _meshText.scale.z = 1;
            _meshText.quaternion = gfxEngine.getCamera().quaternion;
            //     _meshText.rotation = gfxEngine.getCamera().rotation;
            //    _meshText.updateMatrix();

        },
        
        showTextAtPos3D2: function(text, v, sizeFont) {

            if (!_canvasTextCreated) {
                this.initializeTextCanvas();
                this.setTextToCanvas(text, sizeFont);

                _texture = new THREE.Texture(_canvasText);
                _texture.needsUpdate = true;

                var material = new THREE.MeshBasicMaterial({
                    map: _texture, transparent: true
                });
                _meshText = new THREE.Mesh(new THREE.PlaneGeometry(_canvasText.width, _canvasText.height), material);
                _meshText.rotation = gfxEngine.getCamera().rotation;
                // mesh.overdraw = true;
                _meshText.doubleSided = true;
                _meshText.position = v;

                gfxEngine.addToScene(_meshText);
            }
            else {
                this.setTextMeshPosition(v);
                this.setTextToCanvas(text, sizeFont);
                _texture = new THREE.Texture(_canvasText);
                _meshText.material.map = _texture;
                _texture.needsUpdate = true; //.map.needsu
                _meshText.updateMatrix();
            }
        },
        /**
         * Uses the context 2D from the canvas drawn on a texture to show text in a specific 3D Position FOLLOWING THE MOUSE
         */
        showTextAtPos3DSameMesure: function(text, v, sizeFont) {

            sizeFont = sizeFont ||50;
            if (!_canvasTextCreated) {

                this.initializeTextCanvas();
                this.setTextToCanvas(text, sizeFont);
                this.initializeTextMesh(v);
                _xm.map.needsUpdate = true;
                _xm.side = THREE.DoubleSide;
                gfxEngine.addToScene(_meshText);
                //_meshText.doubleSided = true;
                // _meshText.updateMatrix();
                _xm.map.needsUpdate = true;
                _xm.side = THREE.DoubleSide;
            }
            else {

                this.setTextToCanvas(text, sizeFont);
                this.setTextMeshPosition(v);
                _xm.map = new THREE.Texture(_canvasText);
                _xm.map.needsUpdate = true;
                _meshText.updateMatrix();
            }
            
            this.tabText.push(_meshText);
        },
        /**
         * Use the context 2D from the canvas drawn on a texture to show text in a specific FIXED 3D Position
         */
        showTextAtPos3D: function(text, v, sizeFont) {

            sizeFont = sizeFont ||50;
            if (!_canvasTextCreated) {
                this.initializeTextCanvas();
                this.setTextToCanvas(text, sizeFont);
                this.initializeTextMesh(v);
            }
            else {
                this.setTextToCanvas(text, sizeFont);
                this.initializeTextMesh(v);
            }
            gfxEngine.addToScene(_meshText);
            this.tabText.push(_meshText);
            _canvasTextCreated = false;
        },
        /**
         * Draw a boundingbox in edition using 4 3D points coming from 2 and an height
         */
        drawBBTemp: function(ptA, ptB, ptC, ptD, h) {

            if (!this.BBCreated) {

                this.bg = new THREE.Geometry();
                this.bg.dynamic = true; //!!!! Needs to be set before adding the vertices!!
                // Base (ground)
                this.bg.vertices.push(ptA);
                this.bg.vertices.push(ptB);
                this.bg.vertices.push(ptC);
                this.bg.vertices.push(ptD);

                //Top
                this.bg.vertices.push(new THREE.Vector3(ptA.x, ptA.y + h, ptA.z));
                this.bg.vertices.push(new THREE.Vector3(ptB.x, ptB.y + h, ptB.z));
                this.bg.vertices.push(new THREE.Vector3(ptC.x, ptC.y + h, ptC.z));
                this.bg.vertices.push(new THREE.Vector3(ptD.x, ptD.y + h, ptD.z));

                this.bg.faces.push(new THREE.Face3(0, 1, 3));
                this.bg.faces.push(new THREE.Face3(0, 3, 2));
                
                
                this.bg.faces.push(new THREE.Face3(4, 5, 7));
                this.bg.faces.push(new THREE.Face3(4, 7, 6));
                
                this.bg.faces.push(new THREE.Face3(0, 1, 5));
                this.bg.faces.push(new THREE.Face3(0, 5, 4));

                this.bg.faces.push(new THREE.Face3(1, 3, 7));
                this.bg.faces.push(new THREE.Face3(1, 7, 5));
                
                this.bg.faces.push(new THREE.Face3(3, 2, 6));
                this.bg.faces.push(new THREE.Face3(3, 6, 7));
                
                this.bg.faces.push(new THREE.Face3(2, 0, 4));
                this.bg.faces.push(new THREE.Face3(2, 4, 6));
                
                this.bg.dynamic = true;

                if (this.BBMesh) {
                    this.BBMesh.position.y = 0;//-=1; 
                }

                this.BBMesh = new THREE.Mesh(this.bg, new THREE.MeshBasicMaterial({wireframe: true, wireframeLinewidth: 3, color: 0xaaff0f, transparent:true, depthTest: false}));
                this.BBMesh.geometry.dynamic = true;
                this.BBMesh.geometry.verticesNeedUpdate = true;
                this.BBMesh.dynamic = true;
                this.BBCreated = true;
                gfxEngine.addToScene(this.BBMesh);

            } else {

                this.BBMesh.geometry.vertices[0] = ptA;
                this.BBMesh.geometry.vertices[1] = ptB;
                this.BBMesh.geometry.vertices[2] = ptC;
                this.BBMesh.geometry.vertices[3] = ptD;

                this.BBMesh.geometry.vertices[4] = new THREE.Vector3(ptA.x, ptA.y + h, ptA.z);
                this.BBMesh.geometry.vertices[5] = new THREE.Vector3(ptB.x, ptB.y + h, ptB.z);
                this.BBMesh.geometry.vertices[6] = new THREE.Vector3(ptC.x, ptC.y + h, ptC.z);
                this.BBMesh.geometry.vertices[7] = new THREE.Vector3(ptD.x, ptD.y + h, ptD.z);

                this.BBMesh.geometry.__dirtyVertices = true;
                this.BBMesh.geometry.verticesNeedUpdate = true;
            }
        },
        // Display BoundingBox Info, volume, pos, width...
        displayBBInfo: function(lengthAB, lengthAC, nbPointsInBB, ptA, ptB, ptC, ptD, h, nbClassLidar) {


            if (this.infoBB) {
                this.infoBB.mesh.y -= 1; //this.infoBB.lineMesure.y-=1;
            }
            this.infoBB = InfoBox;
            var iWidth, iHeight, iLength, iVolume, iPoints, iPos, estimatedShape;
            iWidth = Math.min(Math.abs(lengthAB), Math.abs(lengthAC)).toFixed(2);
            iLength = Math.max(Math.abs(lengthAB), Math.abs(lengthAC)).toFixed(2);
            iHeight = Math.abs(h).toFixed(2);
            iVolume = (iWidth * iLength * iHeight).toFixed(2);
            iPoints = nbPointsInBB;
            iPos = new THREE.Vector3(parseFloat(ptA.x) + parseFloat(gfxEngine.getZero().x),
                    parseFloat(ptA.y) + parseFloat(gfxEngine.getZero().y) + 0.7, parseFloat(ptA.z) + parseFloat(gfxEngine.getZero().z));
            estimatedShape = "Unknown";
            if (iLength / iHeight < 0.66) {
                if (iLength < 2) {
                    estimatedShape = "Human";
                }
            } else
            {
                if (iLength / iWidth > 1.5) {
                    if (iLength > 3.5 && iLength < 7 && iHeight < 4) {
                        estimatedShape = "Car";
                    }
                    else {
                        estimatedShape = "Scooter";
                    }

                }
            }

            this.infoBB.initialize(nbClassLidar, iWidth, iHeight, iLength, iVolume, iPoints, iPos, estimatedShape);
            this.infoBB.setPosition(new THREE.Vector3(ptA.x, ptA.y + h, ptA.z));
            this.infoBB.addToScene();
            this.tabBB.push(this.infoBB);
        },
        
        addTextPanel: function(text, position, options) {
            
            // We modify the position a bit for the text not to hide the measure point
            position.x+=0.5; 
            position.y+=0.5;
            
            options = options || {}
            var style = options.style || {};
            var delimiter = options.delimiter || "\n";
            var name = options.name || "";

            var canvas = document.createElement("canvas");
            var canvasContext = canvas.getContext("2d");
            var fontSize = style.fontSize || 20;
            canvasContext.font = fontSize + "pt arial bold";// "pt bold Calibri, sans-serif";

            //split text by line
            text = text.split(delimiter);

            //compute the space needed by the canvas
            var canvasWidth = canvasContext.measureText(text[0]).width;
            var lineNumber = text.length;

            for (var i = 1; i < lineNumber; i++) {
                var currentWidth = canvasContext.measureText(text[i]).width;
                if (currentWidth > canvasWidth) { //we keep the longer text for the canvas width
                    canvasWidth = currentWidth;
                }
            }

            //set canvas dimensions
            var padding = style.padding || 10;
            canvasWidth += 2 * padding;
            canvas.width = canvasWidth;
            var lineSpace = style.lineSpace || 3;
            canvas.height = lineNumber * fontSize + 2 * padding + (lineNumber - 1) * lineSpace;

            //set canvas style (font style, colors, ...)
            canvasContext.fillStyle = 'rgba(0,51,102,0.1)'; 
            canvasContext.fillRect(0, 0, canvasWidth, canvas.height);
            canvasContext.shadowColor = "#000";
            canvasContext.shadowBlur = 7;
            canvasContext.fillStyle = 'rgba(255,255,255,1)';
            canvasContext.font = fontSize + "pt arial bold";//"pt bold Calibri, sans-serif";

            //fill canvas with text    
            for (i = 0; i < lineNumber; i++) {
                canvasContext.fillText(text[i], padding, padding + fontSize * (i + 1) + (i * lineSpace));
            }
            
            return gfxEngine.addTextPanel(canvas, position, name);
        },
        getSurfaceType: function() {
            return _surfaceType;
        },
        
        copyToClipboard : function(s) {
                if (window.clipboardData && clipboardData.setData) {
                          clipboardData.setData('text', s);
                }else console.log("browser does not support clipboard");
         },
         
         setZebraOn: function(b){
             _zebraOn = b;
         },
         
         getZebraOn: function(){
             return _zebraOn;
         },
         
         // DrawPlaneSpecific   ex pedestrian 
         initializeZebra: function(pt1,pt2){
             
            var geomPlane = new THREE.PlaneGeometry(4, 2, 1);
            geomPlane.dynamic = true;
            var texture = THREE.ImageUtils.loadTexture("images/zebra.png");
            var material = new THREE.MeshBasicMaterial({map:texture,side: THREE.DoubleSide, transparent:true, depthTest: false});
            _zebraMesh = new THREE.Mesh(geomPlane, material);//new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color: 0xffffff, wireframe: false, depthTest: false, transparent: true, opacity: 0.5}));
            gfxEngine.addToScene(_zebraMesh);

            var m = (pt2.z - pt1.z) / (pt2.x - pt1.x);
            var vecNormal = new THREE.Vector3(-m,0,1).normalize(); 
            var widthZebra = 3; 
            var pt12 = pt1.clone().add(vecNormal.clone().multiplyScalar(widthZebra));
            var pt22 = pt2.clone().add(vecNormal.clone().multiplyScalar(widthZebra));

            var vertices = _zebraMesh.geometry.vertices;
            vertices[0] = pt1;
            vertices[1] = pt2;
            vertices[2] = pt12;
            vertices[3] = pt22;
         
            _zebraInitiated = true;
         },
         
         setZebraPosition: function(pt1,pt2,stay){
             
             if(_zebraOn){
                if(!_zebraInitiated || stay == 'ON') this.initializeZebra(pt1,pt2);
                else{
                    var m = (pt2.z - pt1.z) / (pt2.x - pt1.x);
                    var vecNormal = new THREE.Vector3(-m,0,1).normalize(); 
                    var widthZebra = 3; 
                    var pt12 = pt1.clone().add(vecNormal.clone().multiplyScalar(widthZebra));
                    var pt22 = pt2.clone().add(vecNormal.clone().multiplyScalar(widthZebra));
                    var vertices = _zebraMesh.geometry.vertices;
                    vertices[0] = pt1;
                    vertices[1] = pt2;
                    vertices[2] = pt12;
                    vertices[3] = pt22;
                    _zebraMesh.geometry.verticesNeedUpdate = true;
                }
            }
         },
         
         
         
         
         
         
        // LINE 3D NEW SHADER FOR ANGLE TOO ***************************************************************
        
        
        initializeBufferGeometry: function() {

            this.createShaderLine();
          
            var _currentNbPointsInBuffer = 0;
            _bufferGeometryLine = new THREE.BufferGeometry();
            _bufferGeometryLine.dynamic = true;

            _bufferGeometryLine.attributes = {
                position: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3), // ! not float64 to gpu
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                },
                color: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3),
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                },
                displacement: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3),
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                }
            };
            
            this.initializeBufferValues();
        },
        
                
        initializeBufferValues: function() {

            var values_color = _bufferGeometryLine.attributes.color.array;
            var positions = _bufferGeometryLine.attributes.position.array;
            var displacements = _bufferGeometryLine.attributes.displacement.array;

            var color2 = new THREE.Color();
            color2.setHSL(0.2, 0.5, 0.7);
            // we set default properties: position, color, displacement
            var radius = 10;

            for (n = 0; n < _nbPointsBuffer; ++n) {

                positions[ n * 3 + 0 ] = 5;  // Camera far: 10000
                positions[ n * 3 + 1 ] = 5;  // so out of frustum
                positions[ n * 3 + 2 ] = 5;

                displacements[ n * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
                displacements[ n * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
                displacements[ n * 3 + 2 ] = (Math.random() * 2 - 1) * radius;

                values_color[ n * 3 + 0 ] = color2.r;
                values_color[ n * 3 + 1 ] = color2.g;
                values_color[ n * 3 + 2 ] = color2.b;
            }
            
        },
      
        
        
        
        createShaderLine: function() {

            var _shaderAttributes = {
                displacement: {type: 'v3', value: []},
                color: {type: 'v3', value: []},
            };

            var _shaderUniforms = {
                alpha: {type: 'f', value: 0.4},
                point_size: {type: 'f', value: 10.}
            };

            // create the shader material for the laser particle system
            // !!!!!  VERY IMPORTANT  Depthest : false to have a nice opacity in every direction
            // For BufferGeometry now we need to set everything here. Like transparent 
            _shaderLineMat = new THREE.ShaderMaterial({
                uniforms: _shaderUniforms,
                attributes: _shaderAttributes,
                vertexShader: Shader.shaders['shaderLine.vs'],
                fragmentShader: Shader.shaders['shaderLine.fs'],
                vertexColors: THREE.VertexColors,
                depthTest: false,
                side: THREE.DoubleSide,
                transparent: true
            });

        },

        
        drawLine3D: function(pt1,pt2){
            
             if(pt1==null){pt1 = new THREE.Vector3(0,0,0); pt2 = new THREE.Vector3(10,10,10);}
             
             this.initializeBufferGeometry();
  
            
             var geometryLinesIti = new THREE.Geometry();
             geometryLinesIti.vertices.push(pt1);
             geometryLinesIti.vertices.push(pt2);
             
             
             /*
                var lineMat = new THREE.LineBasicMaterial( { color: 0xaaff0f, opacity: 0.5, overdraw: true, transparent:true, depthTest:true,depthWrite : true, linewidth:4 } )
                var _lineIti = new THREE.Line(geometryLinesIti,lineMat,THREE.LinePieces);
                _lineIti.name = "lineIti";
                gfxEngine.addToScene(_lineIti);
             */
         
             //var _lineIti = new THREE.Mesh(_bufferGeometryLine,_shaderLineMat);//,THREE.LinePieces);//THREE.LineStrip);//THREE.LinePieces);
             var _lineIti = new THREE.Line(_bufferGeometryLine,_shaderLineMat);//matWire);//_shaderLineMat);
             gfxEngine.addToScene(_lineIti);


        
        
        THREE.PiecewiseLinearCurve3 = THREE.Curve.create(

            function ( points /* array of Vector3 */ ) {

                    this.points = (points == undefined) ? [] : points;

            },

            function ( t ) {

                    var points = this.points;

                    var d = ( points.length - 1 ) * t; // t should be clamped between 0 and 1

                    var index1 = Math.floor( d );
                    var index2 = ( index1 < points.length - 1 ) ? index1 + 1 : index1;

                    var	pt1 = points[ index1 ];
                    var	pt2 = points[ index2 ];

                    var weight = d - index1;

                    return new THREE.Vector3().copy( pt1 ).lerp( pt2, weight );

            }

          );

             // points
                    var points = [];
                    for( var i = 0; i < 38; i++ ) {
                            points.push( new THREE.Vector3( Math.cos( i * Math.PI / 3 ), i / 18 - 1, Math.sin( i * Math.PI / 3 ) ).multiplyScalar( 48 ) );
                    }

                    // path
                    var path = new THREE.PiecewiseLinearCurve3( points );

                    // params
                    var pathSegments = 1024; // must be a fairly big number to pass near corners
                    var tubeRadius = 0.2;
                    var radiusSegments = 8;
                    var closed = false;

                    // geometry
                    var geometry = new THREE.TubeGeometry( path, pathSegments, tubeRadius, radiusSegments, closed );

                    // material
                    var material = new THREE.MeshBasicMaterial( {
                            color: 0x4080ff, 
                            opacity: 0.4,
                            transparent: true,
                            side: THREE.DoubleSide,
                            depthTest:false
                    } );

                    // mesh
                   var  mesh = new THREE.Mesh( geometry, material );
                   gfxEngine.addToScene(mesh );
             
         /*    
           var  _particleSystem = new THREE.ParticleSystem(
                    _bufferGeometryLine,_shaderLineMat
                    );
            
            gfxEngine.addToScene(_particleSystem);
            */
        },
        
        
        
         drawLine3DTube: function(points){
             
              THREE.PiecewiseLinearCurve3 = THREE.Curve.create(

                    function ( points /* array of Vector3 */ ) {

                            this.points = (points == undefined) ? [] : points;
                    },

                    function ( t ) {

                            var points = this.points;

                            var d = ( points.length - 1 ) * t; // t should be clamped between 0 and 1

                            var index1 = Math.floor( d );
                            var index2 = ( index1 < points.length - 1 ) ? index1 + 1 : index1;

                            var	pt1 = points[ index1 ];
                            var	pt2 = points[ index2 ];

                            var weight = d - index1;

                            return new THREE.Vector3().copy( pt1 ).lerp( pt2, weight );

                    }
            );


            // path
            var path = new THREE.PiecewiseLinearCurve3( points );

            // params
            var pathSegments = 1024; // must be a fairly big number to pass near corners
            var tubeRadius = 0.5;
            var radiusSegments = 8;
            var closed = false;

            // geometry
            var geometry = new THREE.TubeGeometry( path, pathSegments, tubeRadius, radiusSegments, closed );

            // material
            var material = new THREE.MeshBasicMaterial( {
                    color: 0x4080ff, 
                    opacity: 0.8,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthTest:true
            } );

            // mesh
           var  mesh = new THREE.Mesh( geometry, material );
           return mesh;
           //gfxEngine.addToScene(mesh );


         }
        
        
        
         
         
         
         
         
         
    };


    return Draw;

});

/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/* 
 *  This module is extended from Poly2Tri 
 *  Quoc-Dinh dot Nguyen at IGN dot com
 */

define('CVML',[],function () {

      var CVML = CVML || { REVISION: '1.0.0' };
      
      CVML.epsilon = 2.220446049250313e-16;
      //Point
      
      CVML.Point2D = function (x, y) {
               this.x = x;
               this.y = y;
      };
      
      
   var PointError = function (message, points) {
        this.name    = "PointError";
        this.points  = points = points || [];
        this.message = message || "Invalid Points!";
        for (var i = 0; i < points.length; i++) {
            this.message += " " + Point.toString(points[i]);
        }
    };
    PointError.prototype = new Error();
    PointError.prototype.constructor = PointError;

    //-----Point
    /**
     * Construct a point
     * @param {Number} x    coordinate (0 if undefined)
     * @param {Number} y    coordinate (0 if undefined)
     */
    var Point = function(x, y) {
        this.x = +x || 0;
        this.y = +y || 0;

        // All extra fields added to Point are prefixed with _p2t_
        // to avoid collisions if custom Point class is used.

        // The edges this point constitutes an upper ending point
        this._p2t_edge_list = null;
    };

    /**
     * For pretty printing ex. "(5;42)"
     */
    Point.prototype.toString = function() {
        return ("(" + this.x + ";" + this.y + ")");
    };

    /**
     * Creates a copy of this Point object.
     * @returns Point
     */
    Point.prototype.clone = function() {
        return new Point(this.x, this.y);
    };

    /**
     * Set this Point instance to the origo. (0; 0)
     */
    Point.prototype.set_zero = function() {
        this.x = 0.0;
        this.y = 0.0;
        return this; // for chaining
    };

    /**
     * Set the coordinates of this instance.
     * @param   x   number.
     * @param   y   number;
     */
    Point.prototype.set = function(x, y) {
        this.x = +x || 0;
        this.y = +y || 0;
        return this; // for chaining
    };

    /**
     * Negate this Point instance. (component-wise)
     */
    Point.prototype.negate = function() {
        this.x = -this.x;
        this.y = -this.y;
        return this; // for chaining
    };

    /**
     * Add another Point object to this instance. (component-wise)
     * @param   n   Point object.
     */
    Point.prototype.add = function(n) {
        this.x += n.x;
        this.y += n.y;
        return this; // for chaining
    };

    /**
     * Subtract this Point instance with another point given. (component-wise)
     * @param   n   Point object.
     */
    Point.prototype.sub = function(n) {
        this.x -= n.x;
        this.y -= n.y;
        return this; // for chaining
    };

    /**
     * Multiply this Point instance by a scalar. (component-wise)
     * @param   s   scalar.
     */
    Point.prototype.mul = function(s) {
        this.x *= s;
        this.y *= s;
        return this; // for chaining
    };

    /**
     * Return the distance of this Point instance from the origo.
     */
    Point.prototype.length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    /**
     * Normalize this Point instance (as a vector).
     * @return The original distance of this instance from the origo.
     */
    Point.prototype.normalize = function() {
        var len = this.length();
        this.x /= len;
        this.y /= len;
        return len;
    };

    /**
     * Test this Point object with another for equality.
     * @param   p   any "Point like" object with {x,y} (duck typing)
     * @return True if this == p, false otherwise.
     */
    Point.prototype.equals = function(p) {
        return this.x === p.x && this.y === p.y;
    };

   
    /**
     * Negate a point component-wise and return the result as a new Point object.
     * @param   p   Point object.
     * @return the resulting Point object.
     */
    Point.negate = function(p) {
        return new Point(-p.x, -p.y);
    };

    /**
     * Add two points component-wise and return the result as a new Point object.
     * @param   a   Point object.
     * @param   b   Point object.
     * @return the resulting Point object.
     */
    Point.add = function(a, b) {
        return new Point(a.x + b.x, a.y + b.y);
    };

    /**
     * Subtract two points component-wise and return the result as a new Point object.
     * @param   a   Point object.
     * @param   b   Point object.
     * @return the resulting Point object.
     */
    Point.sub = function(a, b) {
        return new Point(a.x - b.x, a.y - b.y);
    };

    /**
     * Multiply a point by a scalar and return the result as a new Point object.
     * @param   s   the scalar (a number).
     * @param   p   Point object.
     * @return the resulting Point object.
     */
    Point.mul = function(s, p) {
        return new Point(s * p.x, s * p.y);
    };

    /**
     * Perform the cross product on either two points (this produces a scalar)
     * or a point and a scalar (this produces a point).
     * This function requires two parameters, either may be a Point object or a
     * number.
     * @param   a   Point object or scalar.
     * @param   b   Point object or scalar.
     * @return  a   Point object or a number, depending on the parameters.
     */
    Point.cross = function(a, b) {
        if (typeof(a) === 'number') {
            if (typeof(b) === 'number') {
                return a * b;
            } else {
                return new Point(-a * b.y, a * b.x);
            }
        } else {
            if (typeof(b) === 'number') {
                return new Point(b * a.y, -b * a.x);
            } else {
                return a.x * b.y - a.y * b.x;
            }
        }
    };

    /**
     * Point pretty printing ex."(5;42)")
     * @param   p   any "Point like" object with {x,y} 
     * @returns {String}
     */
    Point.toString = function(p) {
        // Try a custom toString first, and fallback to Point.prototype.toString if none
        var s = p.toString();
        return (s === '[object Object]' ? Point.prototype.toString.call(p) : s);
    };


    Point.compare = function(a, b) {
        if (a.y === b.y) {
            return a.x - b.x;
        } else {
            return a.y - b.y;
        }
    };
    Point.cmp = Point.compare; // backward compatibility

    Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    };

    /**
     * Peform the dot product on two vectors.
     * @param   a,b   any "Point like" objects with {x,y} 
     * @return The dot product (as a number).
     */
    Point.dot = function(a, b) {
        return a.x * b.x + a.y * b.y;
    };

	Point.prototype.distanceTo = function(v){
		var dx = this.x - v.x;
		var dy = this.y - v.y;
	    return Math.sqrt(dx * dx + dy * dy);
	}
	
    //---------Edge
    /**
     * Represents a simple polygon's edge
     * @param {Point} p1
     * @param {Point} p2
     */
    var Edge = function(p1, p2) {
        this.p = p1;
        this.q = p2;

        if (p1.y > p2.y) {
            this.q = p1;
            this.p = p2;
        } else if (p1.y === p2.y) {
            if (p1.x > p2.x) {
                this.q = p1;
                this.p = p2;
            } else if (p1.x === p2.x) {
                throw new PointError('Invalid Edge constructor: repeated points!', [p1]);
            }
        }

        if (! this.q._p2t_edge_list) {
            this.q._p2t_edge_list = [];
        }
        this.q._p2t_edge_list.push(this);
    };

   // -----Triangle
    /**
     * Triangle class.
     * Triangle-based data structures are known to have better performance than
     * quad-edge structures.
     * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
     * Delaunay Triangulator", "Triangulations in CGAL"
     * 
     * @param   a,b,c   any "Point like" objects with {x,y} (duck typing)
     */
    var Triangle = function(a, b, c) {
        // Triangle points
        this.points_ = [a, b, c];
        // Neighbor list
        this.neighbors_ = [null, null, null];
        // Has this triangle been marked as an interior triangle?
        this.interior_ = false;
        // Flags to determine if an edge is a Constrained edge
        this.constrained_edge = [false, false, false];
        // Flags to determine if an edge is a Delauney edge
        this.delaunay_edge = [false, false, false];
    };


    Triangle.prototype.toString = function() {
        var p2s = Point.toString;
        return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
    };

    Triangle.prototype.getPoint = function(index) {
        return this.points_[index];
    };
    // for backward compatibility
    Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

    Triangle.prototype.getNeighbor = function(index) {
        return this.neighbors_[index];
    };


    Triangle.prototype.containsPoint = function(point) {
        var points = this.points_;
        // Here we are comparing point references, not values
        return (point === points[0] || point === points[1] || point === points[2]);
    };

    /**
     * Test if this Triangle contains the Edge object given as parameter as its
     * bounding edges. Only point references are compared, not values.
     * @return True if the Edge object is of the Triangle's bounding
     *         edges, false otherwise.
     */
    Triangle.prototype.containsEdge = function(edge) {
        return this.containsPoint(edge.p) && this.containsPoint(edge.q);
    };
    Triangle.prototype.containsPoints = function(p1, p2) {
        return this.containsPoint(p1) && this.containsPoint(p2);
    };


    Triangle.prototype.isInterior = function() {
        return this.interior_;
    };
    Triangle.prototype.setInterior = function(interior) {
        this.interior_ = interior;
        return this;
    };

    /**
     * Update neighbor pointers.
     * @param {Point} p1 Point object.
     * @param {Point} p2 Point object.
     * @param {Triangle} t Triangle object.
     */
    Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
            this.neighbors_[0] = t;
        } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
            this.neighbors_[1] = t;
        } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
            this.neighbors_[2] = t;
        } else {
            throw new Error('Invalid Triangle.markNeighborPointers() call');
        }
    };

    /**
     * Exhaustive search to update neighbor pointers
     * @param {Triangle} t
     */
    Triangle.prototype.markNeighbor = function(t) {
        var points = this.points_;
        if (t.containsPoints(points[1], points[2])) {
            this.neighbors_[0] = t;
            t.markNeighborPointers(points[1], points[2], this);
        } else if (t.containsPoints(points[0], points[2])) {
            this.neighbors_[1] = t;
            t.markNeighborPointers(points[0], points[2], this);
        } else if (t.containsPoints(points[0], points[1])) {
            this.neighbors_[2] = t;
            t.markNeighborPointers(points[0], points[1], this);
        }
    };


    Triangle.prototype.clearNeigbors = function() {
        this.neighbors_[0] = null;
        this.neighbors_[1] = null;
        this.neighbors_[2] = null;
    };

    Triangle.prototype.clearDelunayEdges = function() {
        this.delaunay_edge[0] = false;
        this.delaunay_edge[1] = false;
        this.delaunay_edge[2] = false;
    };

    /**
     * Returns the point clockwise to the given point.
     */
    Triangle.prototype.pointCW = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return points[2];
        } else if (p === points[1]) {
            return points[0];
        } else if (p === points[2]) {
            return points[1];
        } else {
            return null;
        }
    };

    /**
     * Returns the point counter-clockwise to the given point.
     */
    Triangle.prototype.pointCCW = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return points[1];
        } else if (p === points[1]) {
            return points[2];
        } else if (p === points[2]) {
            return points[0];
        } else {
            return null;
        }
    };

    /**
     * Returns the neighbor clockwise to given point.
     */
    Triangle.prototype.neighborCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[1];
        } else if (p === this.points_[1]) {
            return this.neighbors_[2];
        } else {
            return this.neighbors_[0];
        }
    };

    /**
     * Returns the neighbor counter-clockwise to given point.
     */
    Triangle.prototype.neighborCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[2];
        } else if (p === this.points_[1]) {
            return this.neighbors_[0];
        } else {
            return this.neighbors_[1];
        }
    };

    Triangle.prototype.getConstrainedEdgeCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.constrained_edge[1];
        } else if (p === this.points_[1]) {
            return this.constrained_edge[2];
        } else {
            return this.constrained_edge[0];
        }
    };

    Triangle.prototype.getConstrainedEdgeCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.constrained_edge[2];
        } else if (p === this.points_[1]) {
            return this.constrained_edge[0];
        } else {
            return this.constrained_edge[1];
        }
    };

    Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.constrained_edge[1] = ce;
        } else if (p === this.points_[1]) {
            this.constrained_edge[2] = ce;
        } else {
            this.constrained_edge[0] = ce;
        }
    };

    Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.constrained_edge[2] = ce;
        } else if (p === this.points_[1]) {
            this.constrained_edge[0] = ce;
        } else {
            this.constrained_edge[1] = ce;
        }
    };

    Triangle.prototype.getDelaunayEdgeCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.delaunay_edge[1];
        } else if (p === this.points_[1]) {
            return this.delaunay_edge[2];
        } else {
            return this.delaunay_edge[0];
        }
    };

    Triangle.prototype.getDelaunayEdgeCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.delaunay_edge[2];
        } else if (p === this.points_[1]) {
            return this.delaunay_edge[0];
        } else {
            return this.delaunay_edge[1];
        }
    };

    Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.delaunay_edge[1] = e;
        } else if (p === this.points_[1]) {
            this.delaunay_edge[2] = e;
        } else {
            this.delaunay_edge[0] = e;
        }
    };

    Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.delaunay_edge[2] = e;
        } else if (p === this.points_[1]) {
            this.delaunay_edge[0] = e;
        } else {
            this.delaunay_edge[1] = e;
        }
    };

    /**
     * The neighbor across to given point.
     */
    Triangle.prototype.neighborAcross = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[0];
        } else if (p === this.points_[1]) {
            return this.neighbors_[1];
        } else {
            return this.neighbors_[2];
        }
    };

    Triangle.prototype.oppositePoint = function(t, p) {
        var cw = t.pointCW(p);
        return this.pointCW(cw);
    };

    /**
     * Legalize triangle by rotating clockwise around oPoint
     * @param {Point} opoint
     * @param {Point} npoint
     */
    Triangle.prototype.legalize = function(opoint, npoint) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (opoint === points[0]) {
            points[1] = points[0];
            points[0] = points[2];
            points[2] = npoint;
        } else if (opoint === points[1]) {
            points[2] = points[1];
            points[1] = points[0];
            points[0] = npoint;
        } else if (opoint === points[2]) {
            points[0] = points[2];
            points[2] = points[1];
            points[1] = npoint;
        } else {
            throw new Error('Invalid Triangle.legalize() call');
        }
    };

    /**
     * Returns the index of a point in the triangle. 
     * The point *must* be a reference to one of the triangle's vertices.
     * @param {Point} p Point object
     * @returns {Number} index 0, 1 or 2
     */
    Triangle.prototype.index = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return 0;
        } else if (p === points[1]) {
            return 1;
        } else if (p === points[2]) {
            return 2;
        } else {
            throw new Error('Invalid Triangle.index() call');
        }
    };

    Triangle.prototype.edgeIndex = function(p1, p2) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p1 === points[0]) {
            if (p2 === points[1]) {
                return 2;
            } else if (p2 === points[2]) {
                return 1;
            }
        } else if (p1 === points[1]) {
            if (p2 === points[2]) {
                return 0;
            } else if (p2 === points[0]) {
                return 2;
            }
        } else if (p1 === points[2]) {
            if (p2 === points[0]) {
                return 1;
            } else if (p2 === points[1]) {
                return 0;
            }
        }
        return -1;
    };

    /**
     * Mark an edge of this triangle as constrained
     * This method takes either 1 parameter (an edge index or an Edge instance) or
     * 2 parameters (two Point instances defining the edge of the triangle).
     */
    Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
        this.constrained_edge[index] = true;
    };
    Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
        this.markConstrainedEdgeByPoints(edge.p, edge.q);
    };
    Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
        var points = this.points_;
        // Here we are comparing point references, not values        
        if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
            this.constrained_edge[2] = true;
        } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
            this.constrained_edge[1] = true;
        } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
            this.constrained_edge[0] = true;
        }
    };

   // ------utils
    var PI_3div4 = 3 * Math.PI / 4;
    var PI_2 = Math.PI / 2;
    var EPSILON = 1e-12;

    /* 
     * Inital triangle factor, seed triangle will extend 30% of
     * PointSet width to both left and right.
     */
    var kAlpha = 0.3;

    var Orientation = {
        "CW": 1,
        "CCW": -1,
        "COLLINEAR": 0
    };

    function orient2d(pa, pb, pc) {
        var detleft = (pa.x - pc.x) * (pb.y - pc.y);
        var detright = (pa.y - pc.y) * (pb.x - pc.x);
        var val = detleft - detright;
        if (val > -(EPSILON) && val < (EPSILON)) {
            return Orientation.COLLINEAR;
        } else if (val > 0) {
            return Orientation.CCW;
        } else {
            return Orientation.CW;
        }
    }

    function inScanArea(pa, pb, pc, pd) {
        var pdx = pd.x;
        var pdy = pd.y;
        var adx = pa.x - pdx;
        var ady = pa.y - pdy;
        var bdx = pb.x - pdx;
        var bdy = pb.y - pdy;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;

        if (oabd <= (EPSILON)) {
            return false;
        }

        var cdx = pc.x - pdx;
        var cdy = pc.y - pdy;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;

        if (ocad <= (EPSILON)) {
            return false;
        }

        return true;
    }

    var Node = function(p, t) {
        this.point = p;
        this.triangle = t || null;

        this.next = null; // Node
        this.prev = null; // Node

        this.value = p.x;
    };

    var AdvancingFront = function(head, tail) {
        this.head_ = head; // Node
        this.tail_ = tail; // Node
        this.search_node_ = head; // Node
    };

    AdvancingFront.prototype.head = function() {
        return this.head_;
    };

    AdvancingFront.prototype.setHead = function(node) {
        this.head_ = node;
    };

    AdvancingFront.prototype.tail = function() {
        return this.tail_;
    };

    AdvancingFront.prototype.setTail = function(node) {
        this.tail_ = node;
    };

    AdvancingFront.prototype.search = function() {
        return this.search_node_;
    };

    AdvancingFront.prototype.setSearch = function(node) {
        this.search_node_ = node;
    };

    AdvancingFront.prototype.findSearchNode = function(/*x*/) {
        // TODO: implement BST index
        return this.search_node_;
    };

    AdvancingFront.prototype.locateNode = function(x) {
        var node = this.search_node_;

        /* jshint boss:true */
        if (x < node.value) {
            while (node = node.prev) {
                if (x >= node.value) {
                    this.search_node_ = node;
                    return node;
                }
            }
        } else {
            while (node = node.next) {
                if (x < node.value) {
                    this.search_node_ = node.prev;
                    return node.prev;
                }
            }
        }
        return null;
    };

    AdvancingFront.prototype.locatePoint = function(point) {
        var px = point.x;
        var node = this.findSearchNode(px);
        var nx = node.point.x;

        if (px === nx) {
            // Here we are comparing point references, not values
            if (point !== node.point) {
                // We might have two nodes with same x value for a short time
                if (point === node.prev.point) {
                    node = node.prev;
                } else if (point === node.next.point) {
                    node = node.next;
                } else {
                    throw new Error('Invalid AdvancingFront.locatePoint() call');
                }
            }
        } else if (px < nx) {
            /* jshint boss:true */
            while (node = node.prev) {
                if (point === node.point) {
                    break;
                }
            }
        } else {
            while (node = node.next) {
                if (point === node.point) {
                    break;
                }
            }
        }

        if (node) {
            this.search_node_ = node;
        }
        return node;
    };

   //----------Basin
    var Basin = function() {
        this.left_node = null; // Node
        this.bottom_node = null; // Node
        this.right_node = null; // Node
        this.width = 0.0; // number
        this.left_highest = false;
    };

    Basin.prototype.clear = function() {
        this.left_node = null;
        this.bottom_node = null;
        this.right_node = null;
        this.width = 0.0;
        this.left_highest = false;
    };

    //----------EdgeEvent
    var EdgeEvent = function() {
        this.constrained_edge = null; // Edge
        this.right = false;
    };

    
    /**
     * Constructor for the triangulation context.
     * It accepts a simple polyline, which defines the constrained edges.
     * Possible options are:
     *    cloneArrays:  if true, do a shallow copy of the Array parameters 
     *                  (contour, holes). Points inside arrays are never copied.
     *                  Default is false : keep a reference to the array arguments,
     *                  who will be modified in place.
     * @param {Array} contour  array of "Point like" objects with {x,y} (duck typing)
     * @param {Object} options  constructor options
     */
    var SweepContext = function(contour, options) {
        options = options || {};
        this.triangles_ = [];
        this.map_ = [];
        this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
        this.edge_list = [];

        // Bounding box of all points. Computed at the start of the triangulation, 
        // it is stored in case it is needed by the caller.
        this.pmin_ = this.pmax_ = null;

        // Advancing front
        this.front_ = null; // AdvancingFront
        // head point used with advancing front
        this.head_ = null; // Point
        // tail point used with advancing front
        this.tail_ = null; // Point

        this.af_head_ = null; // Node
        this.af_middle_ = null; // Node
        this.af_tail_ = null; // Node

        this.basin = new Basin();
        this.edge_event = new EdgeEvent();

        this.initEdges(this.points_);
        
        
    };


    /**
     * Add a hole to the constraints
     * @param {Array} polyline  array of "Point like" objects with {x,y} (duck typing)
     */
    SweepContext.prototype.addHole = function(polyline) {
        this.initEdges(polyline);
        var i, len = polyline.length;
        for (i = 0; i < len; i++) {
            this.points_.push(polyline[i]);
        }
        return this; // for chaining
    };
    // Backward compatibility
    SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


    /**
     * Add a Steiner point to the constraints
     * @param {Point} point     any "Point like" object with {x,y} (duck typing)
     */
    SweepContext.prototype.addPoint = function(point) {
        this.points_.push(point);
        return this; // for chaining
    };
    // Backward compatibility
    SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


    SweepContext.prototype.addPoints = function(points) {
        this.points_ = this.points_.concat(points);
        return this; // for chaining
    };

    SweepContext.prototype.triangulate = function() {
        Sweep.triangulate(this);
        return this; // for chaining
    };

    SweepContext.prototype.getBoundingBox = function() {
        return {min: this.pmin_, max: this.pmax_};
    };

    SweepContext.prototype.getTriangles = function() {
        return this.triangles_;
    };
    // Backward compatibility
    SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;

 
    SweepContext.prototype.front = function() {
        return this.front_;
    };

    SweepContext.prototype.pointCount = function() {
        return this.points_.length;
    };

    SweepContext.prototype.head = function() {
        return this.head_;
    };

    SweepContext.prototype.setHead = function(p1) {
        this.head_ = p1;
    };

    SweepContext.prototype.tail = function() {
        return this.tail_;
    };

    SweepContext.prototype.setTail = function(p1) {
        this.tail_ = p1;
    };

    SweepContext.prototype.getMap = function() {
        return this.map_;
    };

    SweepContext.prototype.initTriangulation = function() {
        var xmax = this.points_[0].x;
        var xmin = this.points_[0].x;
        var ymax = this.points_[0].y;
        var ymin = this.points_[0].y;

        // Calculate bounds
        var i, len = this.points_.length;
        for (i = 1; i < len; i++) {
            var p = this.points_[i];
            /* jshint expr:true */
            (p.x > xmax) && (xmax = p.x);
            (p.x < xmin) && (xmin = p.x);
            (p.y > ymax) && (ymax = p.y);
            (p.y < ymin) && (ymin = p.y);
        }
        this.pmin_ = new Point(xmin, ymin);
        this.pmax_ = new Point(xmax, ymax);

        var dx = kAlpha * (xmax - xmin);
        var dy = kAlpha * (ymax - ymin);
        this.head_ = new Point(xmax + dx, ymin - dy);
        this.tail_ = new Point(xmin - dx, ymin - dy);

        // Sort points along y-axis
        this.points_.sort(Point.compare);
    };

    SweepContext.prototype.initEdges = function(polyline) {
        var i, len = polyline.length;
        for (i = 0; i < len; ++i) {
            this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
        }
    };

    SweepContext.prototype.getPoint = function(index) {
        return this.points_[index];
    };

    SweepContext.prototype.addToMap = function(triangle) {
        this.map_.push(triangle);
    };

    SweepContext.prototype.locateNode = function(point) {
        return this.front_.locateNode(point.x);
    };

    SweepContext.prototype.createAdvancingFront = function() {
        var head;
        var middle;
        var tail;
        // Initial triangle
        var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

        this.map_.push(triangle);

        head = new Node(triangle.getPoint(1), triangle);
        middle = new Node(triangle.getPoint(0), triangle);
        tail = new Node(triangle.getPoint(2));

        this.front_ = new AdvancingFront(head, tail);

        head.next = middle;
        middle.next = tail;
        middle.prev = head;
        tail.prev = middle;
    };

    SweepContext.prototype.removeNode = function(node) {
        // do nothing
        /* jshint unused:false */
    };

    SweepContext.prototype.mapTriangleToNodes = function(t) {
        for (var i = 0; i < 3; ++i) {
            if (! t.getNeighbor(i)) {
                var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
                if (n) {
                    n.triangle = t;
                }
            }
        }
    };

    SweepContext.prototype.removeFromMap = function(triangle) {
        var i, map = this.map_, len = map.length;
        for (i = 0; i < len; i++) {
            if (map[i] === triangle) {
                map.splice(i, 1);
                break;
            }
        }
    };

    SweepContext.prototype.meshClean = function(triangle) {
        // New implementation avoids recursive calls and use a loop instead.
        // Cf. issues # 57, 65 and 69.
        var triangles = [triangle], t, i;
        /* jshint boss:true */
        while (t = triangles.pop()) {
            if (!t.isInterior()) {
                t.setInterior(true);
                this.triangles_.push(t);
                for (i = 0; i < 3; i++) {
                    if (!t.constrained_edge[i]) {
                        triangles.push(t.getNeighbor(i));
                    }
                }
            }
        }
    };

    var Sweep = {};

    Sweep.triangulate = function(tcx) {
        tcx.initTriangulation();
        tcx.createAdvancingFront();
        // Sweep points; build mesh
        Sweep.sweepPoints(tcx);
        // Clean up
        Sweep.finalizationPolygon(tcx);
    };

    Sweep.sweepPoints = function(tcx) {
        var i, len = tcx.pointCount();
        for (i = 1; i < len; ++i) {
            var point = tcx.getPoint(i);
            var node = Sweep.pointEvent(tcx, point);
            var edges = point._p2t_edge_list;
            for (var j = 0; edges && j < edges.length; ++j) {
                Sweep.edgeEventByEdge(tcx, edges[j], node);
            }
        }
    };

    Sweep.finalizationPolygon = function(tcx) {
        // Get an Internal triangle to start with
        var t = tcx.front().head().next.triangle;
        var p = tcx.front().head().next.point;
        while (!t.getConstrainedEdgeCW(p)) {
            t = t.neighborCCW(p);
        }

        // Collect interior triangles constrained by edges
        tcx.meshClean(t);
    };

    Sweep.pointEvent = function(tcx, point) {
        var node = tcx.locateNode(point);
        var new_node = Sweep.newFrontTriangle(tcx, point, node);

        // Only need to check +epsilon since point never have smaller
        // x value than node due to how we fetch nodes from the front
        if (point.x <= node.point.x + (EPSILON)) {
            Sweep.fill(tcx, node);
        }

        //tcx.AddNode(new_node);

        Sweep.fillAdvancingFront(tcx, new_node);
        return new_node;
    };

    Sweep.edgeEventByEdge = function(tcx, edge, node) {
        tcx.edge_event.constrained_edge = edge;
        tcx.edge_event.right = (edge.p.x > edge.q.x);

        if (Sweep.isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
            return;
        }

        // For now we will do all needed filling
        // TODO: integrate with flip process might give some better performance
        //       but for now this avoid the issue with cases that needs both flips and fills
        Sweep.fillEdgeEvent(tcx, edge, node);
        Sweep.edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
    };

    Sweep.edgeEventByPoints = function(tcx, ep, eq, triangle, point) {
        if (Sweep.isEdgeSideOfTriangle(triangle, ep, eq)) {
            return;
        }

        var p1 = triangle.pointCCW(point);
        var o1 = orient2d(eq, p1, ep);
        if (o1 === Orientation.COLLINEAR) {
            // TODO integrate here changes from C++ version
            throw new PointError('EdgeEvent: Collinear not supported!', [eq, p1, ep]);
        }

        var p2 = triangle.pointCW(point);
        var o2 = orient2d(eq, p2, ep);
        if (o2 === Orientation.COLLINEAR) {
            // TODO integrate here changes from C++ version
            throw new PointError('EdgeEvent: Collinear not supported!', [eq, p2, ep]);
        }

        if (o1 === o2) {
            // Need to decide if we are rotating CW or CCW to get to a triangle
            // that will cross edge
            if (o1 === Orientation.CW) {
                triangle = triangle.neighborCCW(point);
            } else {
                triangle = triangle.neighborCW(point);
            }
            Sweep.edgeEventByPoints(tcx, ep, eq, triangle, point);
        } else {
            // This triangle crosses constraint so lets flippin start!
            Sweep.flipEdgeEvent(tcx, ep, eq, triangle, point);
        }
    };

    Sweep.isEdgeSideOfTriangle = function(triangle, ep, eq) {
        var index = triangle.edgeIndex(ep, eq);
        if (index !== -1) {
            triangle.markConstrainedEdgeByIndex(index);
            var t = triangle.getNeighbor(index);
            if (t) {
                t.markConstrainedEdgeByPoints(ep, eq);
            }
            return true;
        }
        return false;
    };

    Sweep.newFrontTriangle = function(tcx, point, node) {
        var triangle = new Triangle(point, node.point, node.next.point);

        triangle.markNeighbor(node.triangle);
        tcx.addToMap(triangle);

        var new_node = new Node(point);
        new_node.next = node.next;
        new_node.prev = node;
        node.next.prev = new_node;
        node.next = new_node;

        if (!Sweep.legalize(tcx, triangle)) {
            tcx.mapTriangleToNodes(triangle);
        }

        return new_node;
    };

    Sweep.fill = function(tcx, node) {
        var triangle = new Triangle(node.prev.point, node.point, node.next.point);

        // TODO: should copy the constrained_edge value from neighbor triangles
        //       for now constrained_edge values are copied during the legalize
        triangle.markNeighbor(node.prev.triangle);
        triangle.markNeighbor(node.triangle);

        tcx.addToMap(triangle);

        // Update the advancing front
        node.prev.next = node.next;
        node.next.prev = node.prev;


        // If it was legalized the triangle has already been mapped
        if (!Sweep.legalize(tcx, triangle)) {
            tcx.mapTriangleToNodes(triangle);
        }

        //tcx.removeNode(node);
    };


    Sweep.fillAdvancingFront = function(tcx, n) {
        // Fill right holes
        var node = n.next;
        var angle;
        while (node.next) {
            angle = Sweep.holeAngle(node);
            if (angle > PI_2 || angle < -(PI_2)) {
                break;
            }
            Sweep.fill(tcx, node);
            node = node.next;
        }

        // Fill left holes
        node = n.prev;
        while (node.prev) {
            angle = Sweep.holeAngle(node);
            if (angle > PI_2 || angle < -(PI_2)) {
                break;
            }
            Sweep.fill(tcx, node);
            node = node.prev;
        }

        // Fill right basins
        if (n.next && n.next.next) {
            angle = Sweep.basinAngle(n);
            if (angle < PI_3div4) {
                Sweep.fillBasin(tcx, n);
            }
        }
    };

    Sweep.basinAngle = function(node) {
        var ax = node.point.x - node.next.next.point.x;
        var ay = node.point.y - node.next.next.point.y;
        return Math.atan2(ay, ax);
    };

    /**
     *
     * @param node - middle node
     * @return the angle between 3 front nodes
     */
    Sweep.holeAngle = function(node) {
        /* Complex plane
         * ab = cosA +i*sinA
         * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
         * atan2(y,x) computes the principal value of the argument function
         * applied to the complex number x+iy
         * Where x = ax*bx + ay*by
         *       y = ax*by - ay*bx
         */
        var ax = node.next.point.x - node.point.x;
        var ay = node.next.point.y - node.point.y;
        var bx = node.prev.point.x - node.point.x;
        var by = node.prev.point.y - node.point.y;
        return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
    };

    /**
     * Returns true if triangle was legalized
     */
    Sweep.legalize = function(tcx, t) {
        // To legalize a triangle we start by finding if any of the three edges
        // violate the Delaunay condition
        for (var i = 0; i < 3; ++i) {
            if (t.delaunay_edge[i]) {
                continue;
            }
            var ot = t.getNeighbor(i);
            if (ot) {
                var p = t.getPoint(i);
                var op = ot.oppositePoint(t, p);
                var oi = ot.index(op);

                // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
                // then we should not try to legalize
                if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                    t.constrained_edge[i] = ot.constrained_edge[oi];
                    continue;
                }

                var inside = Sweep.inCircle(p, t.pointCCW(p), t.pointCW(p), op);
                if (inside) {
                    // Lets mark this shared edge as Delaunay
                    t.delaunay_edge[i] = true;
                    ot.delaunay_edge[oi] = true;

                    // Lets rotate shared edge one vertex CW to legalize it
                    Sweep.rotateTrianglePair(t, p, ot, op);

                    // We now got one valid Delaunay Edge shared by two triangles
                    // This gives us 4 new edges to check for Delaunay

                    // Make sure that triangle to node mapping is done only one time for a specific triangle
                    var not_legalized = !Sweep.legalize(tcx, t);
                    if (not_legalized) {
                        tcx.mapTriangleToNodes(t);
                    }

                    not_legalized = !Sweep.legalize(tcx, ot);
                    if (not_legalized) {
                        tcx.mapTriangleToNodes(ot);
                    }
                    // Reset the Delaunay edges, since they only are valid Delaunay edges
                    // until we add a new triangle or point.
                    // XXX: need to think about this. Can these edges be tried after we
                    //      return to previous recursive level?
                    t.delaunay_edge[i] = false;
                    ot.delaunay_edge[oi] = false;

                    // If triangle have been legalized no need to check the other edges since
                    // the recursive legalization will handles those so we can end here.
                    return true;
                }
            }
        }
        return false;
    };

    Sweep.inCircle = function(pa, pb, pc, pd) {
        var adx = pa.x - pd.x;
        var ady = pa.y - pd.y;
        var bdx = pb.x - pd.x;
        var bdy = pb.y - pd.y;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;
        if (oabd <= 0) {
            return false;
        }

        var cdx = pc.x - pd.x;
        var cdy = pc.y - pd.y;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;
        if (ocad <= 0) {
            return false;
        }

        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;

        var alift = adx * adx + ady * ady;
        var blift = bdx * bdx + bdy * bdy;
        var clift = cdx * cdx + cdy * cdy;

        var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
        return det > 0;
    };

    Sweep.rotateTrianglePair = function(t, p, ot, op) {
        var n1, n2, n3, n4;
        n1 = t.neighborCCW(p);
        n2 = t.neighborCW(p);
        n3 = ot.neighborCCW(op);
        n4 = ot.neighborCW(op);

        var ce1, ce2, ce3, ce4;
        ce1 = t.getConstrainedEdgeCCW(p);
        ce2 = t.getConstrainedEdgeCW(p);
        ce3 = ot.getConstrainedEdgeCCW(op);
        ce4 = ot.getConstrainedEdgeCW(op);

        var de1, de2, de3, de4;
        de1 = t.getDelaunayEdgeCCW(p);
        de2 = t.getDelaunayEdgeCW(p);
        de3 = ot.getDelaunayEdgeCCW(op);
        de4 = ot.getDelaunayEdgeCW(op);

        t.legalize(p, op);
        ot.legalize(op, p);

        // Remap delaunay_edge
        ot.setDelaunayEdgeCCW(p, de1);
        t.setDelaunayEdgeCW(p, de2);
        t.setDelaunayEdgeCCW(op, de3);
        ot.setDelaunayEdgeCW(op, de4);

        // Remap constrained_edge
        ot.setConstrainedEdgeCCW(p, ce1);
        t.setConstrainedEdgeCW(p, ce2);
        t.setConstrainedEdgeCCW(op, ce3);
        ot.setConstrainedEdgeCW(op, ce4);

        // Remap neighbors
        // XXX: might optimize the markNeighbor by keeping track of
        //      what side should be assigned to what neighbor after the
        //      rotation. Now mark neighbor does lots of testing to find
        //      the right side.
        t.clearNeigbors();
        ot.clearNeigbors();
        if (n1) {
            ot.markNeighbor(n1);
        }
        if (n2) {
            t.markNeighbor(n2);
        }
        if (n3) {
            t.markNeighbor(n3);
        }
        if (n4) {
            ot.markNeighbor(n4);
        }
        t.markNeighbor(ot);
    };

    Sweep.fillBasin = function(tcx, node) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            tcx.basin.left_node = node.next.next;
        } else {
            tcx.basin.left_node = node.next;
        }

        // Find the bottom and right node
        tcx.basin.bottom_node = tcx.basin.left_node;
        while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
            tcx.basin.bottom_node = tcx.basin.bottom_node.next;
        }
        if (tcx.basin.bottom_node === tcx.basin.left_node) {
            // No valid basin
            return;
        }

        tcx.basin.right_node = tcx.basin.bottom_node;
        while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
            tcx.basin.right_node = tcx.basin.right_node.next;
        }
        if (tcx.basin.right_node === tcx.basin.bottom_node) {
            // No valid basins
            return;
        }

        tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
        tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

        Sweep.fillBasinReq(tcx, tcx.basin.bottom_node);
    };

    /**
     * Recursive algorithm to fill a Basin with triangles
     *
     * @param tcx
     * @param node - bottom_node
     */
    Sweep.fillBasinReq = function(tcx, node) {
        // if shallow stop filling
        if (Sweep.isShallow(tcx, node)) {
            return;
        }

        Sweep.fill(tcx, node);

        var o;
        if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
            return;
        } else if (node.prev === tcx.basin.left_node) {
            o = orient2d(node.point, node.next.point, node.next.next.point);
            if (o === Orientation.CW) {
                return;
            }
            node = node.next;
        } else if (node.next === tcx.basin.right_node) {
            o = orient2d(node.point, node.prev.point, node.prev.prev.point);
            if (o === Orientation.CCW) {
                return;
            }
            node = node.prev;
        } else {
            // Continue with the neighbor node with lowest Y value
            if (node.prev.point.y < node.next.point.y) {
                node = node.prev;
            } else {
                node = node.next;
            }
        }

        Sweep.fillBasinReq(tcx, node);
    };

    Sweep.isShallow = function(tcx, node) {
        var height;
        if (tcx.basin.left_highest) {
            height = tcx.basin.left_node.point.y - node.point.y;
        } else {
            height = tcx.basin.right_node.point.y - node.point.y;
        }

        // if shallow stop filling
        if (tcx.basin.width > height) {
            return true;
        }
        return false;
    };

    Sweep.fillEdgeEvent = function(tcx, edge, node) {
        if (tcx.edge_event.right) {
            Sweep.fillRightAboveEdgeEvent(tcx, edge, node);
        } else {
            Sweep.fillLeftAboveEdgeEvent(tcx, edge, node);
        }
    };

    Sweep.fillRightAboveEdgeEvent = function(tcx, edge, node) {
        while (node.next.point.x < edge.p.x) {
            // Check if next node is below the edge
            if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
                Sweep.fillRightBelowEdgeEvent(tcx, edge, node);
            } else {
                node = node.next;
            }
        }
    };

    Sweep.fillRightBelowEdgeEvent = function(tcx, edge, node) {
        if (node.point.x < edge.p.x) {
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Concave
                Sweep.fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Convex
                Sweep.fillRightConvexEdgeEvent(tcx, edge, node);
                // Retry this one
                Sweep.fillRightBelowEdgeEvent(tcx, edge, node);
            }
        }
    };

    Sweep.fillRightConcaveEdgeEvent = function(tcx, edge, node) {
        Sweep.fill(tcx, node.next);
        if (node.next.point !== edge.p) {
            // Next above or below edge?
            if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
                // Below
                if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                    // Next is concave
                    Sweep.fillRightConcaveEdgeEvent(tcx, edge, node);
                } else {
                    // Next is convex
                    /* jshint noempty:false */
                }
            }
        }
    };

    Sweep.fillRightConvexEdgeEvent = function(tcx, edge, node) {
        // Next concave or convex?
        if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
            // Concave
            Sweep.fillRightConcaveEdgeEvent(tcx, edge, node.next);
        } else {
            // Convex
            // Next above or below edge?
            if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
                // Below
                Sweep.fillRightConvexEdgeEvent(tcx, edge, node.next);
            } else {
                // Above
                /* jshint noempty:false */
            }
        }
    };

    Sweep.fillLeftAboveEdgeEvent = function(tcx, edge, node) {
        while (node.prev.point.x > edge.p.x) {
            // Check if next node is below the edge
            if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
                Sweep.fillLeftBelowEdgeEvent(tcx, edge, node);
            } else {
                node = node.prev;
            }
        }
    };

    Sweep.fillLeftBelowEdgeEvent = function(tcx, edge, node) {
        if (node.point.x > edge.p.x) {
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Concave
                Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Convex
                Sweep.fillLeftConvexEdgeEvent(tcx, edge, node);
                // Retry this one
                Sweep.fillLeftBelowEdgeEvent(tcx, edge, node);
            }
        }
    };

    Sweep.fillLeftConvexEdgeEvent = function(tcx, edge, node) {
        // Next concave or convex?
        if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
            // Concave
            Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
        } else {
            // Convex
            // Next above or below edge?
            if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
                // Below
                Sweep.fillLeftConvexEdgeEvent(tcx, edge, node.prev);
            } else {
                // Above
                /* jshint noempty:false */
            }
        }
    };

    Sweep.fillLeftConcaveEdgeEvent = function(tcx, edge, node) {
        Sweep.fill(tcx, node.prev);
        if (node.prev.point !== edge.p) {
            // Next above or below edge?
            if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
                // Below
                if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                    // Next is concave
                    Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node);
                } else {
                    // Next is convex
                    /* jshint noempty:false */
                }
            }
        }
    };

    Sweep.flipEdgeEvent = function(tcx, ep, eq, t, p) {
        var ot = t.neighborAcross(p);
        if (!ot) {
            // If we want to integrate the fillEdgeEvent do it here
            // With current implementation we should never get here
            throw new Error('[BUG:FIXME] FLIP failed due to missing triangle!');
        }
        var op = ot.oppositePoint(t, p);

        if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
            // Lets rotate shared edge one vertex CW
            Sweep.rotateTrianglePair(t, p, ot, op);
            tcx.mapTriangleToNodes(t);
            tcx.mapTriangleToNodes(ot);

            // XXX: in the original C++ code for the next 2 lines, we are
            // comparing point values (and not pointers). In this JavaScript
            // code, we are comparing point references (pointers). This works
            // because we can't have 2 different points with the same values.
            // But to be really equivalent, we should use "Point.equals" here.
            if (p === eq && op === ep) {
                if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                    t.markConstrainedEdgeByPoints(ep, eq);
                    ot.markConstrainedEdgeByPoints(ep, eq);
                    Sweep.legalize(tcx, t);
                    Sweep.legalize(tcx, ot);
                } else {
                    // XXX: I think one of the triangles should be legalized here?
                    /* jshint noempty:false */
                }
            } else {
                var o = orient2d(eq, op, ep);
                t = Sweep.nextFlipTriangle(tcx, o, t, ot, p, op);
                Sweep.flipEdgeEvent(tcx, ep, eq, t, p);
            }
        } else {
            var newP = Sweep.nextFlipPoint(ep, eq, ot, op);
            Sweep.flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
            Sweep.edgeEventByPoints(tcx, ep, eq, t, p);
        }
    };

    Sweep.nextFlipTriangle = function(tcx, o, t, ot, p, op) {
        var edge_index;
        if (o === Orientation.CCW) {
            // ot is not crossing edge after flip
            edge_index = ot.edgeIndex(p, op);
            ot.delaunay_edge[edge_index] = true;
            Sweep.legalize(tcx, ot);
            ot.clearDelunayEdges();
            return t;
        }

        // t is not crossing edge after flip
        edge_index = t.edgeIndex(p, op);

        t.delaunay_edge[edge_index] = true;
        Sweep.legalize(tcx, t);
        t.clearDelunayEdges();
        return ot;
    };

    Sweep.nextFlipPoint = function(ep, eq, ot, op) {
        var o2d = orient2d(eq, op, ep);
        if (o2d === Orientation.CW) {
            // Right
            return ot.pointCCW(op);
        } else if (o2d === Orientation.CCW) {
            // Left
            return ot.pointCW(op);
        } else {
            throw new PointError("[Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
        }
    };

    Sweep.flipScanEdgeEvent = function(tcx, ep, eq, flip_triangle, t, p) {
        var ot = t.neighborAcross(p);
        if (!ot) {
            // If we want to integrate the fillEdgeEvent do it here
            // With current implementation we should never get here
            throw new Error('[BUG:FIXME] FLIP failed due to missing triangle');
        }
        var op = ot.oppositePoint(t, p);

        if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
            // flip with new edge op.eq
            Sweep.flipEdgeEvent(tcx, eq, op, ot, op);
            // TODO: Actually I just figured out that it should be possible to
            //       improve this by getting the next ot and op before the the above
            //       flip and continue the flipScanEdgeEvent here
            // set new ot and op here and loop back to inScanArea test
            // also need to set a new flip_triangle first
            // Turns out at first glance that this is somewhat complicated
            // so it will have to wait.
        } else {
            var newP = Sweep.nextFlipPoint(ep, eq, ot, op);
            Sweep.flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
        }
    };

   var Delaunay = {
        
        _PointError : PointError,
        _Point          : Point,
        _Triangle       : Triangle,
        _SweepContext   : SweepContext,

        // Backward compatibility
        _triangulate    : Sweep.triangulate,
        _sweep : {Triangulate: Sweep.triangulate}
    
    };
    
    CVML.newPoint = function(x,y){
        return new Delaunay._Point(x,y);
    };
    
    CVML.TriangulatePoly = function(arr){
        var swctx = new Delaunay._SweepContext(arr);
            swctx.triangulate();
        return swctx.getTriangles();
    };
    
    CVML.initSweepContext = function(arr){
        return new Delaunay._SweepContext(arr);
    };
    
       
    return CVML;

});
define('Cartography',['lib/three', 'jquery', 'Utils', 'Panoramic', 'Navigation','Config', 'geoportail'],
        function(THREE, $, Utils, Panoramic, Navigation,  Config) {

            //***************************** PRIVATE MEMBERS OF MODULE ************************************************/

            // ATTRIBUTES

            var GEOPORTAL_CLASSES = ['OpenLayers', 'Geoportal'],
                    DEBUG = true,
                    __mapDivId = '', //name of div element containing the Geoportal Map
                    _apiKey = '', //key of the API contract
                    _geoportalTimer = null, //timer used by checkAPILoading
                    _currentPos = {}, //current position of the "pegsman"
                    _viewer = null, //the geoportal viewer
                    _currentPosLayer = null, //layer where current position is displayed
                    _panoramicLayer = null,
                    _itineraryLayer = null, // Layer of current ininerary
                    _laserLayer     = null,
                    _geoveloLayer = null,
                    _isDragging = false,
                    _initializing = false,
                    _initialized = false,
                    _selectedFeature = null,
                    _selectControl = null,
                    _heading = 0,
                    _topLeftCorner = {x: -20037508, y: 20037508},
                    _sizeTile = (1066.3647919248918304 * 0.28 / 1000) * 256,
                    _sizeTileLamb93 = 0,
                    _arrayTiles = [], // Array to stock tiles to load for 3D ortho
                    _arrayPosTiles = [];   // Array to stock tiles position in lamb93


            //Load the 2D Geoportal MAP and initialize it
            function initMap()


            {
                var options = {
                    mode: 'normal',
                    territory: 'FXX'
                };

                _viewer = new Geoportal.Viewer.Default(_mapDivId, options, OpenLayers.Util.extend(
                        options, window.gGEOPORTALRIGHTSMANAGEMENT === undefined ? {
                            'apiKey': 'cleok'
                        } : gGEOPORTALRIGHTSMANAGEMENT));

                if (!_viewer)
                {
                    throw new Error("Failed to intilise the Geoportal viewer");
                }

                //Remove logo and copyright
                var dirts = [_viewer.getMap().getControlsByClass('Geoportal.Control.PermanentLogo')[0],
                    _viewer.getMap().getControlsByClass('Geoportal.Control.Logo')[0],
                    _viewer.getMap().getControlsByClass('Geoportal.Control.TermsOfService')[0]];

                for (var k = 0, dirtLen = dirts.length; k < dirtLen; k++) {
                    _viewer.getMap().removeControl(dirts[k]);
                }

                //Hide copyright
                //document.getElementById("cp_Geoportal.Control.Information_55").style.display = "none";

                //---- LAYERS

                //---- PREDEFINED GEOPORTAL LAYERS
                try {

                    _viewer.addGeoportalLayer('GEOGRAPHICALGRIDSYSTEMS.MAPS', {});
                    _viewer.addGeoportalLayer('ORTHOIMAGERY.ORTHOPHOTOS', {});
                    //_viewer.addGeoportalLayer('ORTHOIMAGERY.ORTHOPHOTOS.PARIS', {});
                }
                catch (e) {
                    console.error("Something went wrong while loading one of the Geoportal layer")
                }

                // ---- OPEN DATA TREES (Paris 12)
                // @TODO : load this kind of data from db or conf files

                //         var treeLayerStyle = new OpenLayers.StyleMap(new OpenLayers.Style(
                //            {
                //             'externalGraphic': 'img/arbre.png',
                //             'graphicWidth': "${dimension}",
                //             'graphicHeight': "${dimension}"
                //            },
                //            {
                //                context: {
                //                    dimension: function (feature)
                //                    {
                //                        if (typeof(feature.attributes.count) === 'undefined') { // not a cluster, atomic feature
                //                            return 15;
                //                        }
                //                        else
                //                        {
                //                            var featuresInCluster = feature.attributes.count;
                //                            if ( featuresInCluster >= 1000){
                //                                return 40;
                //                            }
                //                            else if (featuresInCluster >= 100) {
                //                                return 30;
                //                            }
                //                            else {
                //                                return 20;
                //                            }
                //                        }
                //                    }
                //                }
                //            })
                //        );
                //
                //
                //        try {
                //            _viewer.getMap().addLayer(
                //                "WFS",
                //                'Trees',
                //                "http://localhost/cgi-bin/mapserv.exe?map=..%5Cwfs.map&", //@todo change hard coded address
                //                {typename:'trees_wfs'},
                //                {
                //                    featurePrefix:'ms',
                //                    featureNS:'http://mapserver.gis.umn.edu/mapserver',
                //                    geometryName:'msGeometry',
                //                    projection:'EPSG:2154',
                //                    maxExtent:new OpenLayers.Bounds(653227.687500,6858349.000000, 657171.625000, 6861778.000000),
                //                    styleMap:treeLayerStyle,
                //                    visibility:false,
                //                    strategies:[new OpenLayers.Strategy.Fixed(), new OpenLayers.Strategy.Cluster({
                //                        distance: 40,
                //                        threshold: 10
                //                    })]
                //                });
                //        }
                //        catch (e) {
                //            console.error("Unable to access open data on mapserver");
                //            console.error(e.message);
                //        }

                //--- CURRENT POSITION
                _currentPosLayer = new OpenLayers.Layer.Vector("Current Position");
                _viewer.getMap().addLayer(_currentPosLayer);

                var currentPosGeom = new OpenLayers.Geometry.Point(_currentPos.easting, _currentPos.northing);

                // converting from lambert93 to viewer srs
                currentPosGeom = currentPosGeom.transform(new OpenLayers.Projection("EPSG:2154"), _viewer.getMap().getProjectionObject());
                var truckFeature = new OpenLayers.Feature.Vector(currentPosGeom, {},
                        {
                            externalGraphic: "images/position.png",
                            graphicWidth: 35,
                            graphicHeight: 71
                        });

                /*var frustumFeature = new OpenLayers.Feature.Vector(currentPosGeom.clone(), {},
                 {
                 externalGraphic: "images/frustum.png",
                 graphicWidth: 46,
                 graphicHeight: 129
                 });*/

                _currentPosLayer.addFeatures([/*frustumFeature,*/truckFeature]);

                // click on map move the current position and the position in the 3D world if possible
                // add the control enabling it there
                OpenLayers.Control.Click = OpenLayers.Class(OpenLayers.Control, {
                    defaultHandlerOptions: {
                        'single': true,
                        'double': true,
                        'pixelTolerance': 0,
                        'stopSingle': false,
                        'stopDouble': false
                    },
                    handleRightClicks: true,
                    initialize: function(options) {


                        // Get control of the right-click event:
                        document.getElementById('geoportailDiv').oncontextmenu = function(e) {
                            e = e ? e : window.event;
                            if (e.preventDefault)
                                e.preventDefault(); // For non-IE browsers.
                            else
                                return false; // For IE browsers.
                        };


                        this.handlerOptions = OpenLayers.Util.extend({}, this.defaultHandlerOptions);
                        OpenLayers.Control.prototype.initialize.apply(this, arguments);
                        this.handler = new OpenLayers.Handler.Click(
                                this,
                                {
                                    'click': this.trigger,

                                }, this.handlerOptions
                                );
                    },
                    //@todo
                    trigger: function(e) {

                        var lonlat = _viewer.getMap().getLonLatFromPixel(e.xy);
                        lonlat.transform(_viewer.getMap().getProjectionObject(), new OpenLayers.Projection("EPSG:2154"));
                        Navigation.goToClosestPosition({x: lonlat.lon, y: 0, z: lonlat.lat}, {distance: 100});

                    },
                    

                });

                var click = new OpenLayers.Control.Click();
                _viewer.getMap().addControl(click);
                click.activate();

                //--- PANORAMICS (dev helper @todo see how to exclude it when building)
                if (DEBUG === true) {
                    _panoramicLayer = new OpenLayers.Layer.Vector("Zone Accquisition");

                    // _itineraryLayer **********************************************
                    _itineraryLayer = new OpenLayers.Layer.Vector("Biking Navigation");
                    _viewer.getMap().addLayer(_itineraryLayer);

                    _laserLayer = new OpenLayers.Layer.Vector("Laser Mesure");
                    _viewer.getMap().addLayer(_laserLayer);

                    _geoveloLayer= new OpenLayers.Layer.Vector("geovelo");
                    _viewer.getMap().addLayer(_geoveloLayer);

                    _selectControl = new OpenLayers.Control.SelectFeature(_panoramicLayer, {
                        onSelect: function(feature)
                        {
                            _selectedFeature = feature;
                            var popup = new OpenLayers.Popup.FramedCloud("Pano",
                                    feature.geometry.getBounds().getCenterLonLat(),
                                    null,
                                    "<div style='font-size:.8em'>\n\
                            <p>Easting : " + feature.attributes.easting + "</p>\n\
                            <p>Northing : " + feature.attributes.northing + "\n\
                            <p>Distance to position : " + feature.attributes.distance + "<p>\n\
                            <p>Orientation to position : " + feature.attributes.orientation + "<p>\n\
                        </div>",
                                    null, true, function(evt) {
                                        _selectControl.unselect(_selectedFeature)
                                    });
                            feature.popup = popup;
                        //_viewer.getMap().addPopup(popup);
                        },
                        onUnselect: function(feature) {
                            _viewer.getMap().removePopup(feature.popup);
                            feature.popup.destroy();
                            feature.popup = null;
                        },
                    hover: false
                    });
                    _viewer.getMap().addLayer(_panoramicLayer);

                //_viewer.getMap().addControl(_selectControl);
                //_selectControl.activate();
                }

                var initPos = currentPosGeom.clone();
                initPos.transform(_viewer.getMap().getProjectionObject(), new OpenLayers.Projection("CRS:84"))

                _viewer.getMap().setCenterAtLonLat(initPos.x, initPos.y, 17);

                _viewer.openToolsPanel(false);
                _viewer.openLayersPanel(false);
                _viewer.setInformationPanelVisibility(false);
                _viewer.setToolsPanelVisibility(false);

                _initialized = true;
                _initializing = false;

                //  Cartography.rotatePositionMarker(-90);//_heading); console.log("HEADIIIING",_heading);
            }

            //Displays the Geoportal map on the screen
            function displayMap()
            {
                var sentContract = Geoportal.GeoRMHandler.getConfig([_apiKey], null, 'http://gpp3-wxs.ign.fr/autoconf/$key$/',
                        {
                            onContractsComplete: initMap
                        });

                if (sentContract == 0)
                {
                    console.error("IT.Mapping.addGeoportalMap: no contract sent");
                }
            }

            // EVENT MANAGEMENT
            //*************************************
            var _events = {
                MOVE: function() {
                    Cartography.movePositionOnMap();
                }
            };

            //********************************************************************************************************/

            /**
             * Manages the 2D map of iTOWNS and provide interface to interact with it
             * @export Cartography
             * @author Mathieu Benard IGN
             */
            var Cartography = {
                /**
                 * Init the 2D map in the web browser
                 * @param {String} mapDivId Id of the div element containing the map in the html page
                 * @param {String} geoportalKey The key provide by IGN for the user contract
                 * @param {Object} initPos Initial position in the map in Lambert 93
                 * @param initPos.easting Easting coordinate
                 * @param initPos.northing Northing coordinate
                 */
                init: function(mapDivId, geoportalKey, initPos) {
                    _mapDivId = mapDivId;
                    _apiKey = geoportalKey;
                    _currentPos = {
                        easting: parseFloat(initPos.easting),
                        northing: parseFloat(initPos.northing)
                    };
                    _heading: parseFloat(initPos.heading) || 0;

                    displayMap();

                },
                
                rotatePositionMarker: function(angle) {

                    var feat = _currentPosLayer.features[0];
                    feat.style.rotation = (180 * angle / Math.PI) % 360;
                    for (var i = 0, l = _currentPosLayer.features.length; i < l; i++) {
                        _currentPosLayer.drawFeature(_currentPosLayer.features[i]);
                    }
                    // _currentPosLayer.drawFeature(feat);
                },
                movePositionOnMap: function(pos) {

                    if (typeof pos === "undefined") {
                        //we assumed that the current panoramic position has been udpated
                        pos =
                                {
                                    x: Panoramic.getPanoInfos().easting - _currentPos.easting,
                                    y: Panoramic.getPanoInfos().northing - _currentPos.northing
                                };
                    }

                    _currentPos.easting = _currentPos.easting + pos.x;
                    _currentPos.northing = _currentPos.northing + pos.y;

                    var map = _viewer.getMap();
                    var geom = _currentPosLayer.features[0].geometry;


                    //first we place the geometry in the lambert 93 coordinate system
                    geom.transform(map.getProjectionObject(), new OpenLayers.Projection("EPSG:2154"));

                    //then we apply the translation
                    geom.move(pos.x, pos.y);

                    //then we replace the geometry in the viewer map reference system
                    geom.transform(new OpenLayers.Projection("EPSG:2154"), map.getProjectionObject());
                    _currentPosLayer.drawFeature(_currentPosLayer.features[0]);

                    var lonlat = new OpenLayers.LonLat(geom.x, geom.y);
                    map.setCenter(lonlat);
                },
                getCurrentPosition : function(){
                     return new THREE.Vector3(_currentPos.easting, 0 , _currentPos.northing);
                },
                addPanoPosition: function(featureAttributes) {

                    if (_initialized == true) {
                        var currentPosGeom = new OpenLayers.Geometry.Point(featureAttributes.easting, featureAttributes.northing);
                        currentPosGeom = currentPosGeom.transform(new OpenLayers.Projection("EPSG:2154"), _viewer.getMap().getProjectionObject());

                        var featStyle = {
                            pointRadius: 2
                        };

                        var currentPosFeat = new OpenLayers.Feature.Vector(currentPosGeom, featureAttributes, featStyle);
                        _panoramicLayer.addFeatures([currentPosFeat]);
                    }
                    else if (_viewer == null && _initializing == true) {
                        var that = this;
                        window.setTimeout(function() {
                            that.addPanoPosition(featureAttributes);
                        }, 200);
                    }
                },
                inMap: function(x, y)
                {
                    Utils.inDivArea(x, y, "#" + _mapDivId);
                },
                hasPanoramixLayer: function() {
                    return _panoramicLayer != null;
                },
                cleanPanoramix: function() {
                    _panoramicLayer.removeAllFeatures();
                },
                isDragging: function() {
                    return _isDragging;
                },
                drawSegment: function(p1, p2) {

                	if (p1.z && p2.z) {
                        var point1 = new OpenLayers.Geometry.Point(p1.x, p1.z);
                        var point2 = new OpenLayers.Geometry.Point(p2.x, p2.z);
                	} else {
                		var point1 = new OpenLayers.Geometry.Point(p1.x, p1.y);
                        var point2 = new OpenLayers.Geometry.Point(p2.x, p2.y);
                	}

                    point1 = point1.transform(new OpenLayers.Projection("CRS:84"), _viewer.getMap().getProjectionObject());
                    point2 = point2.transform(new OpenLayers.Projection("CRS:84"), _viewer.getMap().getProjectionObject());

                    var featStyle = {
                        strokeWidth: 1,
                        strokeColor: "#ff0000"
                    };

                    var geomSegment = new OpenLayers.Geometry.LineString([point1, point2]);
                    var featSegment = new OpenLayers.Feature.Vector(geomSegment, {}, featStyle);
                    //var points = [new OpenLayers.Feature.Vector(point1, {}, featStyle), new OpenLayers.Feature.Vector(point2, {}, featStyle)];
                    _itineraryLayer.addFeatures([featSegment]);
                },
                processEvent: function(event) {
                    if (_events[event]) {
                        _events[event]();
                    }
                },
                // Add a point (three.Vector3) in projection specified
                addPointAtPosition: function(point, projcode) {
                    projcode = projcode || "CRS:84";
                    //var pointLayer = new OpenLayers.Layer.Vector("Panoramix");
                    var featStyle = {
                        pointRadius: 2,
                        strokeColor: "#cc00cc"
                    };
                    if ( !point.z) {
                    	var currentPosGeom = new OpenLayers.Geometry.Point(point.x, point.y);
                    } else {
                    	var currentPosGeom = new OpenLayers.Geometry.Point(point.x, point.z);
                    }

                    currentPosGeom = currentPosGeom.transform(new OpenLayers.Projection(projcode), _viewer.getMap().getProjectionObject());

                    var currentPosFeat = new OpenLayers.Feature.Vector(currentPosGeom, null, featStyle);
                    _itineraryLayer.addFeatures([currentPosFeat]);

                },
                 // Add a point (three.Vector3) in projection specified
                addPointOnMap: function(point, projcode,layer,featStyle,description) {

                    projcode = projcode || "CRS:84";
                    var currentPosGeom = new OpenLayers.Geometry.Point(point.x, point.z);
                    currentPosGeom = currentPosGeom.transform(new OpenLayers.Projection(projcode), _viewer.getMap().getProjectionObject());

                    var currentPosFeat = new OpenLayers.Feature.Vector(currentPosGeom, {name:description}, featStyle);
                    layer.addFeatures([currentPosFeat]);
                },
                // Convert a point from projection 1 to projection 2 using EPSG code
                convertCoord: function(point, projection1, projection2) {
                    var point1 = new OpenLayers.Geometry.Point(point.x, point.y);
                    point1 = point1.transform(new OpenLayers.Projection(projection1), new OpenLayers.Projection(projection2));
                    return point1;
                },
                // Convert a point from projection 1 to projection 2 using EPSG code
                convertCoordVec3: function(point, projection1, projection2) {
                    var point1 = new OpenLayers.Geometry.Point(point.x, point.z);
                    point1 = point1.transform(new OpenLayers.Projection(projection1), new OpenLayers.Projection(projection2));
                    return new THREE.Vector3(point1.x, point.y, point1.y);
                },
                // reverse param for geocoding. If reverse then we search an address from a pos
                buildOLSRequest: function(location, reverse) {

                    var request = '<?xml version="1.0" encoding="UTF-8"?><XLS xmlns:gml="http://www.opengis.net/gml"\
                       xmlns="http://www.opengis.net/xls" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\
                       version="1.2"  xsi:schemaLocation="http://www.opengis.net/xls http://schemas.opengis.net/ols/1.2/olsAll.xsd">\
                       <RequestHeader srsName="epsg:2154"/><Request maximumResponses="10" methodName="GeocodeRequest" version="1.2">';

                    if (!reverse) {
                        request += '<GeocodeRequest><Address countryCode="StreetAddress,PositionOfInterest"><freeFormAddress>';
                        request += location + '</freeFormAddress></Address></GeocodeRequest></Request></XLS>';
                    }
                    else {
                        request += ' <ReverseGeocodeRequest><!-- countryCode="StreetAddress" --><ReverseGeocodePreference>StreetAddress</ReverseGeocodePreference><Position><gml:Point><gml:pos>';
                        request += location + '</gml:pos></gml:Point></Position></ReverseGeocodeRequest></Request></XLS>';
                    }

                    return encodeURI(request);
                },
                /**
                 * Send an OpenLocationService (OLS) request in a free form address with the paramater location.
                 * If the request succeed and is not empty, it looks for the closest panoramic and if one exists, it
                 * moves to that panoramic.
                 * ADD ALEX, reverse parameter: boolean if true then reverse geocode (pos -> address)
                 */
                sendOLSRequest: function(location, reverse) {

                    if (location !== "") { //location is empty when enter is keyed with completion
                        var OLSRequest;
                        if (!reverse)
                            OLSRequest = this.buildOLSRequest(location, false);
                        else
                            OLSRequest = this.buildOLSRequest(location, true);

                        $.getJSON("http://wxs.ign.fr/" + Config.geoAPIKey + "/geoportail/ols?xls=" + OLSRequest + "&output=json&callback=?")
                                .done(function(data) {
                                    var format = new OpenLayers.Format.XLS();
                                    var output = format.read(data.xml);
                                    if (output.getNbBodies() > 0) { //the OLS service returns something
                                        if (!reverse) {
                                            var firstGeocodeResponse = output.getBodies()[0].getResponseParameters().getGeocodeResponseList()[0];
                                            if (firstGeocodeResponse.getNbGeocodedAddresses() > 0) { //at least one location has been found
                                                var position = firstGeocodeResponse.getGeocodedAddresses()[0].lonlat;
                                                console.log('pos',position);
                                                require("Navigation").goToClosestPosition({x: position.y, y: 0, z: position.x}, {distance: 250});
                                            }
                                        } else {
                                            var firstGeocodeResponse = output.getBodies()[0].getResponseParameters();//.getGeocodeResponseList()[0];

                                            if (firstGeocodeResponse.getNbReverseGeocodedLocations() > 0) {//getNbReverseGeocodedLocations() > 0) { //at least one location has been found
                                                var street = firstGeocodeResponse.getReverseGeocodedLocations()[0];
                                               // console.log(street.address);
                                                street = street.address.toString().replace('[Ville]', '');
                                                street = street.substring(0,street.indexOf('['));
                                                street = street.substring(0,street.lastIndexOf(','));
                                                //console.log(street);
                                                $(".localisation-text").text(street + "   |   Easting : " + Panoramic.getPanoInfos().easting + " - Northing : " + Panoramic.getPanoInfos().northing + " (lambert 93)");
                                                //return street;
                                            }
                                        }
                                    }
                                })
                                .fail(function(data) {
                                    console.error("something went wrong");
                                });

                    }
                },
                //*********************************** 3D Carto ******************************************

                create3DCarto: function(point, level, radius) {

                    this.loadTilesAroundPos(point, level, radius);

                    // We no have the array with all the tiles url to load: arrayTiles
                    return _arrayTiles;
                },

                        // WMTS ***********************************************************************************************************
                        // Load tiles around a specified position at a zoom level
                        //  and a radius for area size to load
                        loadTilesAroundPos: function(point, level, radius) {

                            // get tile closest to my pos     (cord in tile col/row)
                            var tileInfo = this.getTileCoordAtPos(point, level); // ex {x:250000, y:2054544}

                            // Get this tile position in Lamb93
                            var tilePosX = tileInfo.x * _sizeTile + _topLeftCorner.x;
                            var tilePosY = -tileInfo.y * _sizeTile + _topLeftCorner.y;
                            console.log('tilPosMercator', tilePosX, tilePosY);

                            var closestTileAtpos = {x: tileInfo.x, y: tileInfo.y};

                            for (var i = -radius; i < radius; ++i) {

                                for (var j = -radius; j < radius; ++j) {

                                    var xMercator = tilePosX + i * _sizeTile;
                                    var yMercator = tilePosY + j * _sizeTile;
                                    var Lamb93 = this.convertCoord({x: xMercator, y: yMercator}, "EPSG:3857", "EPSG:2154");
                                    var tilUrlCoord = {x: closestTileAtpos.x + i, y: closestTileAtpos.y - j};
                                    this.loadTileAtCoord({x: tilUrlCoord.x, y: tilUrlCoord.y},
                                    level,
                                            {x: Lamb93.x, y: Lamb93.y}
                                    );
                                }
                            }

                        },

                // We compute the size of the tiles in meters in Mercator sys
                computeSizeTile: function(level) {

                    var scaleDenominator = 1066.3647919248918304;
                    switch (level) {
                        case 19:
                            scaleDenominator = 1066.3647919248918304;
                            break;
                        case 18:
                            scaleDenominator = 2132.7295838497840572;
                            break;
                        case 17:
                            scaleDenominator = 4265.4591676995681144;
                            break;
                        case 16:
                            scaleDenominator = 8530.9183353991362289;
                            break;
                        case 15:
                            scaleDenominator = 17061.8366707982724577;
                            break;
                        case 14:
                            scaleDenominator = 34123.6733415965449154;
                            break;
                    }

                    var sizeTile = (scaleDenominator * 0.28 / 1000) * 256;
                    //console.log(sizeTile);
                    return sizeTile;
                },

                getTileCoordAtPos: function(point, sizeTile) {

                    var coordTile = {x: 0, y: 0};
                    var p = this.convertCoord(point, "EPSG:2154", "EPSG:3857");
                    //console.log('current pos in Mercator: ',p);
                    var x = p.x - _topLeftCorner.x;
                    var y = _topLeftCorner.y - p.y;

                    coordTile.x = Math.floor(x / sizeTile);
                    coordTile.y = Math.floor(y / sizeTile);

                    return {x: coordTile.x, y: coordTile.y}//, px:p.x, py:p.y}                  },
                },
                loadTileAtCoord: function(coordTile, level, point93) {

                    this.getTileImgURL(level, coordTile.y, coordTile.x, point93);

                },
                getTileImgURL: function(level, tileRow, tileCol, point93) {

                    var formatImage = "png";  // jpeg
                    var zone = ".PARIS"; // ""   if empty then national ortho else paris for high reso on capital
                    var key = "z0sxz2r5pnuy669h11vlm982";
                    var urlBase = "http://wxs-i.ign.fr/" + key;
                    urlBase += "/geoportail/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&STYLE=normal&TILEMATRIXSET=PM&TILEMATRIX=";
                    urlBase += level + "&TILEROW=" + tileRow + "&TILECOL=" + tileCol + "&FORMAT=image%2F" + formatImage;
                    console.log(urlBase);
                    _arrayTiles.push(urlBase);
                    _arrayPosTiles.push(point93);
                },
                // WMS ***********************************************************************************************************

                getViewer : function(){
                    return _viewer;
                },

                loadTilesAroundPosWMS: function(point, level, radius) {

                    // get tile closest to my pos     (cord in tile col/row)
                    var tileInfo = this.getTileCoordAtPos(point, level); // ex {x:250000, y:2054544}

                    // Get this tile position in Lamb93
                    var tilePosX = tileInfo.x * _sizeTile + _topLeftCorner.x;
                    var tilePosY = -tileInfo.y * _sizeTile + _topLeftCorner.y;
                    console.log('tilPosMercator', tilePosX, tilePosY);

                    var closestTileAtpos = {x: tileInfo.x, y: tileInfo.y};

                    for (var i = -radius; i < radius; ++i) {

                        for (var j = -radius; j < radius; ++j) {

                            var xMercator = tilePosX + i * _sizeTile;
                            var yMercator = tilePosY + j * _sizeTile;
                            var Lamb93 = this.convertCoord({x: xMercator, y: yMercator}, "EPSG:3857", "EPSG:2154");
                            var tilUrlCoord = {x: closestTileAtpos.x + i, y: closestTileAtpos.y - j};
                            this.loadTileAtCoord({x: tilUrlCoord.x, y: tilUrlCoord.y},
                            level,
                                    {x: Lamb93.x, y: Lamb93.y}
                            );
                        }
                    }

                },
                getArrayTiles: function() {
                    return _arrayTiles;
                },
                getArrayPosTiles: function() {
                    return _arrayPosTiles;
                },
                showZoneAccquisition: function() {
                    var that = this;
                    var featStyle = {
                            pointRadius : 6,
                            fill        : true,
                            fillColor   : "rgba(0,127,127,0.75)",
                            fillOpacity : 0.5,
                            stroke      : false
                    };
                     if (_viewer != null) {
                            $.post("php/getAllPanoPos.php",
                                    function(jsondata) {
                                            var arr = JSON.parse(jsondata);
                                            for (var i = 0; i < arr.length; i++) {
                                                Cartography.addPointOnMap(arr[i], "EPSG:2154",_panoramicLayer,featStyle);
                                            }
                            });
                     } else {
                            window.setTimeout(function() {
                                       that.showZoneAccquisition();
                             }, 200);
                     }
                            console.log("add zone accquisition!");
                },

                getLayerFromName: function(name){

                    var layer
                    switch(name){
                        case "geovelo": layer = _geoveloLayer; break;
                        default: layer = _laserLayer; break;
                    }

                    return layer;
                },

                showPointMeasureOnMap: function(pt,featStyle,layer,description) {
                    var that = this;
                    var layer = this.getLayerFromName(layer) || _laserLayer;
                    featStyle = featStyle || {
                            pointRadius : 3,
                            fill        : true,
                            fillColor   : "#ff00ff",
                            fillOpacity : 0.7,
                            stroke      : false
                    };
                    if (_viewer != null) {
                            Cartography.addPointOnMap(pt, "EPSG:2154",layer,featStyle,description);
                    } else {
                            window.setTimeout(function() {
                                            that.showPointMeasureOnMap(pt,null,layer,featStyle,description);
                                 }, 200);
                    }
                },

                showLineMeasureOnMap: function(p1,p2,layer, projcode,featStyle) {
                    var that  = this;
                    projcode  = projcode  ||  "CRS:84";
                    featStyle = featStyle || {
                        strokeWidth: 1.5,
                        strokeColor: "#ffaa00"
                    };
                    if (_viewer != null) {
                            Cartography.drawLineOnMap(p1,p2,layer,projcode,featStyle);
                    } else {
                            window.setTimeout(function() {
                                            that.showLineMeasureOnMap(p1,p2,layer, projcode,featStyle);
                                 }, 200);
                    }
                },


                drawLineOnMap: function(p1, p2,layer,projcode,featStyle) {
                    var point1 = new OpenLayers.Geometry.Point(p1.x, p1.z);
                        point1 = point1.transform(new OpenLayers.Projection(projcode), _viewer.getMap().getProjectionObject());
                    var point2 = new OpenLayers.Geometry.Point(p2.x, p2.z);
                        point2 = point2.transform(new OpenLayers.Projection(projcode), _viewer.getMap().getProjectionObject());
                    var geomSegment = new OpenLayers.Geometry.LineString([point1, point2]);
                    var featSegment = new OpenLayers.Feature.Vector(geomSegment, {}, featStyle);
                        layer.addFeatures([featSegment]);
                },

                removeAllFeature : function(layer){
                    layer.removeAllFeatures();
                },

                getLaserLayer : function(){
                    return _laserLayer;
                },

                getItineraryLayer: function() {
                	return _itineraryLayer;
                }

            };


            return Cartography;

        }
);



    define ('MeshManager',['GraphicEngine','jquery', 'Config', 'lib/three','Utils','ProjectiveTexturing2','Ori','TileTexture','Draw','CVML','Cartography'],
        function(gfxEngine, $, Config, THREE, Utils,  ProjectiveTexturing2, Ori, TileTexture, Draw, CVML) {




        var _geometry = null,
            _currentObject = {name:"not attributed"},
            _currentObjectToDrag = null,   // Object to drag with mouse3D
            _projectiveMaterial = null,
            _currentMeshForClickAndGo = null,  // Simplify mesh for faster search
            _visibility = true,
            _configStereo = 1,    // indicates what stereopolis version we use
                                  // 0 old version 10 cam, 1 for the 5 cam new version

            //RGE
           _rgeCurrentPositionE  = 0.0,
           _rgeCurrentPositionN  = 0.0,
           _rgeLastPositionE     = 0.0,
           _rgeLastPositionN     = 0.0,
           _radius               = 250,//200,//400,
           _sizeCell  		 = 10, // Size grid cell , ex: 10 meters      
           
           //ROOF
           _meshRoof = null,
           
           //DTM
           _showDTM = false,
           _pivotGrid = new THREE.Vector3(),
           _gridDTM  = new Array(),  // From Bati
           _gridDTM2 = new Array(), // From Stereopolis
           _gridFES = new Array(),
           _geomDTM = null,
           _meshDTM = null,
           _meshCartoFES = null,  // TEMP to intersect with huge mesh carto
           
           //Carto
           _orthoPhotoOn = false,
           _sizeTile = 0,
           _topLeftCorner = {x:-20037508,y:20037508},
           _tabMapMesh = [],
           _roadOn = true,
           
           _urlBuildingFootprint = '',
           _urlDTM ='',
           _localFootprintFile = false,
           _localDTMFile = false;


        var Manager = {
           
            panoInfo:null,
            skyBox:null,  // Optional skybox while not at Camera original position
             
            init : function (info, dataURL) {
                
                // URL Service/DATA from DATAURL     
                _urlBuildingFootprint   = dataURL.urlBuildingFootprint || Config.dataURL.defaultUrlBuildingFootprint;
                _localFootprintFile     = _urlBuildingFootprint.indexOf("http") < 0;
                _urlDTM                 = dataURL.urlDTM   || Config.dataURL.defaultUrlDTM;
                _localDTMFile           = _urlDTM.indexOf("php") < 0;
                
                if(gfxEngine.isMobileEnvironment()) _radius = 100;
             
                this.panoInfo           = info;
                _rgeCurrentPositionE    = info.easting;
                _rgeCurrentPositionN    = info.northing;
                _rgeLastPositionE       = _rgeCurrentPositionE;
                _rgeLastPositionN       = _rgeCurrentPositionN;
                
                
               
                // *************** TEMP to switch between stereopolis config *******
                 this.checkStereopolisVersionFromPosition();
                 this.loadAndCreateMeshFromDB();

                /*
                    var layer = "ORTHOIMAGERY.ORTHOPHOTOS.PARIS"//.PARIS";
                    if (info.easting > 656000 || info.easting < 640000 || info.northing > 6869000 || info.northing < 6860000)
                        layer = "ORTHOIMAGERY.ORTHOPHOTOS.ORTHOPHOTOS";

                    var currentPos = {x: info.easting, z: info.northing};
                    MeshManager.generateCartoPlane({x: currentPos.x, y: currentPos.z}, 18, 10, layer, "jpeg");
		   // this.generateCartoPlanePARIS({x: currentPos.x, y: currentPos.z}, 18, 10, layer, "jpeg");
		*/			
					
            },

           updateDataFromRGE: function(){
               //console.log('updateDataFromRGE');
                 //check if data loading is necessary for this move!
                var  info = this.panoInfo;
                     _rgeCurrentPositionE  = info.easting;
                     _rgeCurrentPositionN  = info.northing;
                 var dist = Math.sqrt((_rgeCurrentPositionE - _rgeLastPositionE)*(_rgeCurrentPositionE - _rgeLastPositionE) +
                                      (_rgeCurrentPositionN - _rgeLastPositionN)*(_rgeCurrentPositionN - _rgeLastPositionN));
                 
                 // If we go to the limit of the exsting RGE loaded we load a new area
                 if(dist >= _radius*0.8){  
                      console.log('load NEW RGE DATA');
                      if(_tabMapMesh.length>0) this.removeMapMeshes();  // Carto
                    
                      this.getDTMFromTrajectory();
                      //this.searchPolygonBatiAround(_rgeCurrentPositionE,_rgeCurrentPositionN,_radius);
                      //update last position
                      _rgeLastPositionE = _rgeCurrentPositionE;
                      _rgeLastPositionN = _rgeCurrentPositionN;
                     
                      
                 }            
           },
           
           // SOON Removed after 12 area redone
           checkStereopolisVersionFromPosition: function(){
     
            _configStereo = 1; // New camera system 
            var name = this.panoInfo.filename;
            if(name.substr(0, 6) == 'Paris_' || name.substr(0, 2) == 'Te')
                _configStereo = 0;  // Old Stereopolis


           },
           
           
           forceUpdateRGE: function(){
               
                 console.log("forceUpdateRGE");
                 var  info = this.panoInfo;
                     _rgeCurrentPositionE  = info.easting;
                     _rgeCurrentPositionN  = info.northing;

                 this.searchPolygonBatiAround(_rgeCurrentPositionE,_rgeCurrentPositionN,_radius);
                      //update last position
                 _rgeLastPositionE = _rgeCurrentPositionE;
                 _rgeLastPositionN = _rgeCurrentPositionN;
             
           },


           // Load a mesh from PostGIS DB. Example: RGE, Bati
           loadAndCreateMeshFromDB: function(){
               
               console.log("load and create mesh DTM then BATI from footprint");
               this.getDTMFromTrajectory();
               //this.searchPolygonBatiAround(_rgeCurrentPositionE,_rgeCurrentPositionN,_radius);
           },

           // Load jsut Cubic geometry for new cam configuration
           loadAndCreateMeshFromDBNewCam: function(){

             this.createGeometry3DfromPoly2([]);
           },


           /*
            * @documentation: Search for bati footprint in PostGIS or WFS around position and launch on callback the creation of the mesh
            * @param {type} easting
            * @param {type} northing
            * @param {type} radius
            * @returns {undefined}
            */
           searchPolygonBatiAround: function(easting, northing ,radius){
               
               
               /******** TEMP
                *  allow switching between stereopolis configuration
                *  supposing that east north not in paris implies acquisition with new config
                */
               this.checkStereopolisVersionFromPosition();
               // **********************************************************************************************
               console.log('config', _configStereo);
               //*****************************************
               var that= this;
               
               if(!_localFootprintFile){        // WFS BATITOPO
                   
                    var bottomLeft = new THREE.Vector2(easting - radius, northing - radius);
                    var topRight   = new THREE.Vector2(easting + radius, northing + radius);
                    var key = "72hpsel8j8nhb5qgdh07gcyp";
                    var serviceVersionRequestLayer = "service=WFS&version=2.0.0&REQUEST=GetFeature&typeName=BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie"
                    //http://wxs.ign.fr/72hpsel8j8nhb5qgdh07gcyp/geoportail/wfs?service=WFS&version=2.0.0&REQUEST=GetFeature
                    //&typeName=BDTOPO_BDD_WLD_WGS84G:bati_indifferencie&srsName=EPSG:2154&bbox=651941.31,6861621.12,652341.31,6862021.12,EPSG:2154&outputFormat=json
                    
                    var urlWFS = _urlBuildingFootprint+key+"/geoportail/wfs?"+serviceVersionRequestLayer+
                                 "&srsName=EPSG:2154&bbox="+bottomLeft.x+","+bottomLeft.y+","+topRight.x+","+topRight.y+",EPSG:2154&outputFormat=json";
                    $.getJSON(urlWFS, function (data){
                            that.createGeometry3DfromPoly(data,true);
                        });
               }else{    
                    $.getJSON(_urlBuildingFootprint, function (data){
                            that.createGeometry3DfromPoly(data,true);
                        });
                  /*
                   // DATABASE POSTGIS
                        var server = (location.host == "www.itowns.fr") ? "itowns" : "local";
                        $.getJSON(Config.phpDir + "getBatiRGE.php?easting="+ easting +"&northing="+northing+"&radius="+radius+"&server="+server, function (data){
                                that.createGeometry3DfromPoly(data);//,pointBB);
                            });
                   */
                }
          },
          
        

         

          generatePointOnCircle : function (centerx, centery, circleradius, totalpoints, startangle, arc, pointdirection) {
                startangle = startangle || 0;
                arc = arc || 360;
                pointdirection = pointdirection || "clockwise";
               
                var pts = [];
                var diameter = circleradius*2;

                var mpi = Math.PI/180;
                var startRadians = 0 * mpi;

                var incrementAngle = arc/totalpoints;
                var incrementRadians = incrementAngle * mpi;


                while(totalpoints--) {
                    var xp = centerx + Math.sin(startRadians) * circleradius;
                    var yp = centery + Math.cos(startRadians) * circleradius;
                    pts.push({x:xp, y:yp});

                    if(pointdirection=="antiClockwise") {
                        startRadians += incrementRadians;
                    } else {
                        startRadians -= incrementRadians;
                    }
                }

                return pts;
          },
          
          

          // [{"geom":"POLYGON((651317.7 6861303.4,651317.3 6861308.8,651308.6 6861304.1,651308.6 6861302.4,651317.7 6861303.4))","h":"3.7","alti":"38"}...]
          // configStereo indicates what camera type we have 0 is 10 cam, 1 is the new config with 5 cam
          createGeometry3DfromPoly: function(data,WFSOption){

             
              _geometry = new THREE.Geometry();
              var geometry = new THREE.Geometry();  // for the roof
              var geometryClickToGo = new THREE.Geometry();  // facades with Simple road  (no dtm)
              var heightApplanixOnTruck = 2;
              var zero = gfxEngine.getZeroAsVec3D();
              var altiSolTruck = this.panoInfo.altitude - zero.y - heightApplanixOnTruck;
              var radiusMarge = _radius + 100;
              var suppHauteur = 10;   // So we don't cut the roof
              
              if(WFSOption){
                
                var features = data.features; 
                for( var r = 0 ; r <features.length ; r++){
                 
                    var hauteur       = (features[r].properties.hauteur + suppHauteur) || 0;
                    var altitude_sol  = 0;//curRow.alti - zero.y || altiSolTruck;
                    var polygon       = features[r].geometry.coordinates[0][0];
                  
                    if(polygon.length > 2){

                                var strHex = 0xffffff;   //'#'+Math.floor(Math.random()*16777215).toString(16);                              
                                var arrPoint2D = [];
                               
                                // VERTICES
                                for(var j=0; j< polygon.length -1; ++j){
                                   
                                    var pt2DTab   = polygon[j];   //.split(' ');
                                    var p1  = new THREE.Vector3(parseFloat(pt2DTab[0]) - zero.x, 0, parseFloat(pt2DTab[1]) -  zero.z);
                                   
                                   // NEW: GET ALTI FROM GENERATED DTM
                                   var indx = Math.floor((p1.x - _pivotGrid.x + radiusMarge)/10);
                                   var indy = Math.floor((p1.z - _pivotGrid.z + radiusMarge)/10);
                                   if(indx >0 && indx < _gridDTM2.length && indy>0 && indy<_gridDTM2.length){
                                       altitude_sol = _gridDTM2[indx][indy];
                                   }

                                   var vector3_1 = new THREE.Vector3(p1.x,altitude_sol,p1.z);
                                   var vector3_2 = new THREE.Vector3(p1.x,altitude_sol+hauteur,p1.z);
                                   arrPoint2D.push(CVML.newPoint(p1.x,p1.z)); //for roof
                                   _geometry.vertices.push(vector3_1,vector3_2);
                                }
                               
                               
                                // FACES
                                // indice of the first point of the polygon 3D
                                for(var k = _geometry.vertices.length - ((polygon.length -1)* 2); k< _geometry.vertices.length ; k=k+2){

                                     var l = k;   // % (pts2DTab.length);
                                     if(l>_geometry.vertices.length-4){
                                         l = _geometry.vertices.length - ((polygon.length -1) * 2);
                                     }
                                     _geometry.faces.push(new THREE.Face3(l, l + 1, l + 3));
                                     _geometry.faces.push(new THREE.Face3(l, l + 3, l + 2));
                                 }
                                 
                                 var ll = _geometry.vertices.length - ((polygon.length -1)* 2);
                                 _geometry.faces.push(new THREE.Face3(ll, ll +1, _geometry.vertices.length-1));
                                 _geometry.faces.push(new THREE.Face3(ll, _geometry.vertices.length-1, _geometry.vertices.length-2));
                                   
                  }

                 //**************** ROOF ****************************
                               var triangles = CVML.TriangulatePoly(arrPoint2D);
                               //var geometry = new THREE.Geometry();  // for the roof
                               triangles.forEach(function(t) {
                                   
                                   var pt1  = t.getPoint(0),  
                                       pt2  = t.getPoint(1),
                                       pt3  = t.getPoint(2);

                                   //var geometry = new THREE.Geometry();
                                   geometry.vertices.push(new THREE.Vector3(pt1.x, altitude_sol + hauteur,pt1.y));
                                   geometry.vertices.push(new THREE.Vector3(pt2.x, altitude_sol + hauteur,pt2.y));
                                   geometry.vertices.push(new THREE.Vector3(pt3.x, altitude_sol + hauteur,pt3.y));

                                   var face = new THREE.Face3(            
                                                             geometry.vertices.length -3,
                                                             geometry.vertices.length -2,
                                                             geometry.vertices.length -1
                                   );
                                   geometry.faces.push(face);
     
                                });
   
                        }
                  
                  
              } else{
                  

                for( var r = 0 ; r <data.length ; r++){

                      var curRow = data[r];
                      var polygonArray  = curRow.geom.replace("POLYGON((" ,'').replace("))",'');
                          polygonArray  = polygonArray.split('),(');
                      var polygon       = polygonArray[0].split(',');

                      var hauteur      = (curRow.h + suppHauteur) || 0;
                      var altitude_sol = curRow.alti - zero.y || altiSolTruck;

                      if(polygon.length > 2){

                                  var strHex = 0xffffff;   //'#'+Math.floor(Math.random()*16777215).toString(16);                              
                                  var arrPoint2D = [];

                                  // VERTICES
                                  for(var j=0; j< polygon.length -1; ++j){

                                      var pt2DTab   = polygon[j].split(' ');
                                      var p1  = new THREE.Vector3(parseFloat(pt2DTab[0]) - zero.x, 0, parseFloat(pt2DTab[1]) -  zero.z);

                                     // NEW: GET ALTI FROM GENERATED DTM
                                     var indx = Math.floor((p1.x - _pivotGrid.x + radiusMarge)/10);
                                     var indy = Math.floor((p1.z - _pivotGrid.z + radiusMarge)/10);
                                     if(indx >0 && indx < _gridDTM2.length && indy>0 && indy<_gridDTM2.length){
                                         altitude_sol = _gridDTM2[indx][indy];
                                     }

                                     var vector3_1 = new THREE.Vector3(p1.x,altitude_sol,p1.z);
                                     var vector3_2 = new THREE.Vector3(p1.x,altitude_sol+hauteur,p1.z);
                                     arrPoint2D.push(CVML.newPoint(p1.x,p1.z)); //for roof
                                     _geometry.vertices.push(vector3_1,vector3_2);
                                  }


                                  // FACES
                                  // indice of the first point of the polygon 3D
                                  for(var k = _geometry.vertices.length - ((polygon.length -1)* 2); k< _geometry.vertices.length ; k=k+2){

                                       var l = k;   // % (pts2DTab.length);
                                       if(l>_geometry.vertices.length-4){
                                           l = _geometry.vertices.length - ((polygon.length -1) * 2);
                                       }
                                       _geometry.faces.push(new THREE.Face3(l, l + 1, l + 3));
                                       _geometry.faces.push(new THREE.Face3(l, l + 3, l + 2));
                                   }

                                   var ll = _geometry.vertices.length - ((polygon.length -1)* 2);
                                   _geometry.faces.push(new THREE.Face3(ll, ll +1, _geometry.vertices.length-1));
                                   _geometry.faces.push(new THREE.Face3(ll, _geometry.vertices.length-1, _geometry.vertices.length-2));

                    }

                   //**************** ROOF ****************************
                                 var triangles = CVML.TriangulatePoly(arrPoint2D);
                                 //var geometry = new THREE.Geometry();  // for the roof
                                 triangles.forEach(function(t) {

                                     var pt1  = t.getPoint(0),  
                                         pt2  = t.getPoint(1),
                                         pt3  = t.getPoint(2);

                                     //var geometry = new THREE.Geometry();
                                     geometry.vertices.push(new THREE.Vector3(pt1.x, altitude_sol + hauteur,pt1.y));
                                     geometry.vertices.push(new THREE.Vector3(pt2.x, altitude_sol + hauteur,pt2.y));
                                     geometry.vertices.push(new THREE.Vector3(pt3.x, altitude_sol + hauteur,pt3.y));

                                     var face = new THREE.Face3(            
                                                               geometry.vertices.length -3,
                                                               geometry.vertices.length -2,
                                                               geometry.vertices.length -1
                                     );
                                     geometry.faces.push(face);

                                  });

                          }
                    }

                        if(_meshRoof) gfxEngine.removeFromScene(_meshRoof);
                        _meshRoof = new THREE.Mesh(geometry,new THREE.MeshBasicMaterial({color: strHex, transparent: true, opacity:0.6 }));
                        _meshRoof.geometry.verticesNeedUpdate = true;
                        _meshRoof.material.side = THREE.DoubleSide;
                        _meshRoof.visible = _visibility;  // So if panoramic is hidden, the roof too
                        gfxEngine.addToScene(_meshRoof);


       //*** ROAD  *** Let s add a road if(roadOn)
                var centerTruckX = this.panoInfo.easting  - gfxEngine.getZeroAsVec3D().x;
                var centerTruckY = this.panoInfo.altitude - gfxEngine.getZeroAsVec3D().y;
                var centerTruckZ = this.panoInfo.northing - gfxEngine.getZeroAsVec3D().z;
               
                geometryClickToGo = _geometry.clone();
                
                if(_roadOn){  // AND CUBE
                   
                  // Version using SIMPLE PLANE ROAD for Click and Go
                       var roadLength = 500
                       geometryClickToGo.vertices.push(new THREE.Vector3(centerTruckX-roadLength,altiSolTruck,centerTruckZ-roadLength),
                               new THREE.Vector3(centerTruckX-roadLength,altiSolTruck,centerTruckZ+roadLength),
                               new THREE.Vector3(centerTruckX+roadLength,altiSolTruck,centerTruckZ+roadLength),
                               new THREE.Vector3(centerTruckX+roadLength,altiSolTruck,centerTruckZ-roadLength)
                           );

                       var len = geometryClickToGo.vertices.length;
                       geometryClickToGo.faces.push( new THREE.Face3( len-4,len-3,len-2));
                       geometryClickToGo.faces.push( new THREE.Face3( len-4,len-2,len-1));
                       
                   
                // NEW DTM ROAD
                        var len = _geometry.vertices.length;
                        var geom = _meshDTM.geometry;
                        for(var a=0;a<geom.vertices.length;++a){
                           // if(geom.vertices[a].y !=0)
                             _geometry.vertices.push(geom.vertices[a]);
                        }

                        for( a=0;a<geom.faces.length;++a){
                            var f = geom.faces[a];
                            _geometry.faces.push(new THREE.Face3(f.a+len,f.b+len,f.c+len));
                        }

    //**** CUBE   Let s add a big cube around position so we are sure to texture everywhere around the cameras
                var cubeSize = 5000; // Coordinate from panoramic cam center and cube edges (in 2D) Half
                var a,b,c,d,e,f,g,h;
                a = new THREE.Vector3(centerTruckX-cubeSize,centerTruckY-cubeSize,centerTruckZ-cubeSize);
                b = new THREE.Vector3(centerTruckX-cubeSize,centerTruckY+cubeSize,centerTruckZ-cubeSize);
                c = new THREE.Vector3(centerTruckX+cubeSize,centerTruckY+cubeSize,centerTruckZ-cubeSize);
                d = new THREE.Vector3(centerTruckX+cubeSize,centerTruckY-cubeSize,centerTruckZ-cubeSize);
                e = new THREE.Vector3(centerTruckX-cubeSize,centerTruckY+cubeSize,centerTruckZ+cubeSize);
                f = new THREE.Vector3(centerTruckX+cubeSize,centerTruckY+cubeSize,centerTruckZ+cubeSize);
                g = new THREE.Vector3(centerTruckX+cubeSize,centerTruckY-cubeSize,centerTruckZ+cubeSize);
                h = new THREE.Vector3(centerTruckX-cubeSize,centerTruckY-cubeSize,centerTruckZ+cubeSize);
                _geometry.vertices.push(a,b,c,d,e,f,g,h);
                len = _geometry.vertices.length;

                _geometry.faces.push( new THREE.Face3( len-1,len-2,len-3));
                _geometry.faces.push( new THREE.Face3( len-1,len-3,len-4));
                _geometry.faces.push( new THREE.Face3( len-6,len-3,len-2));
                _geometry.faces.push( new THREE.Face3( len-6,len-2,len-5));
                _geometry.faces.push( new THREE.Face3( len-8,len-7,len-6));
                _geometry.faces.push( new THREE.Face3( len-8,len-6,len-5));
                _geometry.faces.push( new THREE.Face3( len-8,len-7,len-4));
                _geometry.faces.push( new THREE.Face3( len-8,len-4,len-1));
                _geometry.faces.push( new THREE.Face3( len-7,len-6,len-3));
                _geometry.faces.push( new THREE.Face3( len-7,len-3,len-4));
                _geometry.faces.push( new THREE.Face3( len-8,len-5,len-2));
                _geometry.faces.push( new THREE.Face3( len-8,len-2,len-1));
            }
    //***********************************************************************************************************            

                console.log("RGE Bati loaded and transformed to mesh OK");
                console.log('_configStereo: ',_configStereo);
  
                _geometry.computeFaceNormals();  // WARNING : VERY IMPORTANT WHILE WORKING WITH RAY CASTING ON CUSTOM MESH

                geometryClickToGo.computeFaceNormals();
                var mat = new THREE.MeshBasicMaterial({color:0xff00ff});
                mat.side = THREE.DoubleSide;
                _currentMeshForClickAndGo  = new THREE.Mesh(geometryClickToGo,mat);

                // 5 cameras configuration
                if(!ProjectiveTexturing2.isInitiated()){
                    
                    console.log('ProjectiveTexturing2 init ');
                    var mat = new THREE.MeshBasicMaterial({color:0xff00ff});
                    var mesh  = new THREE.Mesh(_geometry,mat);
                    mat.side = THREE.DoubleSide;
                    mesh.name = "RGE";
                    _currentObject = mesh;

                    var matRotation = Ori.computeMatOriFromHeadingPitchRoll(
                                        this.panoInfo.pan_xml_heading_pp,
                                        this.panoInfo.pan_xml_pitch_pp,
                                        this.panoInfo.pan_xml_roll_pp
                                    );

                    ProjectiveTexturing2.init(matRotation);
                    _projectiveMaterial = ProjectiveTexturing2.createShaderForImage(this.panoInfo.filename,50);
                    mesh.material = _projectiveMaterial;
                    mesh.material.side = THREE.DoubleSide;  
                    mesh.material.transparent = false;
                    mesh.visible = _visibility;  
                    // ProjectiveTexturing2.changePanoTextureAfterloading(this.panoInfo.filename,128,50,posWithPivot,matRotation,1);

                }else {
                    
                    //remove older rge in scene
                    console.log('ProjectiveTexturing2  ');
                    gfxEngine.removeFromScene(_currentObject);  console.log('remove old mesh');
                   // var mesh  = new THREE.Mesh(_geometry, _projectiveMaterial);
                    var mesh  = new THREE.Mesh(_geometry, ProjectiveTexturing2.getShaderMat());
                    mesh.material.side = THREE.DoubleSide;  
                    mesh.material.transparent = false;
                    mesh.name = "RGE";
                    mesh.visible = _visibility;
                    _currentObject = mesh;

                }
                   
                
                
                 gfxEngine.addToScene(_currentObject);
                 this.setRoadOn(true);

                 allInitialized = true;  // End of initializing all (geometry, intriseq param etc)
                    
            },
               
               
               
            // Simple cube geometry for a fast texturing while no RGE (or not yet loaded)
            initGeometryWithCube: function(matRot){
               
                var heightCamOnTruck = 2;
                var alti = this.panoInfo.altitude - gfxEngine.getZeroAsVec3D().y - heightCamOnTruck;
                _geometry = new THREE.Geometry();
               
     //****** Let s add a road
                var centerTruckX = this.panoInfo.easting  - gfxEngine.getZeroAsVec3D().x;
                var centerTruckY = this.panoInfo.altitude - gfxEngine.getZeroAsVec3D().y;
                var centerTruckZ = this.panoInfo.northing - gfxEngine.getZeroAsVec3D().z;
               
                var roadLength = 500
                _geometry.vertices.push(new THREE.Vector3(centerTruckX-roadLength,alti,centerTruckX-roadLength),
                    new THREE.Vector3(centerTruckX-roadLength,alti,centerTruckX+roadLength),
                    new THREE.Vector3(centerTruckX+roadLength,alti,centerTruckX+ roadLength),
                    new THREE.Vector3(centerTruckX+roadLength,alti,centerTruckX-roadLength)
                );
              var len = _geometry.vertices.length;
                _geometry.faces.push( new THREE.Face4( len-4,len-3,len-2,len-1) );//new THREE.Face4( len-1,len-2,len-3,len-4) );

    //**** CUBE   Let s add a big cube around position so we are sure to texture everywhere around the cameras
                var cubeSize = 5000; // Coordinate from panoramic cam center and cube edges (in 2D) Half
                var a,b,c,d,e,f,g,h;
                a = new THREE.Vector3(centerTruckX-cubeSize,centerTruckY-cubeSize,centerTruckZ-cubeSize);
                b = new THREE.Vector3(centerTruckX-cubeSize,centerTruckY+cubeSize,centerTruckZ-cubeSize);
                c = new THREE.Vector3(centerTruckX+cubeSize,centerTruckY+cubeSize,centerTruckZ-cubeSize);
                d = new THREE.Vector3(centerTruckX+cubeSize,centerTruckY-cubeSize,centerTruckZ-cubeSize);
                e = new THREE.Vector3(centerTruckX-cubeSize,centerTruckY+cubeSize,centerTruckZ+cubeSize);
                f = new THREE.Vector3(centerTruckX+cubeSize,centerTruckY+cubeSize,centerTruckZ+cubeSize);
                g = new THREE.Vector3(centerTruckX+cubeSize,centerTruckY-cubeSize,centerTruckZ+cubeSize);
                h = new THREE.Vector3(centerTruckX-cubeSize,centerTruckY-cubeSize,centerTruckZ+cubeSize);
                _geometry.vertices.push(a,b,c,d,e,f,g,h);
                len = _geometry.vertices.length;
                _geometry.faces.push( new THREE.Face4( len-1,len-2,len-3,len-4) );
                _geometry.faces.push( new THREE.Face4( len-6,len-3,len-2,len-5) );
                _geometry.faces.push( new THREE.Face4( len-8,len-7,len-6,len-5) );
                _geometry.faces.push( new THREE.Face4( len-8,len-7,len-4,len-1) );
                _geometry.faces.push( new THREE.Face4( len-7,len-6,len-3,len-4) );
                _geometry.faces.push( new THREE.Face4( len-8,len-5,len-2,len-1) );
    //***********************************************************************************************************            

                _geometry.computeFaceNormals();  // WARNING : VERY IMPORTANT WHILE WORKING WITH RAY CASTING ON CUSTOM MESH
               
               
                 if(!ProjectiveTexturing2.isInitiated()){

                    var mat = new THREE.MeshBasicMaterial({color:0xff00ff});
                    var mesh  = new THREE.Mesh(_geometry,mat);
                    mat.side = THREE.DoubleSide;
                    mesh.name = "RGE";
                    _currentObject = mesh;

                    ProjectiveTexturing2.init(matRot);
                    _projectiveMaterial = ProjectiveTexturing2.createShaderForImage(this.panoInfo.filename,50);
                    mesh.material = _projectiveMaterial;
                    mesh.material.side = THREE.DoubleSide;  // SEE IF BETTER TO HAVE ANOTHER MESH (CLONE) TO TEXTURE SIMPLE SIDE
                    mesh.material.transparent = true;
                    mesh.visible = _visibility;  
                    gfxEngine.addToScene(_currentObject);

                }else {
                    //remove older rge in scene
                    gfxEngine.removeFromScene(_currentObject);  console.log('remove old mesh');
                    var mesh  = new THREE.Mesh(_geometry, _projectiveMaterial);
                    mesh.material.side = THREE.DoubleSide;  // SEE IF BETTER TO HAVE ANOTHER MESH (CLONE) TO TEXTURE SIMPLE SIDE
                    mesh.material.transparent = true;
                    mesh.name = "RGE";
                    mesh.visible = _visibility;
                    _currentObject = mesh;
                    gfxEngine.addToScene(_currentObject);
                }
                 
     
             },
             
       
       //**************************************************** DTM **************************************
       
            getDTMFromTrajectory: function(){
                
                console.log('getDTM');            
                var  info = this.panoInfo;
                var that = this;
                var urlRequest = _localDTMFile ? _urlDTM : _urlDTM+"easting="+ info.easting +"&northing="+info.northing+"&radius="+_radius;
                $.getJSON(urlRequest, function (data){
                        that.createDTMFromTrajectory(data,info);
                    });
            },


            createDTMFromTrajectory: function(data,info){
               
                var radiusMarge = _radius + 100;
                var heightApplanixOnTruck = 2.1;
                var zero = gfxEngine.getZeroAsVec3D();
                _pivotGrid = new THREE.Vector3(
                                 info.easting  - zero.x,
                                 info.altitude - zero.y,
                                 info.northing - zero.z
                );  
                     
                var sideGrid = Math.floor(radiusMarge * 2 / 10);  
                for(var i=0; i< sideGrid; ++i){
                     _gridDTM2[i] = new Array();
                     for(var j=0; j<sideGrid; ++j){
                         _gridDTM2[i][j] = 0;
                    }
                }
                 
                 
                for( i = 0 ; i <data.length ; ++i){
                
                    var pos = data[i];
                    pos.h -= zero.y /*+ _pivotGrid.y*/ + heightApplanixOnTruck;
                    pos.e -= zero.x + _pivotGrid.x;
                    pos.n -= zero.z + _pivotGrid.z;
                   
                   _gridDTM2[Math.floor((pos.e +radiusMarge)/_sizeCell)][Math.floor((pos.n + radiusMarge)/_sizeCell)] = pos.h;
                }
               
                //this.showGridDTM(_gridDTM2);
                this.smoothGrid(_gridDTM2);
            },
           
           
            // test with all cell is the average of neighbour (>8 connex)
            // TOREDO!
            smoothGrid: function(grid){
               
                console.log("smoothGrid");
                var newGrid = new Array();
                var size  = grid.length;
                var radiusMarge = _radius + 100;
               
                for(var i=0; i<size; ++i){
                     newGrid[i] = new Array();
                     for(var j=0; j<size; ++j){
                         newGrid[i][j] = -2;  // was 0 but as applanix is 2meters overground, if no info -2 is better
                    }
                 }
                 
             
                for( var i=3; i<grid.length-3; i+=1){
                     for( var j=3; j<grid.length-3; j+=1){
                         
                         var som=0;
                         var n=0;
                         var lastAlti = -1000;
                         for(var a=-3; a<=3;++a){
                               for(var b=-3; b<=3;++b){
                                   
                                   var alti = grid[i+a][j+b];
                                   if( alti != 0){   // Don't take into account where no information
                                       
                                        if(Math.abs(alti - lastAlti)>0.3){    // Check if same alti as last dont count (Todo: coef:weight)
                                            som+=alti;
                                            n++;
                                            lastAlti = alti;
                                        }
                                   }
                               }
                         }
                         if(n!=0) newGrid[i][j] = som/n;
                       
                     }
                }
               
               
                // SHOW
                 var geometry = new THREE.Geometry();
                 
                 for(var i=0; i<grid.length; ++i){
                     for(var j=0; j<grid[0].length; ++j){
                         
                         var pos1 = new THREE.Vector3(i*_sizeCell-radiusMarge + _pivotGrid.x, newGrid[i][j]/*+ _pivotGrid.y*/, j*_sizeCell - radiusMarge + _pivotGrid.z);
                         geometry.vertices.push(pos1);
                    }
                 }
                 
                 for(var a=0;a<geometry.vertices.length;++a){
                     
                     if(a < geometry.vertices.length - grid.length -1 && ((a +1) % grid.length !=0)){
                         geometry.faces.push( new THREE.Face3( a, a+1, a+grid.length) );
                         geometry.faces.push( new THREE.Face3( a+1, a+1+grid.length, a+grid.length) );
                     }
                 }
                 
                 
                 geometry.computeFaceNormals();
                 
                 var mat = new THREE.MeshBasicMaterial({color:Math.random() * 0xffffff, wireframe:true});
                 mat.side = THREE.DoubleSide;
                 
                if(_showDTM){
                       if(_meshDTM) gfxEngine.removeFromScene(_meshDTM);
                //_meshDTM = new THREE.Mesh(geometry, mat);
                      _meshDTM = new THREE.Mesh(geometry.clone(), mat);
                      gfxEngine.addToScene(_meshDTM);   //   DISPLAY DTM
                }else{
                   _meshDTM = new THREE.Mesh(geometry, mat);
                }
     
               
                _gridDTM2 = newGrid;
                _geomDTM = geometry;
                   
                // var currentPos = {x:this.panoInfo.easting , y: this.panoInfo.northing };
                // this.generateCartoPlane({x:currentPos.x-200,y:currentPos.y+ 200} ,19,10,"ORTHOIMAGERY.ORTHOPHOTOS.PARIS","png",-1);

               //  THEN LAUNCH BATI ETC
                this.searchPolygonBatiAround(_rgeCurrentPositionE,_rgeCurrentPositionN,_radius);
                
                  
                // We create Map and effect is ortho is activated
                if (this.getOrthoPhotoOn()) {
                    this.removeMapMeshes();  // Carto

                    var layer = "ORTHOIMAGERY.ORTHOPHOTOS.PARIS";
                    var info = this.panoInfo;
                    if (info.easting > 656000 || info.easting < 640000 || info.northing > 6869000 || info.northing < 6860000)
                        layer = "ORTHOIMAGERY.ORTHOPHOTOS";

                    var currentPos = {x: info.easting, z: info.northing};
                    this.generateCartoPlane({x: currentPos.x, y: currentPos.z}, 18, 10, layer, "jpeg",128);

                }
               
            },


             initGridDTM: function(size){
                 
                 for(var i=0; i<size; ++i){
                     _gridDTM[i] = new Array();
                     for(var j=0; j<size; ++j){
                         _gridDTM[i][j] = 0;
                    }
                 }
             },
             
        
            
             // Doesn t recreate if already done
             generateSkyBox: function(){
             
               if(this.skyBox == null ){
                   
                    var urls = [
                        //'images/textures/skybox/px.jpg',
                        '../../images/textures/skybox/px.jpg',
                        '../../images/textures/skybox/nx.jpg',
                        '../../images/textures/skybox/py.jpg',
                        '../../images/textures/skybox/ny.jpg',
                        '../../images/textures/skybox/pz.jpg',
                        '../../images/textures/skybox/nz.jpg'
                    ];

                    var cubemap = THREE.ImageUtils.loadTextureCube(urls); // load textures
                    cubemap.format = THREE.RGBFormat;

                    var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
                    shader.uniforms['tCube'].value = cubemap; // apply textures to shader

                    // create shader material
                    var skyBoxMaterial = new THREE.ShaderMaterial( {
                      fragmentShader: shader.fragmentShader,
                      vertexShader: shader.vertexShader,
                      uniforms: shader.uniforms//,
                      //depthWrite: false//,
                      //side: THREE.BackSide
                    });

                    // create skybox mesh
                    this.skyBox = new THREE.Mesh(
                      new THREE.CubeGeometry(8000, 8000, 8000),
                      skyBoxMaterial
                    );
                }
                
                 gfxEngine.addToScene( this.skyBox );
                 //this.skyBox.position.y = 1000;
                 
            },
           
           
            removeSkyBox: function(){
                gfxEngine.removeFromScene(this.skyBox);
            },
            
            
            setSkyBoxVisibility: function(b){
                this.skyBox.visible = b;
            },
       
       
          // ******************************** carto Plane 3D********************************************    
          // WMS LAMB93
         generateCartoPlane: function(pos,level,radius,layer,format,sizeTileMeters){
                   
                  this.removeMapMeshes();  // first remove existing carto
                 // The size of tiles in meters will give the precision of ortho. smaller -> higher precision
                  var sizeTileMeters =  sizeTileMeters || 164;//128;
                  var nbTiles = 8;
                  var sizeTilePx = 256;
                  pos.x -= (sizeTileMeters * nbTiles)/2;
                  pos.y -= (sizeTileMeters * nbTiles)/2;
                  var sizeCell = 10; //10 m grids default
                 
                  var posLocal = {x:pos.x - gfxEngine.getZero().x, y:pos.y - gfxEngine.getZero().z };
                  console.log(posLocal);

                  // We then launch the creation of the TileTexture (composed of 8*8 tiles) with the 4 corners position for the mesh  
                  var tileTexture = new TileTexture("name",layer,format,posLocal,sizeTileMeters,sizeTilePx,nbTiles,_geomDTM,_pivotGrid, _gridDTM2.length, _radius+100, Config.geoAPIKey,sizeCell);

                  tileTexture.createTilesList(pos,sizeTileMeters);
                  tileTexture.loadTilesFromList();
                 
                  gfxEngine.addToScene(tileTexture.meshNest);
                  _tabMapMesh.push(tileTexture.meshNest);
             },
 
 
// SPECIFIC VERSION for Futur En Seine. All paris using 2 triangles    ***************************************************
          generateCartoPlanePARIS: function(pos,level,radius,layer,format){
                   
               //   this.removeMapMeshes();  // first remove existing carto
                 // The size of tiles in meters will give the precision of ortho. smaller -> higher precision
                  var sizeTileMeters =  1000;//128;
                  var nbTiles = 8;
                  var sizeTilePx = 256;
                  pos.x -= (sizeTileMeters * nbTiles)/2;
                  pos.y -= (sizeTileMeters * nbTiles)/2;
                 
                  var posLocal = {x:pos.x - gfxEngine.getZero().x, y:pos.y - gfxEngine.getZero().z };
                  console.log(posLocal);
                  
                  
                  
                  // Create a very simple grid
				  var  info = this.panoInfo;
				  var localRadius = 4500;
          	      var radiusMarge = localRadius + 100;
          	      var sizeCell = 400;
             	  var heightApplanixOnTruck = 2.1;
             	  var zero = gfxEngine.getZeroAsVec3D();
             	  _pivotGrid = new THREE.Vector3(
                                 info.easting  - zero.x,
                                 info.altitude - zero.y,
                                 info.northing - zero.z
                  );  
                     
	                var sideGrid = Math.floor(radiusMarge * 2 / sizeCell);  
	                for(var i=0; i< sideGrid; ++i){
	                     _gridFES[i] = new Array();
	                     for(var j=0; j<sideGrid; ++j){
	                         _gridFES[i][j] = -20;
	                    }
	                }
	                
	                
	                            // SHOW
                 var geometry = new THREE.Geometry();
                 
                 for(var i=0; i<_gridFES.length; ++i){
                     for(var j=0; j<_gridFES.length; ++j){
                         
                         var pos1 = new THREE.Vector3(i*sizeCell-radiusMarge + _pivotGrid.x, _gridFES[i][j]/*+ _pivotGrid.y*/, j*sizeCell - radiusMarge + _pivotGrid.z);
                         geometry.vertices.push(pos1);
                    }
                 }
                 
                 for(var a=0;a<geometry.vertices.length;++a){
                     
                     if(a < geometry.vertices.length - _gridFES.length -1 && ((a +1) % _gridFES.length !=0)){
                         geometry.faces.push( new THREE.Face3( a, a+1, a+_gridFES.length) );
                         geometry.faces.push( new THREE.Face3( a+1, a+1+_gridFES.length, a+_gridFES.length) );
                     }
                 }
                 
                 
                 geometry.computeFaceNormals();
          /*       
                 var mat = new THREE.MeshBasicMaterial({color:Math.random() * 0xffffff, wireframe:true});
                 mat.side = THREE.DoubleSide;
                 
                 var meshDTM = new THREE.Mesh(geometry, mat);
                 gfxEngine.addToScene(meshDTM);
        */         

	             
                  // We then launch the creation of the TileTexture (composed of 8*8 tiles) with the 4 corners position for the mesh  
                  var tileTexture = new TileTexture("name",layer,format,posLocal,sizeTileMeters,sizeTilePx,nbTiles,geometry,_pivotGrid, _gridFES.length, localRadius+100, Config.geoAPIKey,sizeCell);
                        
                  tileTexture.createTilesList(pos,sizeTileMeters);
                  tileTexture.loadTilesFromList();
                  _meshCartoFES = tileTexture.meshNest;
                  gfxEngine.addToScene(_meshCartoFES);
               //   _tabMapMesh.push(tileTexture.meshNest);
             },
             
             
             
             setVisibilityParisOrtho: function(b){
                 _meshCartoFES.visible = b;
                 
             },
             
             getMeshFES : function(){
                 return _meshCartoFES;
             },
       
             generateCartoPlaneWMTSMercator: function(pos,level,radius,layer,format,alti){

             // We need to compute the size of the tiles (depends on level) in meters mercator sys
                  _sizeTile = require("Cartography").computeSizeTile(level);

            //   We need to get to position of the tileTexture around our position in lamb93
                  var tileInfo = require("Cartography").getTileCoordAtPos(pos,_sizeTile);
                  var tilePosX = tileInfo.x *_sizeTile + _topLeftCorner.x;
                  var tilePosY = -tileInfo.y *_sizeTile + _topLeftCorner.y;
                  var posLamb = require("Cartography").convertCoord({x:tilePosX, y:tilePosY},"EPSG:3857","EPSG:2154");        
                 
              // Then we need to know the width and height of the Tile Texture
              // And we calcul the corners position of the Tile Texture (composed of 8*8 tiles)
                  var tilePosBottomCornerX = tilePosX + 8 *_sizeTile;
                  var tilePosBottomCornerY = tilePosY - 8 *_sizeTile;
                  var posLambCorner = require("Cartography").convertCoord({x:tilePosBottomCornerX, y:tilePosBottomCornerY},"EPSG:3857","EPSG:2154");
                  var widTileTexture = posLambCorner.x - posLamb.x;
                  var heiTileTexture = posLambCorner.y - posLamb.y;
                 
               // We transform the 2 other corners in local projection  
                  var posLambCorner11 = require("Cartography").convertCoord({x:tilePosBottomCornerX, y:tilePosY},"EPSG:3857","EPSG:2154");
                  var posLambCorner21 = require("Cartography").convertCoord({x:tilePosX, y:tilePosBottomCornerY},"EPSG:3857","EPSG:2154");
                 
                  var zero = gfxEngine.getZeroAsVec3D();
                  var posLambLocal         = new THREE.Vector3(posLamb.x - zero.x,         alti,   posLamb.y - zero.z);
                  var posLambCornerLocal   = new THREE.Vector3(posLambCorner.x - zero.x,   alti,   posLambCorner.y   - zero.z);
                  var posLambCorner11Local = new THREE.Vector3(posLambCorner11.x - zero.x, alti,   posLambCorner11.y - zero.z);
                  var posLambCorner21Local = new THREE.Vector3(posLambCorner21.x - zero.x, alti,   posLambCorner21.y - zero.z);
                 
                  Draw.drawSphereAt(posLambLocal, 15, 0xff0000);
                  Draw.drawSphereAt(posLambCornerLocal, 15, 0x00ff00);
                  Draw.drawSphereAt(posLambCorner21Local, 15, 0x0000ff);
                 
               // We then launch the creation of the TileTexture (composed of 8*8 tiles) with the 4 corners position for the mesh  
                  var tileTexture = new TileTexture("ur",layer,format,level,
                                                    widTileTexture,heiTileTexture,5,5,posLambLocal,posLambCornerLocal,posLambCorner21Local,posLambCorner11Local,_geomDTM);
                  //tileTexture.loadAllTiles(tileInfo.x,tileInfo.y);
                  tileTexture.createTilesList(tileInfo.x,tileInfo.y);
                  tileTexture.loadTilesFromList();
                 
                  gfxEngine.addToScene(tileTexture.meshNest);
                  _tabMapMesh.push(tileTexture.meshNest);
                  //var heightCamOnTruck = 2;
                  //var alti = this.panoInfo.altitude - zero.y - heightCamOnTruck;
             },
       
         
             
              setMapOpacity: function(alpha){
                 
                  _tabMapMesh[0].material.opacity = alpha;
              },
             
                  getTabMesh: function(){
                 
                  return _tabMapMesh;
              },
             
              removeMapMeshes: function(){
                 
                  //console.log(_tabMapMesh);
                  gfxEngine.removeFromScene(_tabMapMesh[0]);
                //  gfxEngine.removeFromScene(_tabMapMesh[1]);
                  _tabMapMesh = [];
                 /*
                  while(_tabMapMesh.length >0){
                      gfxEngine.removeFromScene(_tabMapMesh.splice());
                  }*/
              },
             
             // NOT USED
              displayTile:function(img, posLamb){
                 
       
                  _sizeTile = 50.23516095429659 ;

                  var texture = new THREE.Texture(img,THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter,THREE.LinearFilter);
                  var meshMaterial = new THREE.MeshBasicMaterial( { map: texture, transparent: false} );
                  meshMaterial.side = THREE.DoubleSide;
                  var meshTile = new THREE.Mesh( new THREE.PlaneGeometry(_sizeTile,_sizeTile), meshMaterial);
                  gfxEngine.addToScene(meshTile);
                  texture.needsUpdate = true;  // VERY IMPORTANT
               
                  var heightCamOnTruck = 2;
                  var zero = gfxEngine.getZeroAsVec3D();
                  var alti = this.panoInfo.altitude - zero.y - heightCamOnTruck;
                 
                  meshTile.rotation.x = Math.PI/2;
                  console.log('posLamb',posLamb);
                  //meshTile.position = new THREE.Vector3(posLamb.x - zero.x - 38,alti,posLamb.y - zero.z + 38);
                  meshTile.position = new THREE.Vector3(posLamb.x - zero.x + _sizeTile/2, alti, posLamb.y - zero.z - _sizeTile/2);
                  //meshTile.position = new THREE.Vector3(0+ sizeTile/2,alti,0-sizeTile/2);//posLamb.x - zero.x , alti, posLamb.y - zero.z);
             },

       
             getCurrentObject:function(){
                 return _currentObject;
             },
             
             getCurrentMeshForClickAndGo:function(){
                 return _currentMeshForClickAndGo;
             },
             
             getProjectiveMaterial: function(){
                 return _projectiveMaterial;
             },
             
             getGeometry: function(){
                 return _geometry;
             },
             
             getCurrentObjectToDrag : function(){
                 return _currentObjectToDrag;
             },
             
             getConfigStereo: function(){
                 return _configStereo;
             },
             
             // Version is 0 or 1
             setConfigStereo: function(version){
                _configStereo = version ;
             },

            getOrthoPhotoOn: function(){
                return _orthoPhotoOn;
            },
             
             addAmbientLight : function(){
                var ambient = new THREE.AmbientLight( 0x101030 );
                gfxEngine.addToScene( ambient );
             },
             
             addDirectionalLight : function(){
                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.set( 1000, 1000, 0 ).normalize();
                gfxEngine.addToScene(directionalLight);
             },
             
            setVisibility: function(b){
                _visibility = b;
                _currentObject.visible = b;
                this.setRoofVisibility(b);  
            },
           
            setRoofVisibility: function(b){
                if(_meshRoof != undefined)
                     _meshRoof.visible = b;
            },
            
            tweenGeneralOpacityUp: function(){
                console.log("tweenGeneralOpacityUp");
                if(ProjectiveTexturing2.isInitiated()){
                    ProjectiveTexturing2.setGeneralOpacity(0);
                    ProjectiveTexturing2.tweenGeneralOpacityUp();
                }
            },
           
            setFogValue: function(v){
               
                if(ProjectiveTexturing2.isInitiated()) ProjectiveTexturing2.setFogValue(v);
            },
           
            setRoadOn: function(b){
                _roadOn = b;
                //this.forceUpdateRGE();
            },
           
            setOrthoPhotoOn: function(b){
                _orthoPhotoOn = b; 
               // if(b) $("#checkbox3")[0].checked = true;   // API OUT
            },
           
            setShowDTM: function(b){
                _showDTM = b;
                if(_showDTM){
                     
                      if(_meshDTM) gfxEngine.removeFromScene(_meshDTM);
                      var mat = new THREE.MeshBasicMaterial({color:Math.random() * 0xffffff, wireframe:true});
                      mat.side = THREE.DoubleSide;
                      _meshDTM = new THREE.Mesh(_geomDTM.clone(), mat);
                      gfxEngine.addToScene(_meshDTM);   //   DISPLAY DTM
                }else{
                   if(_meshDTM) gfxEngine.removeFromScene(_meshDTM);
                }
                 
            },
            
            // Get alti (float) from DTM using parameter Vector3
            getAltiFromDTM: function(v){
                
               var radiusMarge = _radius + 100;
               var altitude_sol = 0;
               
               var indx = Math.floor((v.x - _pivotGrid.x + radiusMarge)/10);
               var indy = Math.floor((v.z - _pivotGrid.z + radiusMarge)/10);
               if(indx >0 && indx < _gridDTM2.length && indy>0 && indy<_gridDTM2.length){
                   altitude_sol = _gridDTM2[indx][indy];
               }
               
               return altitude_sol;
            },
            
            
            removeCubeFromMeshFaces: function(){
                
                //geometry.elementsNeedUpdate = true;
                var l = _currentObject.geometry.faces.length;
                console.log(l); 
                //_geometry.faces.length = l-12;
                _currentObject.geometry.faces[l-1] = null;
                _currentObject.geometry.faces[l-2] = null;
                _currentObject.geometry.faces[l-3] = null;
                _currentObject.geometry.faces[l-4] = null;
                _currentObject.geometry.faces[l-5] = null;
                _currentObject.geometry.faces[l-6] = null;
                _currentObject.geometry.faces[l-7] = null;
                _currentObject.geometry.faces[l-8] = null;
                _currentObject.geometry.faces[l-9] = null;
                _currentObject.geometry.faces[l-10] = null;
                _currentObject.geometry.faces[l-11] = null;
                _currentObject.geometry.faces.length = l-2500;
                _currentObject.geometry.elementsNeedUpdate = true;
                console.log(l);
            }
             
             
        };
        return Manager;
    });


/**
 * Creates a new Panoramic object [ It s actually a Panoramic Layer ]
 * @class Manage the panoramics
 * @author alexandre devaux IGN
 * @requires ThreeJS
 * 
 * Panoramic abstract module 
 * stereopolis uses projective texturing (a mesh (geometry) and a texture (projectiveTexturing))
 * Other can use one texture equirectangular on a sphere
 * 
 */ 
 
define ('Panoramic',['lib/three', 'Ori','MeshManager', 'PanoramicProvider', 'lib/when', 'Navigation'], function ( THREE, Ori, MeshManager, PanoramicProvider, when, Navigation) {
    
    
    var _panoGlobale = new THREE.Object3D(),
    _url = "",
    _initiated = false,
    _visibility = true,
    _panoInfo = {
        filename:'',
        easting:0, 
        northing:0,
        altitude:0, 
        pan_xml_heading_pp:0,
        pan_xml_pitch_pp:0,
        pan_xml_roll_pp:0,
        pan_time_utc:'',
        near_address_num:0,
        near_address_name:''
    },
    _dataURL = null,
    _decalageUTC = 15;

       
    // EVENT MANAGEMENT
    var _events = {
        MOVE : function (){
            MeshManager.updateDataFromRGE();
        }
    };
    
    
    var Panoramic =  {
  
        init: function(pos, dataURL){
            
            _dataURL = dataURL;
            PanoramicProvider.init(_dataURL);
            
            // Get info for initPosition from Data base
            PanoramicProvider.getMetaDataFromPos(pos.x, pos.z, 50).then(
                        function(response){
                            _panoInfo = response[0];
                            _initiated = true;
                           // Init orientation module (used for intrinseque and extraseque parameters)
                            Ori.init();
                        }
                    );
            
            
            // Needs to have ori initiated
            this.testInitOri(); // Generate Mesh with projective images and building geometry
        },
        
            
       testInitOri: function() {

            if (Ori.initiated){
                 MeshManager.init(_panoInfo, _dataURL);
                 
            }
            else {
                 console.log("Panoramic module is initiated");
                 setTimeout(Panoramic.testInitOri, 300);  // !! scope
            }
        },
        
        
        setInfos: function(url,infos){
  
            _url = url || '';
            _panoInfo.filename = infos.filename || '';
            _panoInfo.easting = parseFloat(infos.easting) || 0;
            _panoInfo.northing = parseFloat(infos.northing) || 0;                            
            _panoInfo.altitude = parseFloat(infos.altitude) || 0;
            _panoInfo.pan_xml_heading_pp = parseFloat(infos.heading) ||  parseFloat(infos.pan_xml_heading_pp) ||  0;
            _panoInfo.pan_xml_pitch_pp = parseFloat(infos.pitch) || parseFloat(infos.pan_xml_pitch_pp) || 0;
            _panoInfo.pan_xml_roll_pp = parseFloat(infos.roll) || parseFloat(infos.pan_xml_roll_pp) ||  0;
            _panoInfo.pan_time_utc = infos.time_utc || infos.pan_time_utc || ''; 
            _panoInfo.near_address_num = infos.near_address_num || 0;
            _panoInfo.near_address_name = infos.near_address_name || '';
        },
     

        isInitiated: function(){
            return _initiated;
        },
        
        // Update Pano textures and position/rotation
        updateGlobalPano: function(url,name,position,rotation,infos) {
            this.setInfos(url,infos);
            this.updatePanoTextures(url, name);
            this.updatePanoCoord(position, rotation);
        },
        

        updatePanoCoord: function(position, rotation) {
            _panoGlobale.position = position;
            _panoGlobale.rotation = rotation;
        },

        initInfo: function(url,name){
            _url = url;
            _panoInfo.filename = name;
        },
        


        loadName: function (name){
            _name = name;
            this.loadUrl("http://www.itowns.fr/cgi-bin/iipsrv.fcgi?FIF=/iipimages3/"+name+".jp2");
        },


        removeFromScene: function(){
            scene.remove(this.panoGlobale);
        },

        setNameForCamera: function(numCam){
            //"http://www.itowns.fr/cgi-bin/iipsrv.fcgi?FIF=/iipimages/Paris_12-080422_0687-00-00001_0001319.jp2"
            var pat=new RegExp("-[0-9][0-9]-");
            //	this.url = this.url.replace(pat,"-"+numCam+"-");
            //console.log("set Name: "+ this.url);
            return _url.replace(pat,"-"+numCam+"-");
        },

        // Rotate image on camera using canvas rotation
        rotateImage: function(cameraName,angle){

            var tt = this.getTileTexture(cameraName);
            tt.rotate(angle);
        },


        getPanoGlobale: function(){

            return _panoGlobale;
        },

        getPanoInfos: function(){
            return _panoInfo;
        },

        getPanoPos: function(){
            return new THREE.Vector3(_panoInfo.easting,
                                     _panoInfo.altitude,
                                     _panoInfo.northing);
        },
         
        setURLWithPos: function(){
            
            var params= {};
            var tmp= window.location.search.substr(1).split("&");  // Adresse ex: http://www.itowns.fr/viewer/laserADVIewer.html?date=2008_05_05&hour=14&seconds=350&easting=655550.2&northing=6866565.3
            for (i=0; i<tmp.length; i++)
            {
                data=tmp[i].split("=");
                params[data[0].toLowerCase()]=data[1];		
            }
            
            params.panoname = params.panoname || "TerMob2-130116_0923-00-00002_0000623";
            params.easting = params.easting; // easting=655081.6&northing=6423576.62
            params.northing = params.northing;
            params.heading = params.heading || 0;
            params.duree = params.duree || "25";
            params.particlesize = params.particlesize || "0.01";
            params.mobile = params.mobile =="true" || false;
            params.nc = params.nc =="true" || false;   // nodecontroller to control camera from phone accelerometer
            
          //  console.log("params.mobileparams.mobile" ,params.mobile);
            if (typeof (params.debug) === "undefined" || params.debug !== "true") {
                params.debug = false;
            }
            else {
                params.debug = true;
            }
            
            var urlLocal = "?easting="+_panoInfo.easting+"&northing="+_panoInfo.northing+"&mobile="+params.mobile+"&nc="+params.nc;
            window.history.pushState("string test", "titre", urlLocal);
        },
        
        // ex: Toulouse-131010_0729-00-00002_0000501
        getPanoName: function(){
            return _panoInfo.filename;
        },
        
        // Toulouse-131010_0729-00-00002_0000501
        // -> n= -1 will return Toulouse-131010_0729-00-00002_0000500
        getPanoNameAtIndice: function(n){
            
            var name = _panoInfo.filename;
            var numberInc = (parseInt(name.substr(name.length-5)) + n).toString();
            while(numberInc.length <5){
                numberInc= '0'+numberInc;
            }           
            return name.substr(0,name.length-5) + numberInc;
        },

        getPanoUrl: function(){
            return _url;
        },
        
         getVisibility: function(){
            return _visibility;
        },

        
        // get date frome name (not db pan_date)
        getPanoDate: function(){

            var datee = _panoInfo.filename.substr(_panoInfo.filename.indexOf('-')+1,6);  // ex:080422
            var dateNewFormat = "20"+ datee.substr(0,2)+ "_"+ datee.substr(2,2) + "_"+ datee.substr(4,2);
            //ex: 2008_04_22
            return dateNewFormat;
        },

        getPanoHours: function(){
            var timeUTC = _panoInfo.pan_time_utc.split(":");   
            return parseFloat(timeUTC[0]);
        },

        getPanoSecondsInHour: function(){
            var timeUTC = _panoInfo.pan_time_utc.split(":");   
            return parseInt(timeUTC[1])*60 + parseInt(timeUTC[2]); 
        },
        
        getDecalageUTC: function(){
            
            return _decalageUTC;
        },
        
        setDecalageUTC: function(){
            
            // Code JP
        },

        setPanoInfos: function(panoInfos){
            _panoInfo = panoInfos;
        },
        
        setPosition: function(pos){
            _panoInfo.easting = pos.x;
            _panoInfo.northing = pos.z;
            _panoInfo.altitude = pos.y;
        },

        setVisibility: function(b){
            console.log('panoramic visibility: ',b)
            if (b == null) b = true;
            _visibility = b;
            MeshManager.setVisibility(b);
            
        },
        
        
        tweenGeneralOpacityUp: function(){
            MeshManager.tweenGeneralOpacityUp();
        },


        /*********** Name functions, Date...  *************************************/
        // Jump nb panoramics, acquired in the same 'Chantier' using filename
        jumpTo:function(nbImagetoJump){

            var numberPos = _url.search(".jp2");
            var numberInc = (parseInt(_url.substr(numberPos-5,5),10) +nbImagetoJump).toString();
            while(numberInc.length <4){
                numberInc= '0'+numberInc;
            }
            var pat=new RegExp("_000.*.jp2");
            _name = _url.replace(pat,"_000"+numberInc);

            var pos = _name.lastIndexOf("Paris");
            _name = _name.substr(pos);

            return _name;
        },
        
        processEvent : function(event){
            if (_events[event]){
                _events[event]();
            }
        }


    }

    return Panoramic;

});
define ('Dispatcher',[],function() {
   //PRIVATE MEMBERS******************************************************************************************
   //*********************************************************************************************************

   // ATTRIBUTES
   //*************************************
    //Available events are :
    // MOVE
    var _events = {};
        
   // METHODS
   //*************************************
   
   //END OF PRIVATE MEMBERS***********************************************************************************
   //*********************************************************************************************************
   
   /**
    * Dispatches events to registred modules. This allows independency between modules. For example, when Navigation.move
    * is called, we do not have to call specific methods of other modules inside the function, but just call
    * Dispatcher.send("MOVE"), then all registered modules will process the event.
    * 
    * @author M. BENARD
    * @exports Dispatcher
    */
    var Dispatcher = {
        register : function (event, module) {
            if (_events.hasOwnProperty(event)){
                _events[event].push(module);
            }
            else {
                _events[event] = [module];
            }
        },
        
        send : function (event){
            var registredModules = _events[event];
            if (registredModules) {
                for (var i=0, l=registredModules.length;i<l;i++){
                    registredModules[i].processEvent(event);
                }
            }
        }
        
    };
    
    return Dispatcher;
});



/* 
 * to add some extension to THREE without modifying the lib directly
 * Nguyen dot QuocDinh at gmail dot com
 */

define('lib/threeExt',['lib/three'],function(THREE){

       //Vector3 zone
       //add conversion function of Vector3 to lonlat
          THREE.Vector3.prototype.toLonLat = function(){
                               return new THREE.Vector2(this.x,this.z);
                      };
       //Vector2 zone
       //add check if point 2D in inside of triangle
          THREE.Vector2.prototype.vec = function(from, to) {  
                                return new THREE.Vector2(to.x - from.x, to.y - from.y);  
                      };
                    
          THREE.Vector2.prototype.dot = function(u, v) {  
                                return u.x * v.x + u.y * v.y;  
                      };
          /*
          THREE.Vector2.prototype.isPointInTriange = function (A, B, C) {
                                // Compute vectors        
                                var v0 = this.vec(A, C);
                                var v1 = this.vec(A, B);
                                var v2 = this.vec(A, this);
                                // Compute dot products
                                var dot00 = this.dot(v0, v0);
                                var dot01 = this.dot(v0, v1);
                                var dot02 = this.dot(v0, v2);
                                var dot11 = this.dot(v1, v1);
                                var dot12 = this.dot(v1, v2);
                                // Compute barycentric coordinates
                                var invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
                                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                                // Check if point is in triangle and return baricentrique
                                return new THREE.Vector3((u >= 0) && (v >= 0) && (u + v < 1), //inside?true:false 
                                                          u, //alpha
                                                          v  //beta
                                           );
                     };
           */
           // Compute barycentric coordinates (u, v, w) for
           // point p with respect to triangle (a, b, c)
           THREE.Vector2.prototype.isPointInTriange = function(A, B, C)
           {
                var v1 = this.vec(A, C);
                var v0 = this.vec(A, B);
                var v2 = this.vec(A, this);
 
                // Compute dot products
                var dot00 = this.dot(v0, v0);
                var dot01 = this.dot(v0, v1);
                var dot02 = this.dot(v0, v2);
                var dot11 = this.dot(v1, v1);
                var dot12 = this.dot(v1, v2);
                var invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
                var v = (dot11 * dot02 - dot01 * dot12)*invDenom,
                    w = (dot00 * dot12 - dot01 * dot02)*invDenom,
                    u = 1.0 - v - w;
                return new THREE.Vector3((u >= 0) && (v >= 0) && (u + v < 1), //inside?true:false 
                                                          u, //alpha
                                                          v  //beta
                                           );    
           };
           
           //Extend threejs with Triangle2d for scan line
           THREE.Triangle2D = function ( a, b, c ) {
                this.a = ( a !== undefined ) ? a : new THREE.Vector2();
                this.b = ( b !== undefined ) ? b : new THREE.Vector2();
                this.c = ( c !== undefined ) ? c : new THREE.Vector2();
           };           
           
           THREE.Triangle2D.prototype = {

                    constructor: THREE.Triangle2D,

                    set: function ( a, b, c ) {

                            this.a.copy( a );
                            this.b.copy( b );
                            this.c.copy( c );

                            return this;

                    },

                    setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

                            this.a.copy( points[i0] );
                            this.b.copy( points[i1] );
                            this.c.copy( points[i2] );

                            return this;

                    },

                    copy: function ( triangle ) {

                            this.a.copy( triangle.a );
                            this.b.copy( triangle.b );
                            this.c.copy( triangle.c );

                            return this;

                    },


                    clone: function () {

                            return new THREE.Triangle2D().copy( this );

                    }
            };

            THREE.Edge2D = function(pt1, pt2) {
                    if(pt1.y < pt2.y) {
                        this.pStart = pt1.clone();
                        this.pEnd   = pt2.clone();
                    } else {
                        this.pStart = pt2.clone();
                        this.pEnd   = pt1.clone();
                    }
            };
            
            /*
                *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog 
                *
                *	Subdivision Geometry Modifier 
                *		using Loop Subdivision Scheme
                *
                *	References:
                *		http://graphics.stanford.edu/~mdfisher/subdivision.html
                *		http://www.holmes3d.net/graphics/subdivision/
                *		http://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf
                *
                *	Known Issues et TODO for itowns:
                *		- currently doesn't handle UVs
                *		- currently doesn't handle "Sharp Edges"
                *
           */

            THREE.SubdivisionModifier = function ( subdivisions ) {

                    this.subdivisions = (subdivisions === undefined ) ? 1 : subdivisions;

            };

            // Applies the "modify" pattern
            THREE.SubdivisionModifier.prototype.modify = function ( geometry ) {

                    var repeats = this.subdivisions;

                    while ( repeats-- > 0 ) {
                            this.smooth( geometry );
                    }

                    delete geometry.__tmpVertices;
                    geometry.computeCentroids();
                    geometry.computeFaceNormals();
                    geometry.computeVertexNormals();

            };


            // Some constants et global functions
            var WARNINGS = !true; // Set to true for development
            var ABC = [ 'a', 'b', 'c' ];

            function getEdge( a, b, map ) {

                    var vertexIndexA = Math.min( a, b );
                    var vertexIndexB = Math.max( a, b );

                    var key = vertexIndexA + "_" + vertexIndexB;

                    return map[ key ];

            }


            function processEdge( a, b, vertices, map, face, metaVertices ) {

                    var vertexIndexA = Math.min( a, b );
                    var vertexIndexB = Math.max( a, b );

                    var key = vertexIndexA + "_" + vertexIndexB;

                    var edge;

                    if ( key in map ) {

                            edge = map[ key ];

                    } else {

                            var vertexA = vertices[ vertexIndexA ];
                            var vertexB = vertices[ vertexIndexB ];

                            edge = {

                                    a: vertexA, // pointer reference
                                    b: vertexB,
                                    newEdge: null,
                                    // aIndex: a, // numbered reference
                                    // bIndex: b,
                                    faces: [] // pointers to face

                            };

                            map[ key ] = edge;

                    }

                    edge.faces.push( face );

                    metaVertices[ a ].edges.push( edge );
                    metaVertices[ b ].edges.push( edge );

            }

            function generateLookups( vertices, faces, metaVertices, edges ) {

                    var i, il, face, edge;

                    for ( i = 0, il = vertices.length; i < il; i++ ) {
                            metaVertices[ i ] = { edges: [] };
                    }

                    for ( i = 0, il = faces.length; i < il; i++ ) {
                            face = faces[ i ];

                            processEdge( face.a, face.b, vertices, edges, face, metaVertices );
                            processEdge( face.b, face.c, vertices, edges, face, metaVertices );
                            processEdge( face.c, face.a, vertices, edges, face, metaVertices );

                    }
            }

            function newFace( newFaces, a, b, c ) {

                    newFaces.push( new THREE.Face3( a, b, c ) );

            }

            // Performs one iteration of Subdivision
            THREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {

                    var tmp = new THREE.Vector3();

                    var oldVertices, oldFaces;
                    var newVertices, newFaces; // newUVs = [];

                    var n, l, i, il, j, k;
                    var metaVertices, sourceEdges;

                    // new stuff.
                    var sourceEdges, newEdgeVertices, newSourceVertices;

                    oldVertices = geometry.vertices; // { x, y, z}
                    oldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }

                    /******************************************************
                     *
                     * Step 0: Preprocess Geometry to Generate edges Lookup
                     *
                     *******************************************************/

                    metaVertices = new Array( oldVertices.length );
                    sourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }

                    generateLookups(oldVertices, oldFaces, metaVertices, sourceEdges);


                    /******************************************************
                     *
                     *	Step 1. 
                     *	For each edge, create a new Edge Vertex,
                     *	then position it.
                     *
                     *******************************************************/

                    newEdgeVertices = [];
                    var other, currentEdge, newEdge, face;
                    var edgeVertexWeight, adjacentVertexWeight, connectedFaces;

                    for ( i in sourceEdges ) {

                            currentEdge = sourceEdges[ i ];
                            newEdge = new THREE.Vector3();

                            edgeVertexWeight = 3 / 8;
                            adjacentVertexWeight = 1 / 8;

                            connectedFaces = currentEdge.faces.length;

                            // check how many linked faces. 2 should be correct.
                            if ( connectedFaces != 2 ) {

                                    // if length is not 2, handle condition
                                    edgeVertexWeight = 0.5;
                                    adjacentVertexWeight = 0;

                                    if ( connectedFaces != 1 ) {

                                            if (WARNINGS) console.warn('Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge);

                                    }

                            }

                            newEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );

                            tmp.set( 0, 0, 0 );

                            for ( j = 0; j < connectedFaces; j++ ) {

                                    face = currentEdge.faces[ j ];

                                    for ( k = 0; k < 3; k++ ) {

                                            other = oldVertices[ face[ ABC[k] ] ];
                                            if (other !== currentEdge.a && other !== currentEdge.b ) break;

                                    }

                                    tmp.add( other );

                            }

                            tmp.multiplyScalar( adjacentVertexWeight );
                            newEdge.add( tmp );

                            currentEdge.newEdge = newEdgeVertices.length;
                            newEdgeVertices.push(newEdge);

                            // console.log(currentEdge, newEdge);
                    }

                    /******************************************************
                     *
                     *	Step 2. 
                     *	Reposition each source vertices.
                     *
                     *******************************************************/

                    var beta, sourceVertexWeight, connectingVertexWeight;
                    var connectingEdge, connectingEdges, oldVertex, newSourceVertex;
                    newSourceVertices = [];

                    for ( i = 0, il = oldVertices.length; i < il; i++ ) {

                            oldVertex = oldVertices[ i ];

                            // find all connecting edges (using lookupTable)
                            connectingEdges = metaVertices[ i ].edges;
                            n = connectingEdges.length;
                            beta;

                            if ( n == 3 ) {

                                    beta = 3 / 16;

                            } else if ( n > 3 ) {

                                    beta = 3 / ( 8 * n ); // Warren's modified formula

                            }

                            // Loop's original beta formula
                            // beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );

                            sourceVertexWeight = 1 - n * beta;
                            connectingVertexWeight = beta;

                            if ( n <= 2 ) {

                                    // crease and boundary rules
                                    // console.warn('crease and boundary rules');

                                    if ( n == 2 ) {

                                            if (WARNINGS) console.warn('2 connecting edges', connectingEdges);
                                            sourceVertexWeight = 3 / 4;
                                            connectingVertexWeight = 1 / 8;

                                            // sourceVertexWeight = 1;
                                            // connectingVertexWeight = 0;

                                    } else if ( n == 1 ) {

                                            if (WARNINGS) console.warn('only 1 connecting edge');

                                    } else if ( n == 0 ) {

                                            if (WARNINGS) console.warn('0 connecting edges');

                                    }

                            }

                            newSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );

                            tmp.set( 0, 0, 0 );

                            for ( j=0; j < n; j++ ) {

                                    connectingEdge = connectingEdges[ j ];
                                    other = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;
                                    tmp.add( other );

                            }

                            tmp.multiplyScalar( connectingVertexWeight );
                            newSourceVertex.add( tmp );

                            newSourceVertices.push( newSourceVertex );

                    }


                    /******************************************************
                     *
                     *	Step 3. 
                     *	Generate Faces between source vertecies
                     *	and edge vertices.
                     *
                     *******************************************************/

                    newVertices = newSourceVertices.concat( newEdgeVertices );
                    var sl = newSourceVertices.length, edge1, edge2, edge3;
                    newFaces = [];

                    for ( i = 0, il = oldFaces.length; i < il; i++ ) {

                            face = oldFaces[ i ];

                            // find the 3 new edges vertex of each old face

                            edge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;
                            edge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;
                            edge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;

                            // create 4 faces.

                            newFace( newFaces, edge1, edge2, edge3 );
                            newFace( newFaces, face.a, edge1, edge3 );
                            newFace( newFaces, face.b, edge2, edge1 );
                            newFace( newFaces, face.c, edge3, edge2 );

                    }

                    // Overwrite old arrays
                    geometry.vertices = newVertices;
                    geometry.faces = newFaces;

                    // console.log('done');

            };
        
          /*
           * *************End of Subdivision*****************************************
           */
          
          /*
           * ************* This section adapt from WebGL QuadTree Planet*************
           * ************* https://github.com/merpnderp *****************************
           */

            THREE.QuadTree = function (options) {

                this.name = options.name;
                this.position = options.corner;
                this.widthDir = options.widthDir;
                this.heightDir = options.heightDir;
                this.planet = options.planet;

                this.rootNode = new THREE.TreeNode({ parent: undefined, level: 0, tree: this, position: this.position });
            };

            THREE.QuadTree.prototype.update = function () {
                this.rootNode.update();
            };

            THREE.QuadTree.prototype.AssignNeighbors = function (left, top, right, bottom) {
                this.rootNode.leftNeighbor = left;
                this.rootNode.topNeighbor = top;
                this.rootNode.rightNeighbor = right;
                this.rootNode.bottomNeighbor = bottom;
            };

            
            THREE.TreeNode = function (options) {
                this.level = options.level;
                this.parent = options.parent;
                this.tree = options.tree;
                this.position = options.position;

                //console.log(this.position.x + " : " + this.position.y + " : " + this.position.z);

                this.width = this.tree.planet.radius * 2 / Math.pow(2, this.level);
                this.halfWidth = this.width / 2;
                //this.arcLength = (this.width / this.tree.planet.radius) / 1.43 //divided by fudge factor;
                this.arcLength = (this.width / this.tree.planet.radius);//divided by fudge factor;

                //This is the node's center location after the point is projected onto the sphere.
                this.center = this.FindCenter();
                this.name = this.center.x + ":" + this.center.y + ":" + this.center.z;

                this.isSplit = false;
                this.isDrawn = false;
                this.isOccluded = false;

            };


            THREE.TreeNode.prototype = {


                update: function () {
                    if (this.OccludedByHorizon()) {
                        if (this.isDrawn) {
                            this.isOccluded = true;
                            this.UnDraw();
                        }
                    } else {
                        this.isOccluded = false;
                        if (this.InCameraFrustum()) {
                            this.GetDistanceFromCamera();
                            if (this.isSplit) {
                                if (this.ShouldUnSplit()) {
                                    this.UnSplit();
                                    this.update();
                                } else {
                                    this.updateChildren();
                                }
                            } else if (this.ShouldSplit()) {
                                if (this.isDrawn) {
                                    this.UnDraw();
                                }
                                this.Split();
                                this.updateChildren();
                            }
                            /*else if (!this.isDrawn) {
                                this.ShouldDraw();
                            }*/
                        }
                    }
                },

	
                checkNeighbors: function(){

                            // T;BL;BR; If the top neighbor is split and either the bottem left or bottom right child is split
                    if(this.topNeighbor && this.topNeighbor.isSplit && (this.topNeighbor.bottomLeftChild.isSplit || this.topNeighbor.bottomRightChild.isSplit)){

                        this.Split();

                    }

                            // R;TL;BL; If the right neighbor is split and either the top left or bottom left child is split
                    if(this.rightNeighbor &&this.rightNeighbor.isSplit && (this.rightNeighbor.bottomLeftChild.isSplit || this.rightNeighbor.topLeftChild.isSplit)){

                        this.Split();

                    }

                            // B;TL;TR If the bottom neighbor is split and either the top left or top right child is split
                    if(this.bottomNeighbor && this.bottomNeighbor.isSplit && (this.bottomNeighbor.topLeftChild.isSplit || this.bottomNeighbor.topRightChild.isSplit)){

                        this.Split();

                    }

                            // L;TR;BR If the top neighbor is split and either the top right or bottom right child is split
                    if(this.leftNeighbor && this.leftNeighbor.isSplit && (this.leftNeighbor.topRightChild.isSplit || this.leftNeighbor.bottomRightChild.isSplit)){

                        this.Split();

                    }


                    if(this.isSplit){

                        if(this.topNeighbor && this.topNeighbor.isSplit){

                                            // -----------------     -----------------
                                            // |   | x |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                            // |   | o | â¢ |   |     |   | â¢ | â¢ |   |
                                            // -----------------  =  -----------------
                                            // |   | â¢ | â¢ |   |     |   | o | â¢ |   |
                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   | x |   |   |
                                            // -----------------     -----------------
                                        this.topLeftChild.topNeighbor = this.topNeighbor.bottomLeftChild;

                                            // -----------------     -----------------
                                            // |   |   | x |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                            // |   | â¢ | o |   |     |   | â¢ | â¢ |   |
                                            // -----------------  =  -----------------
                                            // |   | â¢ | â¢ |   |     |   | â¢ | o |   |
                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   | x |   |
                                            // -----------------     -----------------
                                        this.topRightChild.topNeighbor = this.topNeighbor.bottomRightChild;

                        }

                        if(this.rightNeighbor && this.rightNeighbor.isSplit){

                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                            // |   | â¢ | o | x |     | x | o | â¢ |   |
                                            // -----------------  =  -----------------
                                            // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                        this.topRightChild.rightNeighbor = this.rightNeighbor.topLeftChild;

                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                            // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                            // -----------------  =  -----------------
                                            // |   | â¢ | o | x |     | x | o | â¢ |   |
                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                        this.bottomRightChild.rightNeighbor = this.rightNeighbor.bottomLeftChild;

                                    }

                        if(this.bottomNeighbor && this.bottomNeighbor.isSplit){

                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   | x |   |   |
                                            // -----------------     -----------------
                                            // |   | â¢ | â¢ |   |     |   | o | â¢ |   |
                                            // -----------------  =  -----------------
                                            // |   | o | â¢ |   |     |   | â¢ | â¢ |   |
                                            // -----------------     -----------------
                                            // |   | x |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                        this.bottomLeftChild.bottomNeighbor = this.bottomNeighbor.topLeftChild;

                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   | x |   |
                                            // -----------------     -----------------
                                            // |   | â¢ | â¢ |   |     |   | â¢ | o |   |
                                            // -----------------  =  -----------------
                                            // |   | â¢ | o |   |     |   | â¢ | â¢ |   |
                                            // -----------------     -----------------
                                            // |   |   | x |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                        this.bottomRightChild.bottomNeighbor = this.bottomNeighbor.topRightChild;

                                    }

                        if(this.leftNeighbor && this.leftNeighbor.isSplit){

                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                            // | x | o | â¢ |   |     |   | â¢ | o | x |
                                            // -----------------  =  -----------------
                                            // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                        this.topLeftChild.leftNeighbor = this.leftNeighbor.topRightChild;

                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                                            // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                            // -----------------  =  -----------------
                                            // | x | o | â¢ |   |     |   | â¢ | o | x |
                                            // -----------------     -----------------
                                            // |   |   |   |   |     |   |   |   |   |
                                            // -----------------     -----------------
                            this.bottomLeftChild.leftNeighbor = this.leftNeighbor.bottomRightChild;

                                    }

                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                                    // |   | o | x |   |     |   | â¢ | x |   |
                                    // -----------------  =  -----------------
                                    // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                            this.topLeftChild.rightNeighbor = this.topRightChild;

                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                                    // |   | o | â¢ |   |     |   | â¢ | â¢ |   |
                                    // -----------------  =  -----------------
                                    // |   | x | â¢ |   |     |   | x | â¢ |   |
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                            this.topLeftChild.bottomNeighbor = this.bottomLeftChild;

                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                                    // |   | â¢ | o |   |     |   | â¢ | â¢ |   |
                                    // -----------------  =  -----------------
                                    // |   | â¢ | x |   |     |   | â¢ | x |   |
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                            this.topRightChild.bottomNeighbor = this.bottomRightChild;

                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                                    // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                    // -----------------  =  -----------------
                                    // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                            this.topRightChild.leftNeighbor = this.topLeftChild;
 
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                                    // |   | x | â¢ |   |     |   | x | â¢ |   |
                                    // -----------------  =  -----------------
                                    // |   | o | â¢ |   |     |   | â¢ | â¢ |   |
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                           this.bottomLeftChild.topNeighbor = this.topLeftChild;

                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                                    // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                    // -----------------  =  -----------------
                                    // |   | o | x |   |     |   | â¢ | x |   |
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                           this.bottomLeftChild.rightNeighbor = this.bottomRightChild;

                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                                    // |   | â¢ | x |   |     |   | â¢ | x |   |
                                    // -----------------  =  -----------------
                                    // |   | â¢ | o |   |     |   | â¢ | â¢ |   |
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                          this.bottomRightChild.topNeighbor = this.topRightChild;

                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                                    // |   | â¢ | â¢ |   |     |   | â¢ | â¢ |   |
                                    // -----------------  =  -----------------
                                    // |   | x | o |   |     |   | x | â¢ |   |
                                    // -----------------     -----------------
                                    // |   |   |   |   |     |   |   |   |   |
                                    // -----------------     -----------------
                          this.bottomRightChild.leftNeighbor = this.bottomLeftChild;

                       if(!this.leftNeighbor || this.leftNeighbor && !this.leftNeighbor.isSplit){
                                            // -----------------
                                            // |   |   |   |   |
                                            // -----------------
                                            // |   | x | â¢ |   |
                                            // -----------------
                                            // |   | â¢ | â¢ |   |
                                            // -----------------
                                            // |   |   |   |   |
                                            // -----------------
                                this.topLeftChild.checkNeighbors();

                                            // -----------------
                                            // |   |   |   |   |
                                            // -----------------
                                            // |   | â¢ | x |   |
                                            // -----------------
                                            // |   | â¢ | â¢ |   |
                                            // -----------------
                                            // |   |   |   |   |
                                            // -----------------
                                this.topRightChild.checkNeighbors();

                                            // -----------------
                                            // |   |   |   |   |
                                            // -----------------
                                            // |   | â¢ | â¢ |   |
                                            // -----------------
                                            // |   | x | â¢ |   |
                                            // -----------------
                                            // |   |   |   |   |
                                            // -----------------
                                this.bottomLeftChild.checkNeighbors();

                                            // -----------------
                                            // |   |   |   |   |
                                            // -----------------
                                            // |   | â¢ | â¢ |   |
                                            // -----------------
                                            // |   | â¢ | x |   |
                                            // -----------------
                                            // |   |   |   |   |
                                            // -----------------
                                this.bottomRightChild.checkNeighbors();				
                                    }


                    }

                },


                /*ShouldDraw: function(){
                    this.tree.planet.meshesMightAdd.push({name: this.name, draw: this.Draw.bind(this)});
                },*/

                Draw: function () {

                    var position;

                    return function () {
                        

                        if(this.isSplit){
                            this.topLeftChild.Draw();
                            this.topRightChild.Draw();
                            this.bottomLeftChild.Draw();
                            this.bottomRightChild.Draw();
                            return;
                        }

                        if(this.isDrawn || this.isOccluded){
                            return;
                        }

                        this.tree.planet.RemoveFromDeletedMeshes(this.name);

                        var positions = new Float32Array(this.tree.planet.patchSize * this.tree.planet.patchSize * 6 * 3);
                        var normals = new Float32Array(this.tree.planet.patchSize * this.tree.planet.patchSize * 6 * 3);
                        var uvs = new Float32Array(this.tree.planet.patchSize * this.tree.planet.patchSize * 6 * 2);

                        var positionCount = 0;
                        var uvsCount = 0;

                        var patchSize = this.tree.planet.patchSize;

                        for (var u = 0; u < patchSize; u++) {
                            for (var v = 0; v < patchSize; v++) {
                                position = this.SolvePoint(u / patchSize, v / patchSize);
                                positions[positionCount++] = position.x;
                                normals[positionCount-1] = positions[positionCount-1];
                                positions[positionCount++] = position.y;
                                normals[positionCount-1] = positions[positionCount-1];
                                positions[positionCount++] = position.z;
                                normals[positionCount-1] = positions[positionCount-1];
                                uvs[uvsCount++] = u / patchSize;
                                uvs[uvsCount++] = v / patchSize;


                                position = this.SolvePoint((u + 1) / patchSize, (v) / patchSize);
                                positions[positionCount++] = position.x;
                                positions[positionCount++] = position.y;
                                positions[positionCount++] = position.z;
                                uvs[uvsCount++] = (u + 1) / patchSize;
                                uvs[uvsCount++] = v / patchSize;

                                position = this.SolvePoint((u) / patchSize, (v + 1) / patchSize);
                                positions[positionCount++] = position.x;
                                positions[positionCount++] = position.y;
                                positions[positionCount++] = position.z;
                                uvs[uvsCount++] = (u) / patchSize;
                                uvs[uvsCount++] = (v + 1) / patchSize;

                                positions[positionCount++] = positions[positionCount - 4];
                                positions[positionCount++] = positions[positionCount - 4];
                                positions[positionCount++] = positions[positionCount - 4];
                                uvs[uvsCount++] = (u) / patchSize;
                                uvs[uvsCount++] = (v + 1) / patchSize;

                                positions[positionCount++] = positions[positionCount - 10];
                                positions[positionCount++] = positions[positionCount - 10];
                                positions[positionCount++] = positions[positionCount - 10];
                                uvs[uvsCount++] = (u + 1) / patchSize;
                                uvs[uvsCount++] = (v) / patchSize;

                                position = this.SolvePoint((u + 1) / patchSize, (v + 1) / patchSize);
                                positions[positionCount++] = position.x;
                                positions[positionCount++] = position.y;
                                positions[positionCount++] = position.z;
                                uvs[uvsCount++] = (u + 1) / patchSize;
                                uvs[uvsCount++] = (v + 1) / patchSize;
                            }
                        }

                        this.tree.planet.meshesToAdd.push(positions.buffer);
                        this.tree.planet.meshesToAdd.push(normals.buffer);
                        this.tree.planet.meshesToAdd.push(uvs.buffer);
                        //this.tree.planet.returnObject.newMeshes.push({name: this.name, center: this.center, positions: positions, uvs: uvs, normals: normals});
                        this.tree.planet.returnObject.newMeshes.push({name: this.name, width: this.width, center: this.center, positions: positions, uvs: uvs});

                        this.isDrawn = true;
                    };

                }(),

                SolvePoint: function () {
                    var x, y, z, length;
                    return function (u, v) {
                        
                        /*
                        var temp = this.tree.widthDir.clone();
                        temp.multiplyScalar(u);
                        temp.add(this.tree.heightDir.clone().multiplyScalar(v));
                        temp.multiplyScalar(this.width);
                        temp.add(this.position);
                        temp.normalize();
                        temp.multiplyScalar(this.tree.planet.radius);
                        return temp;
                        */
                        /*
                        width = this.width;
                        wx = this.tree.widthDir.x;
                        wy = this.tree.widthDir.y;
                        wz = this.tree.widthDir.z;
                        hx = this.tree.heightDir.x;
                        hy = this.tree.heightDir.y;
                        hz = this.tree.heightDir.z;
            */
                        x = ((this.tree.widthDir.x * u + this.tree.heightDir.x * v) * this.width) + this.position.x;
                        y = ((this.tree.widthDir.y * u + this.tree.heightDir.y * v) * this.width) + this.position.y;
                        z = ((this.tree.widthDir.z * u + this.tree.heightDir.z * v) * this.width) + this.position.z;

                        length = Math.sqrt( x * x + y * y + z * z );

                        x = (x / length) * this.tree.planet.radius - this.center.x;
                        y = (y / length) * this.tree.planet.radius - this.center.y;
                        z = (z / length) * this.tree.planet.radius - this.center.z;

                        return {
                                            x: x,
                                            y: y,
                                            z: z
                                    };

                    }
                }(),


                UnDraw: function () {

                    this.tree.planet.returnObject.deletedMeshes.push(this.name);
                    this.isDrawn = false;

                },


                GetDistanceFromCamera: function () {
                    return function () {
                        this.distance = this.tree.planet.localCameraPosition.distanceTo(this.center);
                    };
                }(),


                ShouldSplit: function () {
                    //console.log("\tShould " + this.level + " Split if: " + this.tree.sphere.splitTable[this.level] + " >= " + this.distance);
                    this.tree.planet.log(this.level + " < " + this.tree.planet.maxLevel);
                    return this.level < this.tree.planet.maxLevel && this.tree.planet.splitTable[this.level] >= this.distance;

                },


                ShouldUnSplit: function () {

                    //console.log("\tShould " + this.level + " UnSplit if: " + this.tree.sphere.splitTable[this.level-1] + " < " + this.distance);
                    return this.level >= 0 && this.tree.planet.splitTable[this.level] < this.distance;

                },


                InCameraFrustum: function () {

                    return true;

                },

                OccludedByHorizon: function () {
                    var angleToCamera = this.tree.planet.localCameraPlanetProjectionPosition.angleTo(this.center);

                    angleToCamera -= this.arcLength;

                    if (angleToCamera > this.tree.planet.localCameraMaxAngle) {
                        return true;
                    }
                    return false;
                },


                Split: function () {

                    var options;

                    return function () {
                        if(this.isSplit){
                            return;
                        }
                        options = {
                                            level: this.level + 1,
                                            parent: this,
                                            tree: this.tree
                                    };

                        options.position = this.position.clone().add(this.tree.heightDir.clone().multiplyScalar(this.halfWidth));
                        this.topLeftChild = new THREE.TreeNode(options);

                        options.position = this.position.clone().add(this.tree.heightDir.clone().multiplyScalar(this.halfWidth));
                        options.position.add(this.tree.widthDir.clone().multiplyScalar(this.halfWidth));
                        this.topRightChild = new THREE.TreeNode(options);

                        options.position = this.position.clone();
                        this.bottomLeftChild = new THREE.TreeNode(options);

                        options.position = this.position.clone().add(this.tree.widthDir.clone().multiplyScalar(this.halfWidth));
                        this.bottomRightChild = new THREE.TreeNode(options);

                        this.isSplit = true;

                    };

                }(),


                Die: function () {
                    if (this.isDrawn) {
                        this.UnDraw();
                    }
                            else if (this.isSplit) {
                        this.UnSplit();
                    }

                },


                UnSplit: function () {

                    if (this.isSplit) {

                        this.topLeftChild.Die();
                        this.topRightChild.Die();
                        this.bottomLeftChild.Die();
                        this.bottomRightChild.Die();
                        delete this.topLeftChild;
                        delete this.topRightChild;
                        delete this.bottomLeftChild;
                        delete this.bottomRightChild;

                    }

                    this.isSplit = false;

                },


                updateChildren: function () {

                    this.topLeftChild.update();
                    this.topRightChild.update();
                    this.bottomLeftChild.update();
                    this.bottomRightChild.update();

                },


                FindCenter: function () {

                    var x, y, z, w, wd, hd;

                    return function () {
                        x = this.position.x;
                        y = this.position.y;
                        z = this.position.z;
                        wd = this.tree.widthDir;
                        hd = this.tree.heightDir;
                        w = this.halfWidth;

                        x = x + wd.x * w + hd.x * w;
                        y = y + wd.y * w + hd.y * w;
                        z = z + wd.z * w + hd.z * w;
                        return new THREE.Vector3(x, y, z).normalize().multiplyScalar(this.tree.planet.radius);
                    };
                }()


            };



            THREE.QuadTreeSphere = function (options) {
                THREE.Object3D.call(this);
                this.isInitialized = false;
                this.pause = false;
                this.meshes = {};
                this.meshBuildTimeAvg = 0;

                    this.initializeOptions(options);

                    this.initializeWorker();

                    this.updateCounter = 0;
                    this.avg = 0;

            };

            THREE.QuadTreeSphere.prototype = Object.create(THREE.Object3D.prototype);

            THREE.QuadTreeSphere.prototype.initializeOptions = function (options, callback) {

                    this.workerPath = options.workerPath || "QuadTreeSphereWorker.min.js";

                    this.configureCamera(options.camera);

                this.scene = options.scene;
                this.radius = options.radius;
                this.patchSize = options.patchSize;
                this.fov = options.fov;

                    this.quadMaterial = options.quadMaterial;

            };

            THREE.QuadTreeSphere.prototype.configureCamera = function ( camera ) {

                this.camera = camera;
                this.cameraHeight = 0;

            };


            THREE.QuadTreeSphere.prototype.initializeWorker = function () {

                this.worker = new Worker(this.workerPath);
                this.worker.onmessage = this.onWorkerMessage.bind(this);

                this.worker.postMessage({
                            Init: {
                                    radius: this.radius,
                                    patchSize: this.patchSize,
                                    fov: this.fov,
                                    screenWidth: screen.width
                            }
                    });

            };

            THREE.QuadTreeSphere.prototype.update = function () {

                return function () {

                            var localCameraPosition;

                    if (!this.isInitialized) {
                        return;
                    }

                    localCameraPosition = this.worldToLocal(this.camera.position.clone());
                    this.cameraHeight = localCameraPosition.length() - this.radius;
                    if (this.pause) {
                        return;
                    }

                    this.worker.postMessage({
                                    update: {
                                            localCameraPosition: localCameraPosition,
                                            started: performance.now()
                                    }
                            });
                }
            }();

            THREE.QuadTreeSphere.prototype.onWorkerMessage = function (event) {

                // var me = this;

                    // Local reference so we don't have to scope traverse in the JIT compiler
                    var data = event.data;

                if (data.isInitialized) {
                    this.isInitialized = true;
                    return;
                }

                    // Is this akin to an Error?
                if (data.log) {
            //        console.log(data.log);
                    return;
                }

                if (data.deletedMeshes) {
                    data.deletedMeshes.forEach(this.removeMesh.bind(this));
                }

                if (data.newMeshes) {
                    if (data.newMeshes.length > 0) {

                        this.updateCounters += 1;
                        this.avg += (performance.now() - data.started);

                        this.meshBuildTimeAvg = this.avg / (this.updateCounters);

                        if ( this.updateCounters % 10 == 0 ) {

                            this.avg = 0;
                                            this.updateCounters= 0;

                        }
                    }

                    data.newMeshes.forEach(this.buildNewMesh.bind(this));
                }
                /*
                 console.log(Date.now() - data.started);
                 console.log(data.finished);
                 console.log(data);
                 */
            };

            /**
             * Remove a mesh from the scene and the THREE.QuadTreeSphere.
             */
            THREE.QuadTreeSphere.prototype.removeMesh = function (name) {

                this.scene.remove(this.meshes[name]);
                delete this.meshes[name];
                //console.log("Deleting: " + name);

            };

            THREE.QuadTreeSphere.prototype.buildNewMesh = function (mesh) {
                var buff = new THREE.BufferGeometry();


                buff.attributes.position = {};
                buff.attributes.position.array = mesh.positions;
                buff.attributes.position.itemSize = 3;
                /*
                 buff.attributes.normal = {};
                 buff.attributes.normal.array = mesh.normals;
                 buff.attributes.normal.itemSize = 3;
                 */
                buff.attributes.uv = {};
                buff.attributes.uv.array = mesh.uvs;
                buff.attributes.uv.itemSize = 2;

                buff.computeBoundingSphere();





                var newMesh = new THREE.Mesh(
                            buff, 
                            this.quadMaterial.buildMaterial(
                                    new THREE.Vector3(mesh.center.x, mesh.center.y, mesh.center.z),
                                    this.position,
                                    this.radius,
                                    mesh.width
                            )
                );

                newMesh.position.x = mesh.center.x;
                newMesh.position.y = mesh.center.y;
                newMesh.position.z = mesh.center.z;
                newMesh.position.add(this.position);

                this.scene.add(newMesh);
                this.meshes[mesh.name] = newMesh;

                    delete mesh;
            }
            
            
            
            var QuadTreeSphereWorker = function () {
                        // console.log("QuadTreeSphereWorker Spawned.");
                        self.onmessage = this.handleMessage.bind(this);
                };

                QuadTreeSphereWorker.prototype = {

                        handleMessage: function (event) {
                            if (event.data.Init) {
                                this.Init(event.data.Init);
                            }
                            if (event.data.update) {
                                this.update(event.data.update);
                            }
                        },

                        log: function (text) {
                        self.postMessage({
                                        log: text
                                });
                        },
	
                        update: function (data) {

                            this.log("Worker says update called");

                            this.returnObject = {
                                        started: data.started,
                                        newMeshes: [],
                                        deletedMeshes: []
                                };


                            this.meshesToAdd = [];


                            //Get local position of player
                            this.localCameraPosition = new THREE.Vector3(data.localCameraPosition.x, data.localCameraPosition.y, data.localCameraPosition.z);
                            this.localCameraPlanetProjectionPosition = this.localCameraPosition.clone().normalize().multiplyScalar(this.radius);
                            //this.cameraHeight = this.localCameraPosition.distanceTo(this.position) - this.radius;
                            this.cameraHeight = this.localCameraPosition.length() - this.radius;

                            this.localCameraMaxAngle = Math.acos(this.radius / (this.cameraHeight + this.radius));

                            this.cameraHeight = this.cameraHeight > 0 ? this.cameraHeight : this.radius + 1;
                            // this.log = function (text) {
                            //     self.postMessage({log: text});
                            // };
                            this.quadTrees.forEach(function (tree) {
                                tree.rootNode.update();
                            });
                            this.quadTrees.forEach(function (tree) {
                                tree.rootNode.checkNeighbors();
                            });

                            this.quadTrees.forEach(function (tree) {
                                tree.rootNode.Draw();
                            });


                            self.postMessage(this.returnObject, this.meshesToAdd);

                        },
	
                        RemoveFromDeletedMeshes: function (name) {

                            for (var i = 0, length = this.returnObject.deletedMeshes; i < length; i++) {
                                if (this.returnObject.deletedMeshes[i] == name) {
                                    this.returnObject.deletedMeshes.splice(i, 1);
                                    return;
                                }
                            }

                        },
	
                        Init: function (data) {

                                this.log("Worker says Init called");

                            this.radius = data.radius;
                            this.patchSize = data.patchSize;
                            this.fov = data.fov;
                            // this.geometryProvider = new GeometryProvider(this.patchSize);
                            this.vs = Math.tan(this.fov / data.screenWidth);
                            this.quadTrees = [];
                            this.splitTable = [];
                            this.BuildSplitTable();
                            this.InitQuadTrees();
                            this.AssignNeighbors();
                            self.postMessage({isInitialized: true});
                        },
	
                        BuildSplitTable: function () {
                            var patchPixelWidth, i = 0, patchSize = this.patchSize;
                            while (i < 200) {
                                patchPixelWidth = (Math.PI * this.radius * 2) / (patchSize * 6);
                                this.splitTable[i] = patchPixelWidth / this.vs;
                                patchSize = patchSize * 2;
                                if (this.splitTable[i] < 3) {
                                    this.maxLevel = i;
                                    break;
                                }
                                i++;
                            }
                        },
	
                        InitQuadTrees: function () {

                            var nearCorner = new THREE.Vector3(1, 1, 1).multiplyScalar(this.radius);
                            var farCorner = nearCorner.clone().multiplyScalar(-1);

                            //Near quadtrees
                            this.quadTrees.push(new THREE.QuadTree({name: "Bottom", corner: nearCorner, widthDir: new THREE.Vector3(0, 0, -1), heightDir: new THREE.Vector3(-1, 0, 0), planet: this}));
                            this.quadTrees.push(new THREE.QuadTree({name: "Front", corner: nearCorner, widthDir: new THREE.Vector3(-1, 0, 0), heightDir: new THREE.Vector3(0, -1, 0), planet: this}));
                            this.quadTrees.push(new THREE.QuadTree({name: "Left", corner: nearCorner, widthDir: new THREE.Vector3(0, -1, 0), heightDir: new THREE.Vector3(0, 0, -1), planet: this}));

                                //Far quadtrees
                            this.quadTrees.push(new THREE.QuadTree({name: "Top", corner: farCorner, widthDir: new THREE.Vector3(1, 0, 0), heightDir: new THREE.Vector3(0, 0, 1), planet: this}));
                            this.quadTrees.push(new THREE.QuadTree({name: "Back", corner: farCorner, widthDir: new THREE.Vector3(0, 1, 0), heightDir: new THREE.Vector3(1, 0, 0), planet: this}));
                            this.quadTrees.push(new THREE.QuadTree({name: "Right", corner: farCorner, widthDir: new THREE.Vector3(0, 0, 1), heightDir: new THREE.Vector3(0, 1, 0), planet: this}));

                        },
	
                        AssignNeighbors: function () {

                            var bottom = this.quadTrees[0].rootNode;
                            var front = this.quadTrees[1].rootNode;
                            var left = this.quadTrees[2].rootNode;
                            var top = this.quadTrees[3].rootNode;
                            var back = this.quadTrees[4].rootNode;
                            var right = this.quadTrees[5].rootNode;

                            this.quadTrees[0].AssignNeighbors(left, back, right, front);
                            this.quadTrees[1].AssignNeighbors(left, top, right, bottom);
                            this.quadTrees[2].AssignNeighbors(bottom, back, top, front);
                            this.quadTrees[3].AssignNeighbors(right, front, left, back);
                            this.quadTrees[4].AssignNeighbors(top, left, bottom, right);
                            this.quadTrees[5].AssignNeighbors(back, bottom, front, top);

                        }
                };
                
                //dinhnq 
                THREE.QuadTreeSphereBlobWorker = function () {
                    
                    var funcObj = new QuadTreeSphereWorker();
                    // Build a worker from an anonymous function body
                    var blobURL = URL.createObjectURL(new Blob(['(',

                            funcObj.toString(),

                                ')()'], {
                                type: 'application/javascript'
                            }));
                    return blobURL;
                };
                
                var QuadBuilder = function () {

                };

                QuadBuilder.prototype = {

                    BuildQuadForGrid: function () {

                                var baseIndex, index0, index1, index2, index3, n = new THREE.Vector3(0, 0, 1);

                                return function (geo, position, uv, buildTriangles, vertsPerRow, swapOrder) {

                                    geo.vertices.push(position);
                                    geo.faceVertexUvs.push(uv);

                                    //geo.faceVertexUvs[0].push([]);

                                    if (buildTriangles) {

                                        baseIndex = geo.vertices.length - 1;
                                        index0 = baseIndex;
                                        index1 = baseIndex - 1;
                                        index2 = baseIndex - vertsPerRow;
                                        index3 = baseIndex - vertsPerRow - 1;

                                        if (swapOrder) {
                                            geo.faces.push(new THREE.Face3(index0, index1, index3, [n, n, n]));
                                            geo.faces.push(new THREE.Face3(index0, index3, index2, [n, n, n]));
                                        } else {
                                            geo.faces.push(new THREE.Face3(index2, index1, index3, [n, n, n]));
                                            geo.faces.push(new THREE.Face3(index0, index1, index2, [n, n, n]));
                                        }
                                    }
                                };
                    }()
                };
                
                //
                // Supply a material to a quadrant.
                // To implement your configuration requires a getMaterialForQuad callback method.
                //
                THREE.QuadMaterialBuilder = function (config) {
                        this.config = config;
                        try {
                                this.config.onCreate();
                        }
                        catch (e) {
                                console.error("QuadMaterial onCreate had an error.", e);
                        }
                };

                THREE.QuadMaterialBuilder.prototype = {

                        /**
                         * Vector3 position - The center point of the quad
                         * float radius - Radius of the planet which hosts the quad
                         */
                        buildMaterial: function (centerPoint, position, radius, width) {
                                try {
                                        return this.config.buildMaterialForQuad(centerPoint, position, radius, width);
                                }
                                catch (e) {
                                        console.error("Unable to build quad material.", e);

                                        var color = new THREE.Color();
                                        color.r = color.g = color.b = 255;

                                        return new THREE.MeshBasicMaterial({wireframe: true, color: color});

                                }

                        }

                };

            /*
             * 
             *  Terrain  
            * 
             */
            
            THREE.Terrain = function (resolution, radius, clipMapCount) {

                    THREE.Object3D.call(this);

                    this.radius = radius;
                    this.resolution = resolution;
                    this.clipMapCount = clipMapCount;

                    this.geometry = new THREE.PlaneGeometry(1, 1, resolution, resolution);

                    this.position = new THREE.Vector3(0, 0, 0);
                    this.clipMaps = [];

                    this.terrainCamera = new TerrainCamera(radius, settings.fov, resolution, Window.innerWidth);

                    this.clipMapCount = this.terrainCamera.getViewTheta(settings.minPossibleHeight);
                    this.clipMapCount = Math.floor((Math.log(1 / (this.clipMapCount / Math.PI))) / Math.log(2));

                    this.createClipMaps();

                };

                THREE.Terrain.prototype = Object.create(THREE.Object3D.prototype);

                THREE.Terrain.prototype = {

                    update: function (cameraPosition) {
                        this.updateCameraPosition(cameraPosition);
                        this.updateClipMaps();
                    },

                    updateCameraPosition: function (cameraPosition) {
                        localCameraPosition.copy(cameraPosition);
                        this.worldToLocal(localCameraPosition);
                        this.terrainCamera.update(localCameraPosition);
                    },


                    updateClipMaps: function () {
                        var maxTheta = this.getViewTheta(this.terrainCamera.height);
                        var minTheta = this.terrainCamera.viewTheta;
                        for (var i = 0; i < this.clipMapCount; i++) {
                            if (this.clipMaps[i].theta > minTheta || this.clipMaps[i].theta < minTheta) {
                                if (!this.clipMaps[i].hidden) {
                                    this.clipMaps[i].hide();
                                }
                            } else {
                                if (this.clipMaps[i].hidden) {
                                    this.clipMaps[i].show();
                                }
                                this.clipMaps[i].theta = this.terrainCamera.theta;
                                this.clipMaps[i].phi = this.terrainCamera.phi;
                                //snap positions to grid
                            }
                        }
                    },

                    createClipMaps: function () {
                        var scale = this.radius;
                        for (var i = 0; i < this.clipMapCount; i++) {

                            this.clipMaps[i] = new ClipMap(scale, this.geometry);
                            this.clipMaps[i].theta = this.getViewTheta(scale / 2);//get inner ring theta

                            this.children.concat(this.clipMaps[i].meshes);

                            scale = scale / 2;
                        }
                    },

                    getViewTheta: function (height) {
                        return Math.acos(this.radius / (this.radius + height));
                    }
                };
                
                var terrainCamera = function (radius, fov, resolution, pixels) {
                        this.fov = fov;
                        this.resolution = resolution;
                        this.pixels = pixels;
                        this.phi = 0;
                        this.theta = 0;
                        this.viewTheta = 0;
                        this.height = 0;
                        this.position = 0;
                        this.radius = radius;
                };

                terrainCamera.prototype = {
                         update: function (localCameraPosition) {
                             this.phi = Math.atan2(this.localCameraPosition.x, this.localCameraPosition.x);
                             this.theta = Math.acos(this.localCameraPosition.y); //0 at north pole, PI at south pole
                             this.height = localCameraPosition.length() - this.radius;
                             this.position = localCameraPosition;
                             this.viewTheta = this.getViewTheta(this.height);
                         },

                         getViewTheta: function (height) {
                             var vs = Math.tan(this.fov / this.pixels);
                             var lt = ( (height * vs) / this.radius ) * this.resolution;

                             return lt;
                         }
                };
            
              var Edge = {
                            NONE: 0,
                            TOP: 1,
                            LEFT: 2,
                            BOTTOM: 4,
                            RIGHT: 8
                  };

             var clipMap = function (scale, geo) {
                    this.hidden = false;
                    this.geo    = geo;
                    this.meshes = [];
                    this.phi   = 0;
                    this.theta = 0;

                    // Create center layer first
                    // +---+---+
                    // | O | O |
                    // +---+---+
                    // | O | O |
                    // +---+---+
                    this.createTile(-scale, -scale, scale, Edge.NONE);
                    this.createTile(-scale, 0, scale, Edge.NONE);
                    this.createTile(0, 0, scale, Edge.NONE);
                    this.createTile(0, -scale, scale, Edge.NONE);

                    // Create "quadtree" of tiles, with smallest in center
                    // Each added layer consists of the following tiles (marked 'A'), with the tiles
                    // in the middle being created in previous layers
                    // +---+---+---+---+
                    // | A | A | A | A |
                    // +---+---+---+---+
                    // | A |   |   | A |
                    // +---+---+---+---+
                    // | A |   |   | A |
                    // +---+---+---+---+
                    // | A | A | A | A |
                    // +---+---+---+---+

                    this.createTile(-2 * scale, -2 * scale, scale, Edge.BOTTOM | Edge.LEFT);
                    this.createTile(-2 * scale, -scale, scale, Edge.LEFT);
                    this.createTile(-2 * scale, 0, scale, Edge.LEFT);
                    this.createTile(-2 * scale, scale, scale, Edge.TOP | Edge.LEFT);

                    this.createTile(-scale, -2 * scale, scale, Edge.BOTTOM);
                    // 2 tiles 'missing' here are in previous layer
                    this.createTile(-scale, scale, scale, Edge.TOP);

                    this.createTile(0, -2 * scale, scale, Edge.BOTTOM);
                    // 2 tiles 'missing' here are in previous layer
                    this.createTile(0, scale, scale, Edge.TOP);

                    this.createTile(scale, -2 * scale, scale, Edge.BOTTOM | Edge.RIGHT);
                    this.createTile(scale, -scale, scale, Edge.RIGHT);
                    this.createTile(scale, 0, scale, Edge.RIGHT);
                    this.createTile(scale, scale, scale, Edge.TOP | Edge.RIGHT);

                };

                clipMap.prototype = {

                    hide: function(){
                        this.hidden = true;
                        this.meshes.forEach(function(mesh){
                           mesh.visible = false;
                        });
                    },

                    show: function(){
                        this.hidden = false;
                        this.meshes.forEach(function(mesh){
                            mesh.visible = true;
                        });
                    },

                    createTile: function (x, y, scale, edgeMorphy) {
                        var terrainMaterial = new THREE.MeshBasicMaterial();
                        this.meshes.push(new THREE.Mesh(this.geo, terrainMaterial));
                    }
                };
            

});
define ('lib/BinaryStream',[],function(){

           var BinaryStream = function(data, isBigEndian) {
                    if(isBigEndian)
                            throw 'BinaryStream constructor failed: Big endian is not supported yet!';

                    this.data = data;
                    this.offset = 0;
            };

            BinaryStream.prototype.size = function() {
                    return this.data.length;
            };
            BinaryStream.prototype.tell = function() {
                    return this.offset;
            };
            BinaryStream.prototype.seek = function(position) {
                    if(position < 0 || position >= this.data.length)
                            return false;

                    this.offset = position;

                    return true;
            };
            BinaryStream.prototype.reset = function() {
                    this.offset = 0;
            };
            BinaryStream.prototype.skip = function(bytesToSkip) {
                    if(this.offset + bytesToSkip > this.data.length)
                            this.offset = this.data.length;
                    else
                            this.offset += bytesToSkip;
            };
            BinaryStream.prototype.available = function() {
                    return this.data.length - this.offset;
            };
            BinaryStream.prototype.eof = function() {
                    return !(this.offset < this.data.length);
            };
            BinaryStream.prototype.readUInt8 = function() {
                    return this.decodeInt(1, false);
            };
            BinaryStream.prototype.readInt8 = function() {
                    return this.decodeInt(1, true);
            };
            BinaryStream.prototype.readUInt16 = function() {
                    return this.decodeInt(2, false);
            };
            BinaryStream.prototype.readInt16 = function() {
                    return this.decodeInt(2, true);
            };
            BinaryStream.prototype.readUInt32 = function() {
                    return this.decodeInt(4, false);
            };
            BinaryStream.prototype.readInt32 = function() {
                    return this.decodeInt(4, true);
            };
            BinaryStream.prototype.readFloat32 = function() {
                    return this.decodeFloat(4, 23);
            };
            BinaryStream.prototype.readFloat64 = function() {
                    return this.decodeFloat(8, 52);
            };
            BinaryStream.prototype.readBytes = function(buffer, bytesToRead) {
                    var bytesRead = bytesToRead;
                    if(this.offset + bytesToRead > this.data.length)
                            bytesRead = this.data.length - this.offset;

                    for(var i=0; i<bytesRead; i++) {
                            buffer[i] = this.data[this.offset++].charCodeAt(0) & 0xff;
                    }

                    return bytesRead;
            };
            BinaryStream.prototype.decodeInt = function(bytes, isSigned) {
                    if(this.offset + bytes > this.data.length) {
                            this.offset = this.data.length;
                            return NaN;
                    }

                    var rv = 0, f = 1;
                    for(var i=0; i<bytes; i++) {
                            rv += ((this.data[this.offset++].charCodeAt(0) & 0xff) * f);
                            f *= 256;
                    }

                    if( isSigned && (rv & Math.pow(2, bytes * 8 - 1)) )
                            rv -= Math.pow(2, bytes * 8);

                    return rv;
            };
            BinaryStream.prototype.decodeFloat = function(bytes, significandBits) {
                    if(this.offset + bytes > this.data.length) {
                            this.offset = this.data.length;
                            return NaN;
                    }

                    var mLen = significandBits;
                    var eLen = bytes * 8 - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;

                    var i = bytes - 1; 
                    var d = -1; 
                    var s = this.data[this.offset + i].charCodeAt(0) & 0xff; 
                    i += d; 
                    var bits = -7;
                    var e = s & ((1 << (-bits)) - 1);
                    s >>= -bits;
                    bits += eLen
                    while(bits > 0) {
                            e = e * 256 + (this.data[this.offset + i].charCodeAt(0) & 0xff);
                            i += d;
                            bits -= 8;
                    }

                    var m = e & ((1 << (-bits)) - 1);
                    e >>= -bits;
                    bits += mLen;
                    while(bits > 0) {
                            m = m * 256 + (this.data[this.offset + i].charCodeAt(0) & 0xff);
                            i += d;
                            bits -= 8;
                    }

                    this.offset += bytes;

                    switch(e) {
                            case 0:		// 0 or denormalized number
                                    e = 1 - eBias;
                                    break;
                            case eMax:	// NaN or +/-Infinity
                                    return m ? NaN : ((s ? -1 : 1) * Infinity);
                            default:	// normalized number
                                    m += Math.pow(2, mLen);
                                    e -= eBias;
                                    break;
                    }

                    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };

return BinaryStream;

});

define ('lib/PlatformInfo',[],function(){
              var PlatformInfo = (function() {
                var info = {
                        browser:		'other', 
                        version:		'0.0.0', 
                        isTouchDevice:	(document.createTouch !== undefined)	// detect if it is running on a touch device
                };

                var agents = [
                        ['firefox', /Firefox[\/\s](\d+(?:.\d+)*)/], 
                        ['chrome',  /Chrome[\/\s](\d+(?:.\d+)*)/ ], 
                        ['opera',   /Opera[\/\s](\d+(?:.\d+)*)/], 
                        ['safari',  /Safari[\/\s](\d+(?:.\d+)*)/], 
                        ['webkit',  /AppleWebKit[\/\s](\d+(?:.\d+)*)/], 
                        ['ie',      /MSIE[\/\s](\d+(?:.\d+)*)/]
                ];

                var matches;
                for(var i=0; i<agents.length; i++) {
                        if((matches = agents[i][1].exec(window.navigator.userAgent))) {
                                info.browser = agents[i][0];
                                info.version = matches[1];
                                break;
                        }
                }

                return info;
        }) ();
 
 return PlatformInfo;
 
 });
/*nguyen dot quocdinh at gmail dot com
 */

define ('lib/3DSLoader',['lib/three','lib/BinaryStream','lib/PlatformInfo'],function(THREE,BinaryStream,PlatformInfo){
        var DS3Loader = function(dalle) {
                    this.decimalPrecision = 3;
                    this._materials = {};
                    this._unfinalized_objects = {};
                    this._textures={};

                    this._cur_obj_end = 0;
                    this._cur_obj;
                    
                    this._cur_mat_end = 0;
                    this._cur_mat;

                    this.totalFaces = 0;
                    this.pivot      = new THREE.Vector3(0,0,0);
                    //only for test
                    this.dalle      = dalle;
                    var self = this;
                    var xhr = new XMLHttpRequest;
  		    var urlName = dalle.getUrlDSFile();
                    xhr.open('GET', urlName, true);
                    
                    if(PlatformInfo.browser === 'ie' && PlatformInfo.version >= '10')
                            xhr.responseType = 'blob';	// use blob method to deal with 3DS files for IE >= 10
                    else{
                        xhr.overrideMimeType('text/plain; charset=x-user-defined');
                    }

                    xhr.onreadystatechange = function() {
                        if(this.readyState === 4) {
                            if(this.status === 200 || this.status === 0) {
                                    if(PlatformInfo.browser === 'ie' && PlatformInfo.version >= '10') {
                                        // asynchronously decode blob to binary string
                                        var blobReader = new FileReader;
                                        //remplace scene par callback
                                        blobReader.onload = function(event) {
                                            self.parse3DS(event.target.result);
                                        };
                                        blobReader.readAsText(this.response, 'x-user-defined');
                                    }
                                    else {
                                        self.parse3DS(this.responseText);
                                    }
                            }
                            else {
                                   console.log('Failed to load 3DS file "' + urlName + '".');
                            }
                        }
                    };

                    xhr.send();
        };
        DS3Loader.prototype.setDecimalPrecision = function(precision) {
                this.decimalPrecision = precision;
        };

        DS3Loader.prototype.parseMaterial= function (reader, endMaterial) {
 
                var mat = {};

                while (reader.tell() < endMaterial) {
                    var cid ;
                    var len;
                    var end;

                    cid = reader.readUInt16();
                    len = reader.readUInt32();
                    end = reader.tell() + (len-6);

                    switch (cid) {
                        case 0xA000: // Material name
                            mat.name = this.readNulTermString(reader);
                            break;

                        case 0xA010: // Ambient color
                            mat.ambientColor = this.readColor(reader);
                            break;

                        case 0xA020: // Diffuse color
                            mat.diffuseColor = this.readColor(reader);
                            break;

                        case 0xA030: // Specular color
                            mat.specularColor = this.readColor(reader);
                            break;

                        case 0xA050: // transparency
                            mat.transparency = this.readAmount(reader,end);
                          break;

                        case 0xA081: // Two-sided, existence indicates "true"
                            mat.twoSided = true;
                            break;

                        case 0xA200: // Main (color) texture
                            mat.colorMap = this.parseTexture(reader,end);
                            break;

                        case 0xA204: // Specular map
                            mat.specularMap = this.parseTexture(reader,end);
                            break;

                        default:
                            reader.seek(end);
                            break;
                    }
                }

                return mat;
        };

        DS3Loader.prototype.readAmount = function(reader,end) {

            var cid;
            var len;
            var amount = 0;
            cid = reader.readUInt16();
            len = reader.readUInt32();

            switch (cid) {
                case 0x0030: // Floats
                    amount = reader.readUInt16();
                    break;
                default:
                    break;
            }
            reader.seek(end);
                return amount;
        };

        DS3Loader.prototype.readColor = function(reader) {
            var cid;
            var len;
            var r, g, b;

            cid = reader.readUInt16();
            len = reader.readUInt32();

            switch (cid) {
                case 0x0010: // Floats
                    r = reader.readFloat32() * 255;
                    g = reader.readFloat32() * 255;
                    b = reader.readFloat32() * 255;
                    break;
                case 0x0011: // 24-bit color
                    r = reader.readUInt8();
                    g = reader.readUInt8();
                    b = reader.readUInt8();
                    break;
                default:
                    reader.skip(len-6);
                    break;
            }

            return (r<<16) | (g<<8) | b;
        };

        DS3Loader.prototype.parseTexture = function(reader, endTexture) {
            var tex ={};

            while (reader.tell() < endTexture) {
                var cid;
                var len;

                cid = reader.readUInt16();
                len = reader.readUInt32();

                switch (cid) {
                    case 0xA300:
                        tex.url = this.readNulTermString(reader);
                        break;

                    default:
                        // Skip this unknown texture sub-chunk
                        reader.skip(len-6);
                        break;
                }
            }

            this._textures[tex.url] = tex;
            return tex;
        };

        DS3Loader.prototype.readNulTermString= function (reader) {
            var chr;
            var str = '';

            while ((chr = reader.readUInt8()) > 0) {
                str += String.fromCharCode(chr);
            }

            return str;
        };

        DS3Loader.prototype.parseVertexList = function (reader) {
                  var i = 0;
                  var count = reader.readUInt16();
                  this._cur_obj.verts = new Array(count);

                  while (i<count) {
                      var x, y, z;

                      x = reader.readFloat32();
                      y = reader.readFloat32();
                      z = reader.readFloat32();
                      
                      this._cur_obj.verts[i] = new THREE.Vector3(x,z,y) ;
                      i++;
                  }
        };

        DS3Loader.prototype.parseFaceList = function (reader) {
                    var i = 0;
                    var count = reader.readUInt16();
                    this._cur_obj.facesCount = count;
                    this._cur_obj.indices = [];
                    this._cur_obj.uvsIndexes = [];

                    while (i < count) {
                        var i0, i1, i2;

                        i0 = reader.readUInt16();
                        i1 = reader.readUInt16();
                        i2 = reader.readUInt16();
                        this._cur_obj.indices.push(new THREE.Face3(i0,i2,i1));

                        this._cur_obj.uvsIndexes.push(new THREE.Vector3(i0,i2,i1));

                        i++;
                        // Skip "face info", irrelevant data
                        reader.skip(2);
                    }

                    this._cur_obj.smoothingGroups = [];
                    for (var index = 0 ; index <this._cur_obj.facesCount;index++){
                        this._cur_obj.smoothingGroups[index] = 0;
                    }
        };



        DS3Loader.prototype.parseUVList = function (reader) {
            var i = 0;
            var count = reader.readUInt16();
            this._cur_obj.uvs = [];
 
            while (i < count) {
                var u,v;
                 
                u = reader.readFloat32();
                v = 1- reader.readFloat32();   
                this._cur_obj.uvs.push(new THREE.Vector2(u,v));
                i+=1;
            }
           //console.log(this._cur_obj.uvs); 
        };


        DS3Loader.prototype.parseFaceMaterialList = function (reader) {
                var mat   = this.readNulTermString(reader);
                var count = reader.readUInt16();
                var i = 0;
                var faces = [];

                for (var index = 0 ; index < count;index++){
                    faces[index] = 0;
                }

                while (i<faces.length) {
                    faces[i++] = reader.readUInt16();
                }

                this._cur_obj.materials.push(mat);
                this._cur_obj.materialFaces[mat] = faces;
        };


        DS3Loader.prototype.readTransform = function (reader) {
             var n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44;
                // X axis
                n11 = reader.readFloat32(); // X
                n31 = reader.readFloat32(); // Z
                n21 = reader.readFloat32(); // Y
                n41 = 0;

                // Z axis
                n13 = reader.readFloat32(); // X
                n33 = reader.readFloat32(); // Z
                n23 = reader.readFloat32(); // Y
                n43 = 0;

                // Y Axis
                n12 = reader.readFloat32(); // X
                n32 = reader.readFloat32(); // Z
                n22 = reader.readFloat32(); // Y
                n42 = 0;

                // Translation
                n14 = reader.readFloat32(); // X
                n34 = reader.readFloat32(); // Z
                n24 = reader.readFloat32(); // Y
                n44 = 1;
                //console.log(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
                return new THREE.Matrix4( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );
        };

        DS3Loader.prototype.parseObjectAnimation = function (reader,end) {
                var vo, obj, name, hier;

                // Pivot defaults to origin
                var px,py,pz;
                while (reader.tell() < end) {
                    var cid;
                    var len;

                    cid = reader.readUInt16();
                    len = reader.readUInt32();

                    switch (cid) {
                        case 0xb010: // Name/hierarchy
                            name = this.readNulTermString(reader);
                            reader.skip(4);
                            hier = reader.readInt16();
                            break;

                        case 0xb013: // Pivot
                            px = reader.readFloat32();
                            pz = reader.readFloat32();
                            py = reader.readFloat32();
                            if((px !==0) && (pz!==0))
                                    this.pivot.set(px,py,pz);
                            //console.log('pivot',pivot.x,pivot.y,pivot.z)
                            break;

                        default:
                            reader.skip(len-6);
                            break;
                    }
                }
                if (name != '$$$DUMMY' && this._unfinalized_objects.hasOwnProperty(name)) {
                    vo = this._unfinalized_objects[name];
                    delete this._unfinalized_objects[name];
                }
        };


        DS3Loader.prototype.parseSmoothingGroups = function (reader) {
            var len = this._cur_obj.facesCount;
            var i = 0;
            while (i < len) {
                this._cur_obj.smoothingGroups[i] = reader.readUInt32();
                i++;
            }
        };

        
        DS3Loader.prototype.finalizeCurrentMaterial = function () {
                this._materials[this._cur_mat.name] = this._cur_mat;
                this._cur_mat = null;
        };

        DS3Loader.prototype.parse3DS = function(data) {

              var reader = new BinaryStream(data);
                  reader.reset();
            
              while (!reader.eof()) {

                        if (this._cur_mat && reader.tell() >= this._cur_mat_end) {
                                    this.finalizeCurrentMaterial();
                        }
                        else if (this._cur_obj &&  reader.tell() >= this._cur_obj_end) {
                                    
                                    this.dalle.parse3DSGeometry(this);
                                     
                                    this.totalFaces+=this._cur_obj.facesCount;
                                    this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
                                    this._cur_obj_end = Number.MAX_VALUE;
                                    this._cur_obj = null;
                        }//end if


                        var cid, len, end;
                            cid = reader.readUInt16();
                            len = reader.readUInt32();
                            end = reader.tell() + (len-6);

                        switch (cid) {
                                case 0x4D4D: // MAIN3DS
                                    //console.log('Read MAIN3DS');
                                    continue;
                                    break;
                                case 0x3D3D: // EDIT3DS
                                    //console.log('Read EDIT3DS');
                                    continue;
                                    break;
                                case 0xB000: // KEYF3DS
                                    //console.log('Read KEYF3DS');
                                    continue;
                                    break;

                                case 0xAFFF: // MATERIAL
                                    //console.log('Read material');
                                    this._cur_mat_end = end;
                                    this._cur_mat = this.parseMaterial(reader,end);
                                    break;

                                case 0x4000: // EDIT_OBJECT
                                    //console.log('Read object');
                                    this._cur_obj_end = end;
                                    this._cur_obj = {};
                                    this._cur_obj.name = this.readNulTermString(reader);
                                    this._cur_obj.materials = [];
                                    this._cur_obj.materialFaces = [];
                                    break;

                                case 0x4100: // OBJ_TRIMESH

                                    this._cur_obj.type = 'mesh';
                                    break;

                                case 0x4110: // TRI_VERTEXL
                                    //console.log('Read the vertex buffer');
                                    this.parseVertexList(reader);
                                    break;

                                case 0x4140: // TRI_MAPPINGCOORDS
                                   // console.log('Read the texture coords buffer');
                                    this.parseUVList(reader);
                                    break;

                                case 0x4120: // TRI_FACELIST
                                   // console.log('Read the faces buffer');
                                    this.parseFaceList(reader);
                                    break;
                                case 0x4130: // Face materials
                                   // console.log('Read the face materials buffer');
                                    this.parseFaceMaterialList(reader);
                                    break;

                                case 0x4160: // Transform
                                   // console.log('Read the object transformation');
                                    this._cur_obj.transform = this.readTransform(reader);
                                    break;

                                case 0xB002: // Object animation (including pivot)
                                   // console.log('Read the object animation');
                                    this.parseObjectAnimation(reader,end);
                                    break;

                                case 0x4150: // Smoothing groups
                                   // console.log('Read the smoothing groups');
                                    this.parseSmoothingGroups(reader);
                                    break;

                                default:
                                    // Skip this (unknown) chunk
                                    reader.skip(len-6);
                                   // console.log('unknown chunk'); 
                                    break;
                            }
                    }
                    if(reader.eof()){
                           
                            this.dalle.parseDallePivot(this.pivot);
                            this.dalle.showDalleInScene();
                            this.dalle.emptyGeometryCache();
                            this.dalle.emptyMaterialsCache();
                            console.log('3DS object was loaded !');
                            console.log(' totalFaces='+this.totalFaces);
                    }
                   

        };

        DS3Loader.prototype.decimalPrecision = 3;

    return DS3Loader;
    
});
/*nguyen dot quocdinh at gmail dot com
 */
define ('lib/B3DLoader',['lib/three','lib/BinaryStream','lib/PlatformInfo'],function(THREE,BinaryStream,PlatformInfo){
       
        var B3DLoader = function(dalle) {
                    this.decimalPrecision = 3;
                    this._materials = {};
                    this._unfinalized_objects = {};
                    this._textures={};

                    this._cur_obj_end = 0;
                    this._cur_obj;
                    
                    this._cur_mat_end = 0;
                    this._cur_mat;

                    this.totalFaces = 0;
                    this.pivot      = new THREE.Vector3(0,0,0);
                    //only for test
                    this.dalle      = dalle;
                    var self = this;
                    var xhr = new XMLHttpRequest;
					var urlName = dalle.getUrlDSFile();
                    xhr.open('GET', urlName, true);
                    if(PlatformInfo.browser === 'ie' && PlatformInfo.version >= '10')
                            xhr.responseType = 'blob';	// use blob method to deal with b3d files for IE >= 10
                    else{
                        xhr.overrideMimeType('text/plain; charset=x-user-defined');
                    }

                    xhr.onreadystatechange = function() {
                        if(this.readyState === 4) {
                            if(this.status === 200 || this.status === 0) {
                                    if(PlatformInfo.browser === 'ie' && PlatformInfo.version >= '10') {
                                        var blobReader = new FileReader;
                                        blobReader.onload = function(event) {
                                            self.parseB3D(event.target.result);
                                        };
                                        blobReader.readAsText(this.response, 'x-user-defined');
                                    }
                                    else {
                                        self.parseB3D(this.responseText);
                                    }
                            }
                            else {
                                   console.log('Failed to load B3D file "' + urlName + '".');
                            }
                        }
                    };

                    xhr.send();
        };
        B3DLoader.prototype.setDecimalPrecision = function(precision) {
                this.decimalPrecision = precision;
        };

        B3DLoader.prototype.parseMaterial= function (reader, endMaterial) {
 
                var mat = {};

                while (reader.tell() < endMaterial) {
                    var cid ;
                    var len;
                    var end;

                    cid = reader.readUInt16();
                    len = reader.readUInt32();
                    end = reader.tell() + (len-6);

                    switch (cid) {
                        case 0xA000: // Material name
                            mat.name = this.readNulTermString(reader);
                            break;

                        case 0xA010: // Ambient color
                            mat.ambientColor = this.readColor(reader);
                            break;

                        case 0xA020: // Diffuse color
                            mat.diffuseColor = this.readColor(reader);
                            break;

                        case 0xA030: // Specular color
                            mat.specularColor = this.readColor(reader);
                            break;

                        case 0xA050: // transparency
                            mat.transparency = this.readAmount(reader,end);
                          break;

                        case 0xA081: // Two-sided, existence indicates "true"
                            mat.twoSided = true;
                            break;

                        case 0xA200: // Main (color) texture
                            mat.colorMap = this.parseTexture(reader,end);
                            break;

                        case 0xA204: // Specular map
                            mat.specularMap = this.parseTexture(reader,end);
                            break;

                        default:
                            reader.seek(end);
                            break;
                    }
                }

                return mat;
        };

        B3DLoader.prototype.readAmount = function(reader,end) {

            var cid;
            var len;
            var amount = 0;
            cid = reader.readUInt16();
            len = reader.readUInt32();

            switch (cid) {
                case 0x0030: // Floats
                    amount = reader.readUInt16();
                    break;
                default:
                    break;
            }
            reader.seek(end);
                return amount;
        };

        B3DLoader.prototype.readColor = function(reader) {
            var cid;
            var len;
            var r, g, b;

            cid = reader.readUInt16();
            len = reader.readUInt32();

            switch (cid) {
                case 0x0010: // Floats
                    r = reader.readFloat32() * 255;
                    g = reader.readFloat32() * 255;
                    b = reader.readFloat32() * 255;
                    break;
                case 0x0011: // 24-bit color
                    r = reader.readUInt8();
                    g = reader.readUInt8();
                    b = reader.readUInt8();
                    break;
                default:
                    reader.skip(len-6);
                    break;
            }

            return (r<<16) | (g<<8) | b;
        };

        B3DLoader.prototype.parseTexture = function(reader, endTexture) {
            var tex ={};

            while (reader.tell() < endTexture) {
                var cid;
                var len;

                cid = reader.readUInt16();
                len = reader.readUInt32();

                switch (cid) {
                    case 0xA300:
                        tex.url = this.readNulTermString(reader);
                        break;

                    default:
                        // Skip this unknown texture sub-chunk
                        reader.skip(len-6);
                        break;
                }
            }

            this._textures[tex.url] = tex;
            return tex;
        };

        B3DLoader.prototype.readNulTermString= function (reader) {
            var chr;
            var str = '';

            while ((chr = reader.readUInt8()) > 0) {
                str += String.fromCharCode(chr);
            }

            return str;
        };

        B3DLoader.prototype.parseVertexList = function (reader) {
                  var i = 0;
                  var count = reader.readUInt16();
                  //console.log('have to read '+count+' vertices');
            
                  this._cur_obj.verts = new Array(count);

                  while (i<count) {
                      var x, y, z;

                      x = reader.readFloat32();
                      y = reader.readFloat32();
                      z = reader.readFloat32();
                      
                      this._cur_obj.verts[i] = new THREE.Vector3(x,z,y) ;
                      
                                          
                      i++;
                  }
        };

        B3DLoader.prototype.parseFaceList = function (reader) {
                    var i = 0;
                    var count = reader.readUInt16();
                    this._cur_obj.facesCount = count;
                    this._cur_obj.indices = [];
                    this._cur_obj.uvsIndexes = [];

                    while (i < count) {
                        var i0, i1, i2;

                        i0 = reader.readUInt16();
                        i1 = reader.readUInt16();
                        i2 = reader.readUInt16();
                        this._cur_obj.indices.push(new THREE.Face3(i0,i2,i1));

                        this._cur_obj.uvsIndexes.push(new THREE.Vector3(i0,i2,i1));

                        i++;
                        // Skip "face info", irrelevant data
                        reader.skip(2);
                    }

                    this._cur_obj.smoothingGroups = [];
                    for (var index = 0 ; index <this._cur_obj.facesCount;index++){
                        this._cur_obj.smoothingGroups[index] = 0;
                    }
        };
        B3DLoader.prototype.parseUVList = function (reader) {
            var i = 0;
            var count = reader.readUInt16();
            this._cur_obj.uvs = [];
 
            while (i < count) {
                var u,v;
                 
                u = reader.readFloat32();
                v = 1- reader.readFloat32();   
                this._cur_obj.uvs.push(new THREE.Vector2(u,v));
                i+=1;
            }
        };
        B3DLoader.prototype.parseFaceMaterialList = function (reader) {
                var mat   = this.readNulTermString(reader);
                var count = reader.readUInt16();
                var i = 0;
                var faces = [];

                for (var index = 0 ; index < count;index++){
                    faces[index] = 0;
                }

                while (i<faces.length) {
                    faces[i++] = reader.readUInt16();
                }

                this._cur_obj.materials.push(mat);
                this._cur_obj.materialFaces[mat] = faces;
        };

        
        B3DLoader.prototype.finalizeCurrentMaterial = function () {
                this._materials[this._cur_mat.name] = this._cur_mat;
                this._cur_mat = null;
        };

        B3DLoader.prototype.parseB3D = function(data) {

              var reader = new BinaryStream(data);
                  reader.reset();
            
              while (!reader.eof()) {

                        if (this._cur_mat && reader.tell() >= this._cur_mat_end) {
                                    this.finalizeCurrentMaterial();
                        }
                        else if (this._cur_obj &&  reader.tell() >= this._cur_obj_end) {
                                    
                                    this.dalle.parseB3DObject(this);
                                     
                                    this.totalFaces+=this._cur_obj.facesCount;
                                    this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
                                    this._cur_obj_end = Number.MAX_VALUE;
                                    this._cur_obj = null;
                        }//end if


                        var cid, len, end;
                            cid = reader.readUInt16();
                            len = reader.readUInt32();
                            end = reader.tell() + (len-6);

                        switch (cid) {
                                case 0x4D4D: // MAINB3D
                                    continue;
                                    break;
                                case 0x3D3D: // EDITB3D
                                    continue;
                                    break;
                                case 0xB000: // KEYFB3D
                                    continue;
                                    break;

                                case 0xAFFF: // MATERIAL
                                    this._cur_mat_end = end;
                                    this._cur_mat = this.parseMaterial(reader,end);
                                    break;

                                case 0x4000: // EDIT_OBJECT
                                    this._cur_obj_end = end;
                                    this._cur_obj = {};
                                    this._cur_obj.name = this.readNulTermString(reader);
                                    this._cur_obj.materials = [];
                                    this._cur_obj.materialFaces = [];
                                    break;

                                case 0x4100: // OBJ_TRIMESH

                                    this._cur_obj.type = 'mesh';
                                    break;

                                case 0x4110: // TRI_VERTEXL
                                    this.parseVertexList(reader);
                                    break;

                                case 0x4140: // TRI_MAPPINGCOORDS
                                    this.parseUVList(reader);
                                    break;

                                case 0x4120: // TRI_FACELIST
                                    this.parseFaceList(reader);
                                    break;
                                case 0x4130: // Face materials
                                    this.parseFaceMaterialList(reader);
                                    break;

                                default:
                                    reader.skip(len-6);
                                    break;
                            }
                    }
                    if(reader.eof()){
                            this.dalle.parseDallePivot(this.pivot);
                            this.dalle.showDalleInScene();
                            this.dalle.emptyGeometryCache();
                            this.dalle.emptyMaterialsCache();
                            console.log('B3D object was loaded !');
                            console.log(' totalFaces='+this.totalFaces, 'Dalle Name=' + this.dalle.name);
                    }
        };

        B3DLoader.prototype.decimalPrecision = 3;

    return B3DLoader;
    
});
/* 
 * To manage Bati 3D layer
 * quocdinh dot nguyen at gmail dot com
 */
define('Cartography3D',['jquery', 'GraphicEngine', 'lib/three', 'lib/threeExt', 'Panoramic', 'Dispatcher', 'Cartography','lib/3DSLoader', 'Shader','lib/B3DLoader','Draw', 'Utils', 'Config'],
    function($, gfxEngine, THREE, THREEExt, Panoramic, Dispatcher, Cartography, DS3Loader, Shader, B3DLoader, Draw, Utils, Config) {
        
        
               
            //GLOBAL VARIABLE
            var _events = {
                                MOVE: function() {
                                       Cartography3D.update();
                                }
            };
            
            var _textureType = '.dds';
          
            //manage planet by quadSphere
            var quadSpherePlanet = {
                     quadMaterial : new THREE.QuadMaterialBuilder({
			
                                onCreate : function () {
                                                    // NOP
                                },

                                buildMaterialForQuad : function (centerPoint, position, radius, width) {

                                                var color = new THREE.Color();

                                                    var decimalColor = ((width/1E11) * 16777215);


                                                var R =	 decimalColor%256;
                                                var G =	 (decimalColor/256)%256;
                                                var B =	 Math.sin(width);//((decimalColor/256)/256)%256;

                                                color.r = R;
                                                color.g = G;
                                                color.b = B;

                                                return new THREE.MeshBasicMaterial({wireframe: true, color: color});

                                }
                    }),
		    quadSphere : null    
            };
            
            var dalleClasse  =  function(){
                
                    this.dataURL         = "";
                    this.name            = '';
                    this.path            = '';
                    this.pivot           = new THREE.Vector3(0,0,0);
                    this.LOBLevel        = {  level:0, 
                                              urlDS3 : '', 
                                              urlDDS : '',
                                              urlDDS16:'' 
                                           };
                    this.textureType = '.dds';  
                    this.dalleOpacity = 1.;
                    this.cachedMaterials = {   
                                                loadMaterials : true,
                                                materials     : [],
                                                textures : [],
                                                imgUrlMaterial: [],
                                                urls:  []
                                           };
                    this.geometry        =  new THREE.Geometry();                        
                    this.materialsName   = [];
                    this.mesh            = null;
                    this.globalObject = new THREE.Object3D();        
                    this.shaderMat = null;
                    this.texture1 = null;
                    this.racineFile = "";//Version4LODS";  // Version4LODS_o for jpg
            };
            
            dalleClasse.prototype.addSubMeshToDalle = function(mesh){
                    this.dalleObject.add(mesh);
            };
            dalleClasse.prototype.setDalleZeroPivot     = function(v){
                    //this is zero
                    this.pivot = v;
            };
            
            dalleClasse.prototype.setTextureType = function(t){
              
                this.textureType = t;
            };
            dalleClasse.prototype.addMaterialsName  = function(v){
                    this.materialsName.push(v);
            };
            dalleClasse.prototype.getIndexMaterialName = function(v){
                    return this.materialsName.indexOf(v);
            };
            dalleClasse.prototype.setNamePath = function(name){
                    
                    this.path = "EXPORT_" + name + "/" + "export-3DS" +"/";
                    this.name = name;
            };
            /*
            dalleClasse.prototype.setNamePath = function(name){
                    this.name = name;
                    this.path = this.name + "/" + this.name +"/";
            };
            */
            dalleClasse.prototype.isMaterialsLoaded  = function() {
                    return this.cachedMaterials.loadMaterials;
            };
            dalleClasse.prototype.setMaterialsLoaded = function(v) {
                    this.cachedMaterials.loadMaterials = v;
            }; 
            dalleClasse.prototype.addDalleMaterials = function(mat){
                    this.cachedMaterials.materials.push(mat);
            };
            dalleClasse.prototype.addTextureURL= function(url){
                    this.cachedMaterials.urls.push(url);
            };
            dalleClasse.prototype.addTextureAlex = function(texture){
                    this.cachedMaterials.textures.push(texture);
            };
            dalleClasse.prototype.mergeObject = function(object){
                    THREE.GeometryUtils.merge( this.geometry, object );
            };
            dalleClasse.prototype.mergeGeometry = function(geom){
                    THREE.GeometryUtils.merge( this.geometry, geom);
            };
            dalleClasse.prototype.checkDoubleVertices = function(){
                    this.geometry.mergeVertices(); 
            };
            dalleClasse.prototype.setLoDLevel = function(v){
                    this.LOBLevel.level = v; 
            };
            dalleClasse.prototype.getLoDLevel = function(){
                    return this.LOBLevel.level; 
            };
            dalleClasse.prototype.subdivision = function(){
                    this.checkDoubleVertices();
                    var modifier = new THREE.SubdivisionModifier(this.LOBLevel);
                    modifier.modify(this.geometry);
            };

            dalleClasse.prototype.getDalleGemetry  = function(){
                   return this.geometry;
            };            
            
            
            dalleClasse.prototype.showDalleInScene = function(){

                    /*  this.mesh = new THREE.Mesh(  this.geometry, 
                                                   new THREE.MeshFaceMaterial( 
                                                                             this.cachedMaterials.materials)
                                                 );
                   gfxEngine.addToScene(this.mesh);
                  */
              

           // Create mesh for each n material with BufferGeomtry and specific shader material 
                   var vertices = this.geometry.vertices;  // Pointeur
                   var faces = this.geometry.faces;
                   var faceVertexUvs = this.geometry.faceVertexUvs;
                   var nbMaterials = this.cachedMaterials.urls.length;
                   var nbTexturesInShader = 16;
                   
                  
                   var geom2 = new THREE.Geometry();
                   for(n=0;n<=nbMaterials;n+=nbTexturesInShader){
                       
                        //var geom2 = new THREE.Geometry();
                        geom2.vertices = this.geometry.vertices;//.slice(); 
                        //geom2.faceVertexUvs = this.geometry.faceVertexUvs.slice();
                       // var geom2 = this.geometry.clone();
                        geom2.faces = [];
                        geom2.faceVertexUvs[0] = [];
                        for ( var i = 0; i < faces.length; i ++ ) {
                            
                                var face = faces[ i ];
                                var faceUV = faceVertexUvs[0][i];
                                if (face.materialIndex >= n && face.materialIndex <n+nbTexturesInShader){
                                    geom2.faces.push(face);
                                    geom2.faceVertexUvs[0].push(faceUV);
                                }   
                        }
                        
                        
                        var bufferGeometry = THREE.BufferGeometryUtils.fromGeometry(geom2,{indice:n} );

                        var mat = this.createShaderForBati();
                        for(var a=0;a<nbTexturesInShader;++a){
                            
                           if(n+a< nbMaterials) this.affectTexture(mat,n+a,a);
                            
                        }

                        var mesh = new THREE.Mesh(bufferGeometry,mat);//this.cachedMaterials.materials[n]);
                        
                        this.globalObject.add(mesh);
                        
                        //gfxEngine.addToScene(mesh);
                   }   
                     gfxEngine.addToScene(this.globalObject);
                  /*    
                        var bufferGeometry = THREE.BufferGeometryUtils.fromGeometry(this.geometry );
                       // var mesh = new THREE.Mesh(bufferGeometry,new THREE.MeshBasicMaterial({side : THREE.DoubleSide, wireframe:true,color:0xff0000}));
                        var mesh = new THREE.Mesh(bufferGeometry,this.cachedMaterials.materials[0]);
                        gfxEngine.addToScene(mesh);
                        console.log(bufferGeometry);
                 */
            };
            
            dalleClasse.prototype.load3DS    =     function(){
                    var loader = new DS3Loader(this);
            };
            dalleClasse.prototype.affectTexture = function(shaderMat,numMaterial,numTexture){
                //console.log("aaaaaaaaa");
                 var urlTexture = this.cachedMaterials.urls[numMaterial]; //console.log(urlTexture);
                 var texture;
                 THREE.ImageUtils.crossOrigin= 'use-credentials';   // No anonymous to keep ability to access password protected files (behind dir Viewer)
                 if(this.textureType=='.dds'){
                    texture = THREE.ImageUtils.loadDDSTexture(urlTexture,null,
                                           function() {
                                               shaderMat.uniforms["u_textures"].value[numTexture] = texture;   // onLoad function
                                               texture.dispose();
                                           }
                                  );
                    texture.generateMipmaps = false;
                   }
                else{
                    texture = THREE.ImageUtils.loadTexture(urlTexture,null,function() { "http://www.itowns.fr/images/textures/quoc.png"
                                               shaderMat.uniforms["u_textures"].value[numTexture] = texture;   // onLoad function
                                               texture.dispose();
                                           }
                                  );
                          
                    texture.generateMipmaps = true;;
                 }
                  texture.minFilter = texture.magFilter = THREE.LinearFilter;
                  texture.anisotropy = 4;
                  texture.needsUpdate = true;
                  texture.name = numMaterial;

                 // shaderMat.uniforms["u_textures"].value[numTexture] = texture ;//this.cachedMaterials.textures[numMaterial];//texture ;//this.cachedMaterials.textures[numMaterial];//this.texture1;//this.cachedMaterials.materials[0].map;//THREE.ImageUtils.loadTexture("images/itowns.png");//new THREE.Texture();//this.cachedMaterials.materials[0].map);
                 // shaderMat.uniforms["u_textures"].value[numTexture].needsUpdate = true;
                
            };
            
             pushTextureToGPU2 = function(){
                console.log('pushTextureToGPU2',this);
            };
            
            dalleClasse.prototype.pushTextureToGPU = function(texture){
                console.log('pushTextureToGPU',texture);
            };
           /*
            * works
            dalleClasse.prototype.affectTexture = function(shaderMat,numMaterial,numTexture){
                 shaderMat.uniforms["u_textures"].value[numTexture] = this.cachedMaterials.textures[numMaterial];//this.texture1;//this.cachedMaterials.materials[0].map;//THREE.ImageUtils.loadTexture("images/itowns.png");//new THREE.Texture();//this.cachedMaterials.materials[0].map);
                 shaderMat.uniforms["u_textures"].value[numTexture].needsUpdate = true;
            };
         */
                      
            dalleClasse.prototype.createShaderForBati = function(){

                var uniformsBati = {
                    alpha: {type: "f", value: this.dalleOpacity},
                    textureJPG : { type: "i" ,value: this.textureType =='.jpg'},
                    u_textures : { type: "tv", value: [ new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),
                                                        new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),
                                                        new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),new THREE.Texture(),
                                                        new THREE.Texture()] }, 
                    light: {type: "v3", value:  Cartography3D.light}                            
               };
                
              var attributesBati = {
                  //position: {type: 'v3', value: []},
                    materialindice: {type: 'f', value: []}
              };

                              
                 // create the shader material
                var shaderMat = new THREE.ShaderMaterial({
                        uniforms:     	uniformsBati,
                        attributes: attributesBati,
                        vertexShader:   Shader.shaderBati3DVS.join("\n"),//Shader.shaders['shaderBati3D.vs'],
                        fragmentShader: Shader.shaderBati3DFS.join("\n"),//Shader.shaders['shaderBati3D.fs'],
                        side: THREE.DoubleSide,
                        transparent:true
                });
                
                return shaderMat;
            };
        
            dalleClasse.prototype.emptyGeometryCache = function(){
                   //suppose garbage collector work well, we just
                   //dÃ©reference memory buffer!
                    this.geometry = new THREE.Geometry();
            };
            dalleClasse.prototype.emptyMaterialsCache = function(){
                    this.cachedMaterials.materials = [];
                    this.setMaterialsLoaded(true);
            };    
            dalleClasse.prototype.generateAmbientColor = function(ambient){
                    var ambientR = (ambient & 0xff0000) >> 16;
                    var ambientG = (ambient & 0xff00) >> 8;
                    var ambientB = ambient  & 0xff;
                    this.colorMaterial.ambient.setRGB(ambientR,ambientG,ambientB);
            };
       
            dalleClasse.prototype.generateDidduseColor = function(diffuse) {
                    var diffuseR = (diffuse & 0xff0000) >> 16;
                    var diffuseG = (diffuse & 0xff00) >> 8;
                    var diffuseB = diffuse  & 0xff;
                    this.colorMaterial.diffuse.setRGB(diffuseR, diffuseG,diffuseB);
            };
            
              
	    dalleClasse.prototype.computeUrlLoBLevel = function(){
                
                if(this.textureType=='.dds'){
		   switch(this.getLoDLevel())
		   {
			 case 0 :
                                this.LOBLevel.urlDS3    =  this.dataURL +  this.path + "ZoneAExporter.3DS";
				this.LOBLevel.urlDDS    =  this.textureType;	
				break;
			 case 2 :
				this.LOBLevel.urlDS3    =  this.dataURL +  this.path + "ZoneAExporter-0.b3d";
				this.LOBLevel.urlDDS    =  this.textureType;
                                this.LOBLevel.urlDDS16  =  '-16'+this.textureType;
				break;
			 case 4 :
                                this.LOBLevel.urlDS3    =  this.dataURL + this.path + "ZoneAExporter-1.b3d";
				this.LOBLevel.urlDDS	=  '-4'+this.textureType;
                                this.LOBLevel.urlDDS16  =  '-16'+this.textureType;
				break;									
			 case 8 :
                                this.LOBLevel.urlDS3    =  this.dataURL + this.path + "ZoneAExporter-2.b3d";
				this.LOBLevel.urlDDS	=  '-8'+this.textureType;
                                this.LOBLevel.urlDDS16  =  '-16'+this.textureType;
				break;									
			 case 16 :
				this.LOBLevel.urlDS3    =  this.dataURL + this.path + "ZoneAExporter-3.b3d"//"images/Bati3D/" + this.path + "ZoneAExporter-3.b3d"; 
				this.LOBLevel.urlDDS	=  '-16'+this.textureType;
                                this.LOBLevel.urlDDS16  =  '-16'+this.textureType;
				break;																		
			default : 
			        console.log('Cartography3D: does not support this level');
			        break;
		   }
               }else{
                    switch(this.getLoDLevel())
		   {
			 case 0 :
                                this.LOBLevel.urlDS3    =  this.dataURL +  this.path + "ZoneAExporter.3DS";
				this.LOBLevel.urlDDS    =  this.textureType;	
				break;
			 case 2 :
				this.LOBLevel.urlDS3    =  this.dataURL +  this.path + "ZoneAExporter-0.b3d";
				this.LOBLevel.urlDDS    =  this.textureType;
                                this.LOBLevel.urlDDS16  =  this.textureType;
				break;
			 case 4 :
                                this.LOBLevel.urlDS3    =  this.dataURL +  this.path + "ZoneAExporter-1.b3d";
				this.LOBLevel.urlDDS	=  this.textureType;
                                this.LOBLevel.urlDDS16  =  this.textureType;
				break;									
			 case 8 :
                                this.LOBLevel.urlDS3    =  this.dataURL +  this.path + "ZoneAExporter-2.b3d";
				this.LOBLevel.urlDDS	=  this.textureType;
                                this.LOBLevel.urlDDS16  =  this.textureType;
				break;									
			 case 16 :
				this.LOBLevel.urlDS3    =  this.dataURL +  this.path + "ZoneAExporter-3.b3d"//"images/Bati3D/" + this.path + "ZoneAExporter-3.b3d"; 
				this.LOBLevel.urlDDS	=  this.textureType;
                                this.LOBLevel.urlDDS16  =  this.textureType;
				break;																		
			default : 
			        console.log('Cartography3D: does not support this level');
			        break;
		   }
               }
                   
	    };
	    dalleClasse.prototype.computeUrlLoBLevelSAVE = function(){
                
                if(this.textureType=='.dds'){
		   switch(this.getLoDLevel())
		   {
			 case 0 :
                                this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter.3DS";
				this.LOBLevel.urlDDS    =  this.textureType;	
				break;
			 case 2 :
				this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter-0.b3d";
				this.LOBLevel.urlDDS    =  this.textureType;
                                this.LOBLevel.urlDDS16  =  '-16'+this.textureType;
				break;
			 case 4 :
                                this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter-1.b3d";
				this.LOBLevel.urlDDS	=  '-4'+this.textureType;
                                this.LOBLevel.urlDDS16  =  '-16'+this.textureType;
				break;									
			 case 8 :
                                this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter-2.b3d";
				this.LOBLevel.urlDDS	=  '-8'+this.textureType;
                                this.LOBLevel.urlDDS16  =  '-16'+this.textureType;
				break;									
			 case 16 :
				this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter-3.b3d"//"images/Bati3D/" + this.path + "ZoneAExporter-3.b3d"; 
				this.LOBLevel.urlDDS	=  '-16'+this.textureType;
                                this.LOBLevel.urlDDS16  =  '-16'+this.textureType;
				break;																		
			default : 
			        console.log('Cartography3D: does not support this level');
			        break;
		   }
               }else{
                    switch(this.getLoDLevel())
		   {
			 case 0 :
                                this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter.3DS";
				this.LOBLevel.urlDDS    =  this.textureType;	
				break;
			 case 2 :
				this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter-0.b3d";
				this.LOBLevel.urlDDS    =  this.textureType;
                                this.LOBLevel.urlDDS16  =  this.textureType;
				break;
			 case 4 :
                                this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter-1.b3d";
				this.LOBLevel.urlDDS	=  this.textureType;
                                this.LOBLevel.urlDDS16  =  this.textureType;
				break;									
			 case 8 :
                                this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter-2.b3d";
				this.LOBLevel.urlDDS	=  this.textureType;
                                this.LOBLevel.urlDDS16  =  this.textureType;
				break;									
			 case 16 :
				this.LOBLevel.urlDS3    =  "../Bati3D_LOB/Version4LODS/" + this.path + "ZoneAExporter-3.b3d"//"images/Bati3D/" + this.path + "ZoneAExporter-3.b3d"; 
				this.LOBLevel.urlDDS	=  this.textureType;
                                this.LOBLevel.urlDDS16  =  this.textureType;
				break;																		
			default : 
			        console.log('Cartography3D: does not support this level');
			        break;
		   }
               }
                   
	    };
	    dalleClasse.prototype.getUrlDSFile	 = function(){
		    return this.LOBLevel.urlDS3;
	    };
	    dalleClasse.prototype.getUrlDDSFile	 = function(){
	 	    return this.LOBLevel.urlDDS;
	    };
            
            dalleClasse.prototype.getUrlDDS16	 = function(){
                    return this.LOBLevel.urlDDS16;
	    };
            
            dalleClasse.prototype.load    =     function(){
		    this.computeUrlLoBLevel();
		    var loader = new B3DLoader(this);
            };
            dalleClasse.prototype.setVisible = function(v){
                    this.globalObject.traverse( function ( object ) { object.visible = v; } );
                   // this.globalObject.traverse( function ( object ) { if(object.material) object.material.uniforms.alpha.value = 0.3;} );
                    console.log('Bati3D visibility is ',v);
                    //this.mesh.visible Visi= v;
            };
            
            dalleClasse.prototype.setOpacity = function(v){
                    this.globalObject.traverse( function ( object ) { if(object.material) object.material.uniforms.alpha.value = v;} );
                //    console.log('Bati3D opacity is ',v);
            };
            
            dalleClasse.prototype.removeFromScene = function(){
                    //gfxEngine.removeFromScene(this.mesh);
                    gfxEngine.removeFromScene(this.globalObject);
                    this.globalObject.traverse( function ( object ) { gfxEngine.removeFromScene(object);} );
            };
            
            
            dalleClasse.prototype.setLightPosition = function(v){
                    this.globalObject.traverse( function ( object ) { if(object.material) object.material.uniforms.light.value = v;} );
                //    console.log('Bati3D opacity is ',v);
            };
        
            dalleClasse.prototype.parseB3DObject = function(instantB3D){
                    var     self = this, 
                            obj = instantB3D._cur_obj,
			    urlDDS   = self.getUrlDDSFile(),
                            urlDDS16 = self.getUrlDDS16() ;
                    
                            //add vertices and faces
                            this.geometry.vertices   = obj.verts,
                            this.geometry.faces      = obj.indices;    //face index
                            
                            if(gfxEngine.isMobileEnvironment()) this.racineFile = "Version4LODS_o"; 
                            //load texture one time at begining
                            if(self.isMaterialsLoaded()) {
                                     var mat = null;
                                     for(var materialName in instantB3D._materials){
                                              mat = instantB3D._materials[materialName];
                                              if (mat.colorMap) {
                                                  
                                                  var imgUrl   = this.dataURL+this.racineFile+"/" + self.path + mat.colorMap.url.split('.')[0] + urlDDS;
                                                  self.addTextureURL(imgUrl);
                                                  self.addMaterialsName(materialName);
                                              }              
                                     }
                                     self.setMaterialsLoaded(false);
                            }  
                            
                            //add uv texture if exist
                            
                            for(var i= 0; i < obj.uvsIndexes.length ; i++){
                                      this.geometry.faceVertexUvs[0].push([
                                            obj.uvs[obj.uvsIndexes[i].x],
                                            obj.uvs[obj.uvsIndexes[i].y],
                                            obj.uvs[obj.uvsIndexes[i].z]
                                      ]);
                                    
                            }

                             
                              var materialFaces = obj.materialFaces;
                              for(var materialName in materialFaces){
                                    var ind      = self.getIndexMaterialName(materialName);
                                    
                                    var indFaces = materialFaces[materialName];
                                   
                                    for ( var j = 0; j < indFaces.length; j ++ ) {
                                            this.geometry.faces[indFaces[j]].materialIndex = ind;
                                    }    
                              }
                              
                              
                              this.geometry.computeFaceNormals();
                              this.geometry.computeVertexNormals();  
                              
                             //self.mergeGeometry(new THREE.Mesh(geometry));
                   //}// end check uv
            };
            /*
            dalleClasse.prototype.parseDallePivot  = function(p){
                    //console.log('dalle pivot',p);
                    if((p.x !==0)&&(p.y !==0)){
                        var xp =  Math.abs(p.x) - this.pivot.x,
                            yp =  Math.abs(p.y) - this.pivot.y,
                            zp =  Math.abs(p.z) - this.pivot.z;
                        this.geometry.applyMatrix( new THREE.Matrix4().makeTranslation( xp, yp, zp) );
                    }     
            };
            */
           
            dalleClasse.prototype.parseDallePivot  = function(p){
                        var xp =  - this.pivot.x,
                            yp =  - this.pivot.y,
                            zp =  - this.pivot.z;
                        this.geometry.applyMatrix( new THREE.Matrix4().makeTranslation( xp, yp, zp) );
            };
           
            dalleClasse.prototype.parse3DSGeometry = function(instant3DS){
                                    
                 var self = this, obj = instant3DS._cur_obj; 
                 if(obj.uvs !== undefined){        
                             var geometry = new THREE.Geometry();
                                   //add vertices and faces
                                   geometry.vertices   = obj.verts,
                                   geometry.faces      = obj.indices;    //face index
                             //load texture one time at begining
                             if(self.isMaterialsLoaded()) {
                                        var mat = null;
                                        for(var materialName in instant3DS._materials){
                                                 mat = instant3DS._materials[materialName];
                                                 if (mat.colorMap) {
                                                       self.addDalleMaterials(new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe :true})); 
                                                       self.addMaterialsName(materialName);
                                                 }              
                                        }
                                        self.setMaterialsLoaded(false);
                             }  
                             //add uv texture if exist
                             for(var i= 0; i < obj.uvsIndexes.length ; i++){
                                      geometry.faceVertexUvs[0].push([
                                            obj.uvs[obj.uvsIndexes[i].x],
                                            obj.uvs[obj.uvsIndexes[i].y],
                                            obj.uvs[obj.uvsIndexes[i].z]
                                      ]);
                              }
                              var materialFaces = obj.materialFaces;
                              for(var materialName in materialFaces){
                                    var ind = self.getIndexMaterialName(materialName);
                                    for ( var j = 0; j < geometry.faces.length; j ++ ) {
                                            geometry.faces[j].materialIndex = ind;
                                    }    
                              }

                              self.mergeGeometry(new THREE.Mesh(geometry));
                   }
            };
            
                dalleClasse.prototype.parseB3DGeometry = function(instantB3D){
                                    
                 var self = this, obj = instantB3D._cur_obj; 
                 if(obj.uvs !== undefined){        
                             var geometry = new THREE.Geometry();
                                   //add vertices and faces
                                   geometry.vertices   = obj.verts,
                                   geometry.faces      = obj.indices;    //face index
                             //load texture one time at begining
                             if(self.isMaterialsLoaded()) {
                                        var mat = null;
                                        for(var materialName in instantB3D._materials){
                                                 mat = instantB3D._materials[materialName];
                                                 if (mat.colorMap) {
                                                       self.addDalleMaterials(new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe :true})); 
                                                       self.addMaterialsName(materialName);
                                                 }              
                                        }
                                        self.setMaterialsLoaded(false);
                             }  
                             //add uv texture if exist
                             for(var i= 0; i < obj.uvsIndexes.length ; i++){
                                      geometry.faceVertexUvs[0].push([
                                            obj.uvs[obj.uvsIndexes[i].x],
                                            obj.uvs[obj.uvsIndexes[i].y],
                                            obj.uvs[obj.uvsIndexes[i].z]
                                      ]);
                              }
                              var materialFaces = obj.materialFaces;
                              for(var materialName in materialFaces){
                                    var ind = self.getIndexMaterialName(materialName);
                                    for ( var j = 0; j < geometry.faces.length; j ++ ) {
                                            geometry.faces[j].materialIndex = ind;
                                    }    
                              }

                              self.mergeGeometry(new THREE.Mesh(geometry));
                   }
            };
            
           //END OF OBJECT CLASSS
           var  bbox      = { xmin : 1286, 
                               xmax : 1315, //+1
                               ymin : 13715, 
                               ymax : 13734 //+1
                              };
                              
           var LODs = {
                            ORIGIN: 2,
                            SECOND: 4,
                            THIRD:  8,
                            FOURTH: 16
                       };
               
 
                          
             var clipMap = function (lon, lat, levels, scale,textureType) {
                 
                    THREE.Object3D.call( this );

                    this.levels = ( levels !== undefined ) ? levels : 4;
                    this.scale  = ( scale !== undefined ) ? scale : 1;
                    this.list   = [];
                    this.textureType = textureType;

                
                    var nbDallesCote = 2;
                    if (this.textureType == '.jpg') nbDallesCote = 2;
                    for(var i=-nbDallesCote/2 +1 ;i<nbDallesCote/2 +1;++i){
                          for(var j=-nbDallesCote/2 ;j<nbDallesCote/2 ;++j){
                             
                             if (this.textureType == '.jpg'){
                                  this.createTile(lon, lat, i, j, LODs.SECOND);
                             }else{
                                 
                                if(Math.abs(i)<1) this.createTile(lon, lat, i, j, LODs.ORIGIN);
                                else
                                    if(Math.abs(i)<3) this.createTile(lon, lat, i, j, LODs.ORIGIN);
                                else
                                   this.createTile(lon, lat, i, j, LODs.THIRD);
                              
                             }
                          
                          }
                    }
                    
           
                };
                
               
               
                clipMap.prototype = {
                    
                    hide: function(){
                        this.hidden = true;
                        this.meshes.forEach(function(mesh){
                             mesh.visible = false;
                        });
                    },

                    show: function(){
                        this.hidden = false;
                        this.meshes.forEach(function(mesh){
                             mesh.visible = true;
                        });
                    },

                    createTile: function (lon, lat, x, y, lod) {
                         // if(gfxEngine.isMobileEnvironment)
                          var name  = (lon+x).toString() + "-" + (lat+y).toString();
                          var dalle =  new dalleClasse();
                              dalle.dataURL = Cartography3D.dataURL;
                              dalle.setNamePath(name);
                              dalle.setLoDLevel(lod);
                              dalle.setTextureType(this.textureType);
                              this.list.push(dalle);
                              
                    },
                    
                   createTile2: function (lon, lat, x, y, lod) {
                         // if(gfxEngine.isMobileEnvironment)
                          var name  = (lon+x).toString() + "-" + (lat+y).toString();
                          var dalle =  new dalleClasse();
                              dalle.setNamePath(name);
                              dalle.setLoDLevel(lod);
                              dalle.setTextureType(this.textureType);
                              this.list.push(dalle);
                              
                    },
                    
                    getListTiles : function(){
                         return this.list;  
                    }
                    
                };
            
            
            
            
            var Cartography3D = {
                
                            intialized       : false,
                            opacity          : 1,
                            carte3Dactivated : false,
                            grid             : [],
                            dalleSet         : {},
                            listDalles       : [],
                            scale            : 500,
                            zero             : null,
                            paris            : { xmin : bbox.xmin*500, 
                                                 xmax : bbox.xmax*500, 
                                                 ymin : bbox.ymin*500, 
                                                 ymax : bbox.ymax*500 
                                               },
                            videoGamesOn        : false,    
                            dataURL : Config.dataURL.defaultUrl3DBuilding,
                            nbSeeds:5,
                            dateNow : null,
                            timeLapse: null,
                            counterAdded : false,
                            arrTargets : [],
                            iteration        : 0,   // For updating loop
                            light: new THREE.Vector3 (0., -0.5, -1.0).normalize(),
                            gridWeather: [],
                            gridGeometry: null,
                            textureType : 'dds',
                            //grillMap
                            gmap            : null,
                            createGMap      : function(){
                                
                                      var  mat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0.5, side:THREE.DoubleSide});
                                      this.gmap = new THREE.Mesh(
                                              new THREE.PlaneGeometry(10000, 10000),
                                              mat
                                      );

                                      this.gmap.rotation.x = - Math.PI * 0.5;
                                      this.gmap.position.y  = 0;
                                      this.gmap.visible = false;
                                      gfxEngine.addToScene(this.gmap);
                            },
                            projectFrustumOnGMAP : function() {
                                  var viewMatrix           = new THREE.Matrix4(),
                                      viewProjectionMatrix = new THREE.Matrix4(),
                                      frustum = new THREE.Frustum();
                                      viewMatrix.copy( gfxEngine.getCamera().matrixWorldInverse.getInverse(gfxEngine.getCamera().matrixWorld));
                                      viewProjectionMatrix.multiplyMatrices( gfxEngine.getCamera().projectionMatrix, viewMatrix );
                                      frustum.setFromMatrix( viewProjectionMatrix );
                                  
                            },
                            
                            
                            
                            generateGrid:function(){
                
                                var leftBottomCornerGrid = new THREE.Vector3(bbox.xmin*500,0,bbox.ymin*500);
                                this.sceneleftBottomCornerGrid = new THREE.Vector3().subVectors(leftBottomCornerGrid,this.zero);
                                    
                                this.grid = new Array();
                                var nbdallesX = bbox.xmax - bbox.xmin +1;
                                var nbdallesY = bbox.ymax - bbox.ymin +1;
                                //console.log(nbdallesX);
                                //console.log(nbdallesY);
                                for(var i=0; i< nbdallesX; i++)
                                   this.grid[i] = new Array();

                                // on parcourt les lignes...
                                for(var i=0; i<nbdallesX; i++)
                                   // ... et dans chaque ligne, on parcourt les cellules
                                   for(var j=0; j<nbdallesY; j++)
                                      this.grid[i][j] = null;

                                                    /*

                                                     var  bbox      = { xmin : 1286, 
                                                                        xmax : 1315, //+1
                                                                        ymin : 13715, 
                                                                        ymax : 13734 //+1
                                                                };
                                                  */
                            },
                            
                            
                         
                            getDalleXYFromCamDirection: function(){
                                
                                var p = new THREE.Vector3(-9999,0,0);  // To detect no intersection
                                var vector = new THREE.Vector3(0, 0, 1);
                                var projector = new THREE.Projector();
                                var ray = projector.pickingRay(vector, gfxEngine.getCamera());
                                var objArray = ray.intersectObjects([this.gmap]);
                                if (objArray[0]) {
                                    
                                    p = objArray[0].point; // Pos 3D in scene of camera look to gmap plane
                                    if(p.distanceTo(gfxEngine.getCameraPosition()) < 500){
                                        var currentDalleUnderCam = new THREE.Vector3().subVectors(p,this.sceneleftBottomCornerGrid);
                                        var x = Math.floor(currentDalleUnderCam.x / 500);
                                        var z = Math.floor(currentDalleUnderCam.z / 500);
                                        p.x = x; p.z = z;}
                                    else p = new THREE.Vector3(-9999,0,0); 
                                }
                                
                                return p;
                             
                            },
                            
                            
                            checkWhatToLoad: function(){
                                
                                this.iteration++;
                                
                                if(this.iteration%30==0 && this.opacity==1){
                                            
                                   var pLook = this.getDalleXYFromCamDirection();
                                   
                                   if(pLook.x!=-9999 && this.grid[pLook.x][pLook.z] == null){
                                        var lon = bbox.xmin + pLook.x;
                                        var lat = bbox.ymin + pLook.z;
                                        this.loadDallesAtPosition(lon,lat);   
                                   }
   
                               }
                               
                               requestAnimSelectionAlpha(this.checkWhatToLoad.bind(this));
                               
                            },
                            
                            
                            // GAMING FUNCTION
                            checkIfTouchTarget: function(){

                                if(this.videoGamesOn){
                                    var nbTouched = this.nbSeeds - this.arrTargets.length ;
                                    for (var i=0;i<this.arrTargets.length;++i){
                                        var d = gfxEngine.getCameraPosition().distanceTo(this.arrTargets[i].position);
                                        if(d<50) {
                                            
                                         //   var nbTouched = this.nbSeeds - this.arrTargets.length +1;
                                            console.log("touched!");
                                        //    this.setMessageDisplay( nbTouched ,1);
                                            // remove targets sphere in scene
                                            gfxEngine.removeFromScene(this.arrTargets[i]);
                                            this.arrTargets.splice(i, 1);
                                            this.playMP3(nbTouched);
                                            
                                        }
                                    }
                                    
                                    this.setMessageDisplay( nbTouched ,1);
                                    requestAnimSelectionAlpha(this.checkIfTouchTarget.bind(this));
                                }
                                    
                            },
                            
                            
                           
                            
                            
                            playMP3:function(nbTouched){

                                    var mp3name = "172205__fins__jumping.wav";
                                    //mp3name = mp3name || "172205__fins__jumping.wav";  //221568__alaskarobotics__cheering-and-clapping-crowd-1
                                    if(nbTouched >= this.nbSeeds-1) {
                                        mp3name = "clap.mp3";
                                        Utils.snd = new Audio('sounds/'+mp3name);
                                    }
                                    if(!Utils.snd) Utils.snd = new Audio('sounds/'+mp3name); // buffers automatically when created
                                    Utils.snd.play();
                            },
                               
                            removeDalleFromGrid: function(x,y){
                                
                               var pLook = this.getDalleXYFromCamDirection();
                               if(pLook.x!=-9999){
                                    console.log("remove dalle",pLook.x,pLook.z);
                                    console.log(this.grid[pLook.x][pLook.z] );
                                    this.grid[pLook.x][pLook.z].removeFromScene();
                               }
                            },
                                   
                 
                            initCarto3D : function(dataURL){
                                  
                                  this.dataURL = dataURL.url3DBuilding || Config.dataURL.defaultUrl3DBuilding;
                                  this.zero = gfxEngine.getZeroAsVec3D(); 
                                  this.textureType = gfxEngine.isMobileEnvironment() ? '.jpg' : '.dds'; console.log("this.textureType",this.textureType);
                                  _textureType = this.textureType;
                                  //var pos   = Cartography.getCurrentPosition();
                                  var pos = gfxEngine.getCameraPosition();
                                  
                                  this.createGMap();
                                  this.generateGrid();
                                 // this.generateSeeds();
                                  gfxEngine.translateCameraSmoothly(-10001,100,0);   // Translate to 100 meters up
                                  if(this.isDataAvailable(pos.add(this.zero))){ 
                                       this.loadDallesAroundPosition(pos,this.zero);
                                       this.setInitStatus(true);
                                  }    
                            },
                            
                            /*
                            initCarto3D : function(){
                                 this.createQuadTreePlanet();
                            },
                            */
                            setActivatedCarte3D : function(v){
                                  this.carte3Dactivated = v;  
                                //  this.setVisibility(v);
                            },
                            isActivatedCarte3D : function(){
                                  return this.carte3Dactivated;
                            },
                            setInitStatus : function(v){
                                  this.intialized = v;
                            },                 
                            isCartoInitialized : function(){
                                  return this.intialized;
                            },                 
                            createCarteLoD : function(p,zero) {
                                /*
                                  if(this.isDataAvailable(p)){
                                          var lon   = Math.floor(p.x/this.scale),
                                              //lat   = Math.ceil(p.z/this.scale),
                                              lat   = Math.floor(p.z/this.scale),
                                              dalle = null,
                                              listDalles = this.createDalleListAroundPosition(lon, lat);
                                              for(var i = 0; i< listDalles.length;i++){
                                                    var name = listDalles[i];
                                                    if(this.dalleSet[name] === undefined){
                                                              dalle =  new dalleClasse();
                                                              dalle.setDalleZeroPivot(zero);
                                                              dalle.setNamePath(name);
                                                              dalle.load(2);

                                                              //empty texture cache
                                                              this.dalleSet[name] = dalle;
                                                    }
                                             }
                                             console.log('create dalle',Math.floor(p.x/this.scale), Math.ceil(p.z/this.scale)); 
                                  } */
                            },
                            
                            removeAllDalles :function(){
                                     for(var dalleName in this.dalleSet){
                                           this.dalleSet[dalleName].removeFromScene();
                                     }
                            },
                            
                            setVisibility :function(v){

                                   // this.tweenGeneralOpacity();
                                   for(var dalle in this.listDalles){
                                       //console.log("dalle",dalle);
                                        this.listDalles[dalle].setVisible(v);
                                }
                                   
                            },
                            
                            removeDalleAt: function(x,y){
                                
                            },
                            
                            setOpacity :function(v){

                                   this.opacity = v;
                                   for(var dalle in this.listDalles){
                                       //console.log("dalle",dalle);
                                        this.listDalles[dalle].setOpacity(v);
                                   }
                                    
                            },
                            
                            setLightPosition :function(v){

                                   this.opacity = v;
                                   for(var dalle in this.listDalles){
                                       //console.log("dalle",dalle);
                                        this.listDalles[dalle].setLightPosition(v);
                                   }
                                    
                            },
                            
                            // DOWN
                            tweenGeneralOpacity: function(){
                                    
                                //console.log(" tweenGeneralOpacity",this.opacity);
                                if(this.intialized){
                                    var i = this.opacity;
                                    if(i>0){
                                        i -= (1- (i-0.01))*0.04;
                                        if(i<0) {i=0;this.setVisibility(false);}
                                        this.setOpacity(i);
                                    	requestAnimSelectionAlpha(this.tweenGeneralOpacity.bind(this));
                                    }
                               }
                            },
                            
                              // UP
                            tweenGeneralOpacityUP: function(){
                                
                                
                                //console.log(" tweenGeneralOpacity",this.opacity);
                                if(this.intialized){
                                    
                                    var i = this.opacity;
                                    //if(i==0) this.setVisibility(true);
                                    if(i<1){
                                        i += ((i+0.01))*0.04;
                                        if(i>1) i=1;   
                                        this.setOpacity(i);
                                        requestAnimSelectionAlpha(this.tweenGeneralOpacity.bind(this));
                                    }
                               }
                            },
                            
                            getOpacity: function(){
                                return this.opacity;
                            },
                          
                            // with Alex changes
                            loadDallesAtPosition  : function(lon,lat) {
                                    console.log("loadDallesAtPosition",lon,lat);
                              var      dalle = null,
                                       listDalles = this.createDalleListAroundPosition(lon, lat);
                               
                                   for(var i = 0; i< listDalles.length;i++){
                                           var name = listDalles[i];
                                           if(this.dalleSet[name] === undefined){
                                                      
                                                     dalle =  new dalleClasse();
                                                     dalle.dataURL = this.dataURL;
                                                     dalle.textureType = this.textureType;
                                                     dalle.setDalleZeroPivot(gfxEngine.getZeroAsVec3D());
                                                     dalle.setNamePath(name);
                                                     dalle.setLoDLevel(2);
                                                     dalle.load();
                                                     this.grid[lon - bbox.xmin][lat - bbox.ymin] = dalle;   
                                                     //empty texture cache
                                                     this.dalleSet[name] = dalle;
                                                     // add to Global listDalles
                                                     this.listDalles.push(dalle);
                                           }
                                  }
                            },
                           
                           loadDallesAroundPosition  : function(p,zero) {
                              console.log("loadDallesAroundPosition",p);
                                   var lon   = Math.floor(p.x/this.scale),
                                       lat   = Math.floor(p.z/this.scale);
                                   var textureType = '.dds';
                                   if(gfxEngine.isMobileEnvironment()) { textureType = '.jpg';}
                                   var map   = new clipMap(lon, lat, 1, 1, _textureType);
                                   this.listDalles = map.getListTiles();
                                   //console.log("listDalles",this.listDalles);
                                   //console.log(this.grid);
                                   for(var i = 0; i< this.listDalles.length;i++){
                                       if(this.dalleSet[this.listDalles[i].name] === undefined){
                                                var currentDalle = this.listDalles[i];
                                                var currentDalleNameSplit = this.listDalles[i].name.split('-');
                                                var currentDalleXinGrid =  currentDalleNameSplit[0] - bbox.xmin;
                                                var currentDalleYinGrid =  currentDalleNameSplit[1] - bbox.ymin;
                                                //console.log(currentDalleXinGrid,currentDalleYinGrid);
                                                this.grid[currentDalleXinGrid][currentDalleYinGrid] = currentDalle;
                                                this.listDalles[i].setDalleZeroPivot(zero);
                                                if(!this.using3DS) {
                                                    this.listDalles[i].load();
                                                }{
                                                    this.listDalles[i].setLoDLevel(0);  
                                                    this.listDalles[i].load3DS();
                                                }    
                                       }
                                  }
                                  this.checkWhatToLoad();   // Then launch auto update
                                  // call update LOD texture here
                                  // this.updateLODTextureInClipMap(listDalles);
                            },
                            
                            usingLayer : function(layerName) {
                                 if(layerName === "3DBuilding"){
                                     this.using3DS = true;
                                 }else{
                                     this.using3DS = false;
                                 }   
                            },
                            
                            setVideoGamesOn: function(b){
                                this.videoGamesOn = b;
                            },
                            
                            getVideoGamesOn: function(b){
                                return this.videoGamesOn;
                            },
 
 
                            generateSeeds: function(){
                                
                                console.log("generateSeeds");
                               
                                this.arrTargets = [];
                                this.dateNow  = new Date();
                                for(var i = 0; i< this.nbSeeds; ++i){
                                    
                                    var pos = new THREE.Vector3(500*Math.random()-250, 20 + 100*Math.random(), 500*Math.random()-250);
                                    this.drawTarget(pos,25);
                                     // this.arrTargets.push(pos);
                                    //Draw.drawSphereAt(pos,10);
                                }
                                
                                this.videoGamesOn = true;
                                
                                this.checkIfTouchTarget();
                                var helico = new Audio('sounds/'+"93076__cgeffex__helicopter.mp3"); // buffers automatically when created
                                helico.loop = true;
                                helico.play();
                                
                                this.getTemperatureForGrid();
                                
                            },   
                            
                              // Print message on screen(text) remove it depending on value
                            setMessageDisplay: function(text,value){

                                var timeLapse = new Date() -  this.dateNow ;
                                if(text < this.nbSeeds-1) 
                                this.timeLapse = timeLapse;
                                if(!this.counterAdded){
                                    
                                    this.counterAdded = true;
                                    
                                    var element = document.createElement("div");
                                    element.innerHTML = '<font style="font-family: Impact; font-size:8vw; position:absolute; bottom:5%; left: 35%; margin-top: -10vw; margin-left: 0vw; color:white"> '+ text +' '+this.timeLapse+' </font>';
                                    element.id="loading";
                                    var div = document.getElementById("dynamicInput");
                                    div.appendChild(element);          
                                }
                                else{
                                    $('#loading').html('<font style="font-family: Impact; font-size:8vw; position:absolute; bottom:5%; left: 35%; margin-top: -10vw; margin-left: 0vw; color:white"> '+ text+' '+this.timeLapse+' </font>');
                                }
                                
                                // Turn torus
                                 for (var i=0;i<this.arrTargets.length;++i){
                                       
                                     this.arrTargets[i].rotation.y+=0.01;  
                                    
                                }
                                
                            },
                            
                            
                            drawTarget: function(pos,radius){
                             
                                var mesh = new THREE.Mesh( new THREE.TorusGeometry( 20, 3, 16, 100),new THREE.MeshBasicMaterial( { depthTest: false, transparent: true,  opacity: 0.8, color: 0xffffff * Math.random()}));
                                mesh.position = pos;
                                gfxEngine.addToScene(mesh);
                                this.arrTargets.push(mesh);
      
                            },
                         
                            
                            createQuadTreePlanet : function(){
                                
                                var refCamera = gfxEngine.getCamera(), eathRadius = 6376136;
                                
                                 quadSpherePlanet.quadSphere = new THREE.QuadTreeSphere({
                                            workerPath: new THREE.QuadTreeSphereBlobWorker(),
                                            camera: refCamera,
                                            radius: eathRadius, //radius earth
                                            patchSize: 16,
                                            scene: gfxEngine.getScene(),
                                            fov: refCamera.fov,
                                            quadMaterial: quadSpherePlanet.quadMaterial
                                  });
                                  
                                   refCamera.position.z = eathRadius * 4;
		  	           refCamera.lookAt(new THREE.Vector3(0, 0, 0));
                                                                
                                   this.renderQuadTreePlanet();
                            },
                            
                            renderQuadTreePlanet : function () {
                                  quadSpherePlanet.quadSphere.update();
                                  requestAnimationFrame(Cartography3D.renderQuadTreePlanet);
                            }, 
                            
                            
                            
                            // List dalle around position and check if already loaded or not
                            createDalleListAroundPosition : function(lon,lat){
                                  var list = [],
                                         x = [0,1],
                                         y = [0,1];

                                  for(var i = 0 ; i < x.length ; i++)
                                      for(var j= 0; j < y.length; j++){
                                            if (this.grid[lon + x[i] - bbox.xmin][lat +y[j] - bbox.ymin] == null){
                                                this.grid[lon + x[i] - bbox.xmin][lat +y[j] - bbox.ymin] == {};  
                                                var name  = /*"EXPORT_" +*/ (lon+x[i]).toString() + "-" + (lat+y[j]).toString();
                                                list.push(name);
                                            }
                                      }
                                 return list; 
                            },
                            
                         
                            isPointInsideDalle : function(geom, pt){
                                    var p1 = new THREE.Vector2(geom.Xmin,geom.Ymin),
                                        p2 = new THREE.Vector2(geom.Xmin,geom.Ymax),
                                        p3 = new THREE.Vector2(geom.Xmax,geom.Ymax),
                                        p4 = new THREE.Vector2(geom.Xmax,geom.Ymin);
                                    var b1 = pt.isPointInTriange(p1,p2,p3),
                                        b2 = pt.isPointInTriange(p1,p3,p4);
                                    return (b1.x || b2.x);    
                            },
                            isDataAvailable : function(p){
                                    return (p.x > this.paris.xmin)&&(p.x < this.paris.xmax)&&
                                       (p.z > this.paris.ymin)&&(p.z < this.paris.ymax);
                            },
                            update : function() {
                                    if(this.isActivatedCarte3D()){
                                        var zero           = gfxEngine.getZeroAsVec3D(), //pivot for RGE, street view
                                            pos            = Cartography.getCurrentPosition(); //current position when click on geoportail
                                            if(this.isDataAvailable(pos)){
                                                    // this.createNewDalle(pos,zero);
                                                    //this.createCarteLoD(pos,zero);
                                                    //this.createALlDalle(pos,zero);
                                                    this.loadDallesAroundPosition(pos,zero);
                                            }        
                                    }        
                            },
                    
                            processEvent: function(event) {
                                    if (_events[event]) {
                                            _events[event]();
                                    }
                            }
            };
            
             

    return Cartography3D;
});


define ('Navigation',['lib/three', 'GraphicEngine', 'RequestManager', 'Config', 'Utils',  'Panoramic', 'PanoramicProvider', 'Dispatcher','ProjectiveTexturing2','MeshManager', 'Ori', 'Draw', 'Cartography3D', 'lib/when'],
function(THREE, gfxEngine, RequestManager, Config, Utils, Panoramic, PanoramicProvider, Dispatcher, ProjectiveTexturing2, MeshManager,  Ori, Draw, Cartography3D, when)
{

    //***************************** PRIVATE MEMBERS OF MODULE ************************************************/

    //ATTRIBUTES
    var _navigationGroup = null,    //Object grouping the navigation arrows into one 3D object
    _arrows = {},                   //Navigation arrows, containing Arrows.
                                    //Properties identifier are the id of the mesh associated to arrow
    _texArrow = null,
    _texSelectedArrow = null,
    _arrowMaterial = null,
    _arrowGeometry = null,
    _roadPlane = null,              //The road plane used for click & go
    _currentPanoInfo = null,        //Current displayed panoramic infos
    _initialPositionInfos = null,

    _step = null,                   //Wanted distance between each jump from one panoramic to another
    _distThreshold = null,          //Threshold allowed between the wanted step and the available panoramic
    _minAngle = null,               //Min angle (in radian) required between navigation arrow to avoid overlap

    _intersectedArrow = null,       //Current intersected 3D navigation arrow at the mouse position (picking)
    _initialized = false,           //Indicate if this has been initalised
    _lookNextPano = false,
    DEBUG = false,
    _indiceCurrentPosIti = 0,


    _arrZebra = [];  // TEMP will move to PMR
    _barycentre = {x: 0.025244939999999993, y: 0.8656037999999999, z: -0.14644352};
    _count = 0;
    _preIntersectionToLook = null;

   
    var _next = 0;
    var _theta = 200;
 

    //METHODS
    function registerEvents() {

      /*  $(document).mouseup(function(e) {
            if (Navigation.isOnArrow()){
                Navigation.move();
            }
        });
        */
    }


    /*********************************************************************************************************/


    /**
     * Manages the navigation interface enabling user to navigate throw panoramic images and laser cloud
     * @export Navigation
     */
    var Navigation = {

        BATI_DISTANCE : 200,
        ROAD_DISTANCE : 10000,
        ROAD_HEIGHT : -2.5,
        intersectionToLook:{},
        clickAndGoActivated: false,
        autoPlay:false, // For itinerary

        /**
         * Creates a new Navigation object.
         * @author Mathieu Benard IGN
         * @class The navigation user interface, allowing the user to navigate through the 3D world
         * @param {Number} step The wanted distance (in meter) between each "jump"
         * @param {Panoramic} initialPano The first Panoramic loaded
         */
        init: function(initialInfos) {

            _initialPositionInfos = initialInfos;
            _currentPanoInfo = Panoramic.getPanoInfos();
            _distThreshold = 2;
            _minAngle = 0.52;

        },


        // option intersection to look {x1, y1, z1, x2, y2, z2, headingCorrection}
        // Projective Texturing
        moveWithTransition: function(targetPanoInfo, intersectionToLook, surfaceType, altiOption) {

            //console.log('moveWithTransition ************************************');
            if (typeof (targetPanoInfo) !== "undefined") {

            	altiOption = altiOption || 0;

                // TEST IF WE GO FAR FROM INITIALIZATION POINT WE NEED TO CHANGE PIVOT
                if( Math.abs(parseFloat(targetPanoInfo.easting)  - gfxEngine.getZero().x) >20000 ||
                    Math.abs(parseFloat(targetPanoInfo.northing) - gfxEngine.getZero().z) >20000 )
                {
                    gfxEngine.setZero({x:parseFloat(targetPanoInfo.easting),y:parseFloat(targetPanoInfo.altitude),z:parseFloat(targetPanoInfo.northing)});
                    Dispatcher.send("CHANGEPIVOT");
                }

                //  targetPanoInfo.easting = 354881.41; targetPanoInfo.northing = 6689609.56;
                Panoramic.setInfos(targetPanoInfo.url,targetPanoInfo);

                var posWithPivot = new THREE.Vector4(parseFloat(targetPanoInfo.easting)  - gfxEngine.getZeroAsVec3D().x,
                                                     parseFloat(targetPanoInfo.altitude) - gfxEngine.getZeroAsVec3D().y,
                                                     parseFloat(targetPanoInfo.northing) - gfxEngine.getZeroAsVec3D().z,
                                                     1);

             /*************************** Projection ******************************************************************/
                var matRotation = Ori.computeMatOriFromHeadingPitchRoll(
                                        targetPanoInfo.pan_xml_heading_pp,
                                        targetPanoInfo.pan_xml_pitch_pp,
                                        targetPanoInfo.pan_xml_roll_pp
                                    );

                var cameraVersion = this.getCameraVersionFromPanoName(targetPanoInfo.filename);
                if (cameraVersion == 2)
                    _barycentre = Ori.getBarycentreV2();
                else
                    _barycentre = Ori.getBarycentreV1();  // For Paris.. and Terramob (old chantiers)

                _barycentre.applyProjection(matRotation);

                gfxEngine.translateCameraSmoothly(posWithPivot.x + _barycentre.x, posWithPivot.y +_barycentre.y + altiOption, posWithPivot.z+ _barycentre.z);

                var panoWithDirName = this.getDirectoryFromPanoName(targetPanoInfo.filename);
                
                if(ProjectiveTexturing2.isInitiated()) ProjectiveTexturing2.changePanoTextureAfterloading(panoWithDirName,128,50,posWithPivot,matRotation,1);


            /************************************************************************************************************/
            
                if(surfaceType=="SkyToGround"){   // From aerial to terrastrial when clicked on road, needs to look horizontal after transition
                    gfxEngine.setSpeedTurnCam(0.04);
                    gfxEngine.cameraLookHorizontally(); console.log("looook horizontally");
                    
                }else
                    
                if(intersectionToLook != null && surfaceType=="Rectangle"){// Useful for Photogrammetry automatic targeting

                    gfxEngine.cameraLookAtPosition( intersectionToLook.x,
                                                    intersectionToLook.y ,
                                                    intersectionToLook.z,
                                                    posWithPivot.x,
                                                    posWithPivot.y + altiOption,
                                                    posWithPivot.z);
                    gfxEngine.setSpeedTurnCam(0.04);
                }

                Dispatcher.send("MOVE");
            }
            else {
                throw TypeError("Can't move to undefined panoramic");
            }
        },



        // Load a series of panoramic using a 'tab' of positions
        moveWithTransitionTablePositions: function(targetPanoInfo,tab, intersectionToLook, surfaceType) {

            if (typeof (targetPanoInfo) !== "undefined") {

                var posWithPivot = new THREE.Vector4(parseFloat(targetPanoInfo.easting) - _initialPositionInfos['easting'],
                                                     parseFloat(targetPanoInfo.altitude) - _initialPositionInfos['altitude'],
                                                     parseFloat(targetPanoInfo.northing) - _initialPositionInfos['northing'],
                                                     1);

                gfxEngine.translateCameraSmoothly(posWithPivot.x, posWithPivot.y , posWithPivot.z);
              //ProjectiveTexturing.tweenGeneralOpacity();

               Panoramic.setInfos(targetPanoInfo.url,targetPanoInfo);
             /*************************** Projection ******************************************************************/
                // rotation from heading TODO real 3D Rotation with pitch and roll
                var teta = parseFloat(targetPanoInfo.pan_xml_heading_pp)/ 180 * Math.PI;  // Deg to Rad
                var cosTeta = Math.cos(teta);
                var sinTeta = Math.sin(teta);
                var matRotation = new THREE.Matrix4( cosTeta,0,-sinTeta,0,
                                                       0,        1,0,      0,
                                                       sinTeta,0,cosTeta,0,
                                                       0,0,0,1);

                ProjectiveTexturing2.changePanoTextureAfterloading(targetPanoInfo.filename,128,50,posWithPivot,matRotation,0);
             //   ProjectiveTexturing.changePanoTextureAfterloading(targetPanoInfo.filename,1024,75,posWithPivot,matRotation);
            /************************************************************************************************************/

                if(intersectionToLook != null && surfaceType=="Rectangle"){// Useful for Photogrammetry automatic targeting

                    gfxEngine.cameraLookAtPosition( intersectionToLook.x,
                                                    intersectionToLook.y,
                                                    intersectionToLook.z,
                                                    posWithPivot.x,
                                                    posWithPivot.y,
                                                    posWithPivot.z);
                    gfxEngine.setSpeedTurnCam(0.04);
                }


                    setTimeout(function(){Navigation.loadTablePositions(tab);},1000);
                //this.loadTablePositions(tab);

                Dispatcher.send("MOVE");
            }
            else {
                throw TypeError("Can't move to undefined panoramic");
            }
        },


        // Load a series of panoramic using a 'tab' of pano infos. For itineraries
        moveWithTransitionTablePanos: function(targetPanoInfo, tab) {

            if (typeof (targetPanoInfo) !== "undefined") {

                // TEST IF WE GO FAR FROM INITIALIZATION POINT WE NEED TO CHANGE PIVOT
                if( Math.abs(parseFloat(targetPanoInfo.easting)  - gfxEngine.getZero().x) >20000 ||
                    Math.abs(parseFloat(targetPanoInfo.northing) - gfxEngine.getZero().z) >20000 )
                {
                    gfxEngine.setZero({x:parseFloat(targetPanoInfo.easting),y:parseFloat(targetPanoInfo.altitude),z:parseFloat(targetPanoInfo.northing)});
                    Dispatcher.send("CHANGEPIVOT");
                }

               //  targetPanoInfo.easting = 354881.41; targetPanoInfo.northing = 6689609.56;
                Panoramic.setInfos(targetPanoInfo.url,targetPanoInfo);

                var posWithPivot = new THREE.Vector4(parseFloat(targetPanoInfo.easting)  - gfxEngine.getZeroAsVec3D().x,
                                                     parseFloat(targetPanoInfo.altitude) - gfxEngine.getZeroAsVec3D().y,
                                                     parseFloat(targetPanoInfo.northing) - gfxEngine.getZeroAsVec3D().z,
                                                     1);

             /*************************** Projection ******************************************************************/
                // rotation from heading TODO real 3D Rotation with pitch and roll
                var matRotation = Ori.computeMatOriFromHeadingPitchRoll(
                                        targetPanoInfo.pan_xml_heading_pp,
                                        targetPanoInfo.pan_xml_pitch_pp,
                                        targetPanoInfo.pan_xml_roll_pp
                                    );


                var cameraVersion = this.getCameraVersionFromPanoName(targetPanoInfo.filename);
                if (cameraVersion == 2)
                    _barycentre = Ori.getBarycentreV2();
                else
                    _barycentre = Ori.getBarycentreV1();  // For Paris.. and Terramob (old chantiers)

                _barycentre.applyProjection(matRotation);

                gfxEngine.translateCameraSmoothly(posWithPivot.x + _barycentre.x, posWithPivot.y +_barycentre.y, posWithPivot.z+ _barycentre.z);

                var panoWithDirName = this.getDirectoryFromPanoName(targetPanoInfo.filename);
               
                if(ProjectiveTexturing2.isInitiated()) ProjectiveTexturing2.changePanoTextureAfterloading(panoWithDirName,128,50,posWithPivot,matRotation,1);


               if(tab.length>0 && _lookNextPano){ // Then we look at the next pos
                        var intersectionToLook = new THREE.Vector3(tab[0].easting  - gfxEngine.getZeroAsVec3D().x,//_initialPositionInfos['easting'],
                                                                   tab[0].altitude - gfxEngine.getZeroAsVec3D().y,
                                                                   tab[0].northing - gfxEngine.getZeroAsVec3D().z);

                        gfxEngine.cameraLookAtPosition( intersectionToLook.x,
                                                        intersectionToLook.y,
                                                        intersectionToLook.z,
                                                        posWithPivot.x,
                                                        posWithPivot.y,
                                                        posWithPivot.z);
                        gfxEngine.setSpeedTurnCam(0.04);
                 }

                if(this.autoPlay)
                    setTimeout(function(){Navigation.loadTablePanos(tab);},1200);
                //this.loadTablePositions(tab);

                Dispatcher.send("MOVE");
            }
            else {
                throw TypeError("Can't move to undefined panoramic");
            }
        },



        // Load a series of panoramic using a 'tab' of pano infos. For itineraries
        moveWithTransitionTablePanosAERIAL: function(targetPanoInfo, tab) {

            if (typeof (targetPanoInfo) !== "undefined") {

                // TEST IF WE GO FAR FROM INITIALIZATION POINT WE NEED TO CHANGE PIVOT
                if( Math.abs(parseFloat(targetPanoInfo.easting)  - gfxEngine.getZero().x) >20000 ||
                    Math.abs(parseFloat(targetPanoInfo.northing) - gfxEngine.getZero().z) >20000 )
                {
                    gfxEngine.setZero({x:parseFloat(targetPanoInfo.easting),y:parseFloat(targetPanoInfo.altitude),z:parseFloat(targetPanoInfo.northing)});
                    Dispatcher.send("CHANGEPIVOT");
                }

               //  targetPanoInfo.easting = 354881.41; targetPanoInfo.northing = 6689609.56;
                Panoramic.setInfos(targetPanoInfo.url,targetPanoInfo);

                var posWithPivot = new THREE.Vector4(parseFloat(targetPanoInfo.easting)  - gfxEngine.getZeroAsVec3D().x,
                                                     parseFloat(targetPanoInfo.altitude) - gfxEngine.getZeroAsVec3D().y,
                                                     parseFloat(targetPanoInfo.northing) - gfxEngine.getZeroAsVec3D().z,
                                                     1);

             /*************************** Projection ******************************************************************/
                // rotation from heading TODO real 3D Rotation with pitch and roll
                var matRotation = Ori.computeMatOriFromHeadingPitchRoll(
                                        targetPanoInfo.pan_xml_heading_pp,
                                        targetPanoInfo.pan_xml_pitch_pp,
                                        targetPanoInfo.pan_xml_roll_pp
                                    );


                var cameraVersion = this.getCameraVersionFromPanoName(targetPanoInfo.filename);
                if (cameraVersion == 2)
                    _barycentre = Ori.getBarycentreV2();
                else
                    _barycentre = Ori.getBarycentreV1();  // For Paris.. and Terramob (old chantiers)

                _barycentre.applyProjection(matRotation);

                gfxEngine.translateCameraSmoothly(posWithPivot.x + _barycentre.x, posWithPivot.y +_barycentre.y, posWithPivot.z+ _barycentre.z);

                var panoWithDirName = this.getDirectoryFromPanoName(targetPanoInfo.filename);
               
               if(ProjectiveTexturing2.isInitiated()) ProjectiveTexturing2.changePanoTextureAfterloading(panoWithDirName,128,50,posWithPivot,matRotation,1);


               if(tab.length>0 && _lookNextPano){ // Then we look at the next pos
                        var intersectionToLook = new THREE.Vector3(tab[0].easting  - gfxEngine.getZeroAsVec3D().x,//_initialPositionInfos['easting'],
                                                                   tab[0].altitude - gfxEngine.getZeroAsVec3D().y,
                                                                   tab[0].northing - gfxEngine.getZeroAsVec3D().z);

                        gfxEngine.cameraLookAtPosition( intersectionToLook.x,
                                                        intersectionToLook.y,
                                                        intersectionToLook.z,
                                                        posWithPivot.x,
                                                        posWithPivot.y,
                                                        posWithPivot.z);
                        gfxEngine.setSpeedTurnCam(0.04);
                 }

                if(this.autoPlay)
                    setTimeout(function(){Navigation.loadTablePanos(tab);},1200);
                //this.loadTablePositions(tab);

                Dispatcher.send("MOVE");
            }
            else {
                throw TypeError("Can't move to undefined panoramic");
            }
        },




        // Function to move the cam to any 3D position (not a pano)
        // TODO Link to quadtree DTM and his friends
        moveWithTransitionAerial: function(pos, intersectionToLook) {

              // TEST IF WE GO FAR FROM INITIALIZATION POINT WE NEED TO CHANGE PIVOT
                if( Math.abs(pos.x - gfxEngine.getZero().x) > 20000 ||
                    Math.abs(pos.z - gfxEngine.getZero().z) > 20000 )
                {
                    gfxEngine.setZero({x:pos.x,y:pos.y,z:pos.z});
                    Dispatcher.send("CHANGEPIVOT");
                }

                var zero = gfxEngine.getZeroAsVec3D();
                var posWithPivot = new THREE.Vector4(pos.x - zero.x,
                                                     pos.y - zero.y,
                                                     pos.z - zero.z,
                                                     1);

               Panoramic.setPosition(pos);           // TEMP keep the position in Panoramic
               MeshManager.setRoadOn(false);

               if(Math.abs(pos.x - 651463) > 5000)   // Show ortho if not in paris (shown by default)
                   MeshManager.setOrthoPhotoOn(true);



               gfxEngine.translateCameraSmoothly(posWithPivot.x , posWithPivot.y + 200 , posWithPivot.z); // 200 meters up cause map click is at alti 0
               console.log('intersectionToLook',intersectionToLook);
               if(intersectionToLook != null){// Useful for Photogrammetry automatic targeting


                    gfxEngine.cameraLookAtPosition( intersectionToLook.x - zero.x-30,
                                                    intersectionToLook.y - zero.y,
                                                    intersectionToLook.z - zero.z,
                                                    posWithPivot.x,
                                                    posWithPivot.y+200,
                                                    posWithPivot.z);
                    gfxEngine.setSpeedTurnCam(0.01);
                    gfxEngine.setSpeedTransCam(0.03);
                }

                 Dispatcher.send("MOVE");


                 setTimeout(function(){
                    gfxEngine.setSpeedTransCam(0.04);
                    gfxEngine.setSpeedTurnCam(0.1);
                },4500);

        },


        getCameraVersionFromPanoName: function(name){

            var version = 2;
            //if(name.charAt(0) == 'P' || (name.charAt(0) == 'T' && name.charAt(1) == 'e'))
            if(name.substr(0, 6) == 'Paris_' || name.substr(0, 2) == 'Te')
                version = 1;

            return version;
        },

        // @param name ex: Halage-130711_0968-304-00003_0002110.jp2
        // -> 130711/Halage-130711_0968-304-00003_0002110.jp2
        getDirectoryFromPanoName: function(name){

             var dirName = name;
             var datee = name.substr(name.indexOf('-')+1,6);
             dirName = datee + "/" + name;

             return dirName;
         },


        loadPanoFromNameAndLookAtIntersection: function(name,intersectionToLook){

            this.intersectionToLook = intersectionToLook;
            var request = PanoramicProvider.getMetaDataPHPFromNameRequest(name);

             RequestManager.sendCommand(request, function(panoInfo) {

                     panoInfo = panoInfo[0];  // We get the first (and only pano)
                     if(panoInfo)
                         Navigation.moveWithTransition(panoInfo);
                     else Utils.noPanoramic();
                 },true
            );
        },


        // To move fast in same session using the keyboard crosses left and right
        loadNextPanoByName: function(name){

            var request = PanoramicProvider.getMetaDataPHPFromNameRequest(name);
            
            RequestManager.sendCommand(request, function(panoInfo) {

                     panoInfo = panoInfo[0];  // We get the first (and only pano)
                     if(panoInfo)
                         Navigation.moveWithTransition(panoInfo);
                     else Utils.noPanoramic();
                 },true
            );
        },



        // Important function to move to a 3D pos (to the closest pos in pano)
        goToClosestPosition: function(pos, options){

            options = options || {};
            options.distance = options.distance || 50;
            options.alti = options.alti || 0;

           
            PanoramicProvider.getMetaDataFromPos(pos.x, pos.z, options.distance).then(
                        function(response){
                            var panoInfo = response[0];
                            if(panoInfo)
                                Navigation.moveWithTransition(panoInfo,options.intersectionToLook, options.surfaceType, options.alti);
                        }
                    );

        },


        // Load positions continuously, looking for closest pano. For itineraries
        loadTablePositions: function(tabPos){

            if(tabPos.length>0){
                var pos = tabPos.shift();
                var request = "php/getInfosFromPos.php?easting=" + pos.x +
                         "&northing=" + pos.z + "&distneighbours=15";

                RequestManager.sendCommand(request, function(panoInfo) {

                         panoInfo = panoInfo[0];  // We get the first (and only pano)
                         if(panoInfo)
                             Navigation.moveWithTransitionTablePositions(panoInfo,tabPos);
                         else Utils.noPanoramic();
                     },true
                );
            }
        },



        // Load pano continuously using tab of panoInfos
        loadTablePanos: function(tabPanos){

            if(tabPanos.length>0){
                var pano = tabPanos.shift();
                Navigation.moveWithTransitionTablePanos(pano,tabPanos);
            }else{
                setTimeout(function(){     // Itinerary is done so we set back to moderate speed
                    gfxEngine.setSpeedTransCam(0.04);
                    gfxEngine.setSpeedTurnCam(0.1);
                },2000);
                $( "#b1" ).animate({height: "0px"}, 2000);   // Set cinematic effect off
                $( "#b2" ).animate({height: "0px"}, 2000);
            }

        },


        // Load positions continuously, looking for closest pano. For itineraries   FUTUR EN SEINE AERIAL
        // ** Navigate throught trajecto  *****  ******** FES **************************
        loadTablePositions2: function(tabPos){
            var alti = 80;  // alti camera while in scene repere


            if(_indiceCurrentPosIti < tabPos.length){
                 var pos = tabPos[_indiceCurrentPosIti];//tabPos.shift();
                 _indiceCurrentPosIti++;
            	 var posWithPivot = new THREE.Vector4( parseFloat(pos.x) - gfxEngine.getZeroAsVec3D().x,
                                                       alti,//parseFloat(pos.y) - gfxEngine.getZeroAsVec3D().y,
                                                       parseFloat(pos.z) - gfxEngine.getZeroAsVec3D().z,
                                                     1);

              	  gfxEngine.translateCameraSmoothly(posWithPivot.x, posWithPivot.y , posWithPivot.z);


              	if(_indiceCurrentPosIti < tabPos.length -2 ){ // Then we look at the next pos
                        var intersectionToLook = new THREE.Vector3(tabPos[_indiceCurrentPosIti+2].x - gfxEngine.getZeroAsVec3D().x,
                                                                   tabPos[_indiceCurrentPosIti+2].y - gfxEngine.getZeroAsVec3D().y + 50,
                                                                   tabPos[_indiceCurrentPosIti+2].z - gfxEngine.getZeroAsVec3D().z);

/*                        var nextIntersection = new THREE.Vector3(tabPos[_indiceCurrentPosIti+3].x - gfxEngine.getZeroAsVec3D().x,
                                                                   tabPos[_indiceCurrentPosIti+3].y - gfxEngine.getZeroAsVec3D().y + 50,
                                                                   tabPos[_indiceCurrentPosIti+3].z - gfxEngine.getZeroAsVec3D().z);*/
/*                        console.log("============================");
                        console.log(intersectionToLook);
                        console.log(posWithPivot);*/
                        if (intersectionToLook.x !== posWithPivot.x && intersectionToLook.z !== posWithPivot.z) {
	                        gfxEngine.cameraLookAtPosition( intersectionToLook.x,
                                intersectionToLook.y,
                                intersectionToLook.z,
                                posWithPivot.x,
                                posWithPivot.y,
                                posWithPivot.z);
	                        _preIntersectionToLook = intersectionToLook;
/*	                        ++_count;
							console.log(_count);*/
    		//console.log(_currentCSSObjects);

							

/*				    		if ( (_next < _currCSSObjs.length) && (nextDistance < _theta) ) {
			    				console.log("==> displaying ", _next);
			    				_dropObjectManager.displayPOI(_currCSSObjs[_next]);
			    				_next = _next + 1;
				    		}*/
                        } else {
                        	console.log("Conflict, skip this point");
                        }

              	}
              	 if(this.autoPlay)
                    setTimeout(function(){Navigation.loadTablePositions2(tabPos);}, 1200);



            }else{
            	console.log("Done");
            	_count = 0;
                _indiceCurrentPosIti = 0;
	             setTimeout(function(){     // Itinerary is done so we set back to moderate speed
	                    gfxEngine.setSpeedTransCam(0.04);
	                    gfxEngine.setSpeedTurnCam(0.1);
	                },2000);
	             //require('GUI').setViewModeOn(false);
            }
        },



        initialized: function() {
            return _initialized;
        },

        isOnArrow : function() {
            for (var arrow in _arrows) {
                if (_arrows[arrow].intersected) return true;
            }
            return false;
        },

        rotateArrows : function (angle){
            gfxEngine.rotateY(angle, _navigationGroup);
        },

        getDistanceToRoadPlane : function (x,y){
            var intersections = gfxEngine.getIntersected(x, y, [_roadPlane]);

            if (intersections.length !== 0){
                var px = intersections[0].point.x, pz = intersections[0].point.z,
                camX = gfxEngine.getCameraPosition().x, camZ = gfxEngine.getCameraPosition().z;

                return Math.sqrt((camX-px)*(camX-px) + (camZ-pz)*(camZ-pz));
            }
            else {
                return -1;
            }
        },

        moveOnRoad : function (x,y){
            var intersections = gfxEngine.getIntersected(x, y, [_roadPlane]);

            if (intersections.length === 0){
                Utils.noPanoramic();
            }
            else {
                var intersectedPoint = intersections[0].point;
                console.log('intersectedPoint: ',intersectedPoint);
                if( THREE.REVISION === '52' ) { //@TODO : remove for release
                    intersectedPoint.addSelf(gfxEngine.getZeroAsVec3D());
                }
                else {
                    intersectedPoint.add(gfxEngine.getZeroAsVec3D());
                }


                var command = "php/getNeighboursAsText.php?easting=" + intersectedPoint.x +
                    "&northing=" + intersectedPoint.z + "&distneighbours=10";

                RequestManager.sendCommand(command, function (array){
                    if (array.length > 2){
                        var panoInfo = RequestManager.getPanoInfo(array, 1)[0];
                        Navigation.move(panoInfo);
                    }
                    else {
                        Utils.noPanoramic();
                    }
                });
            }
        },

        toggleRoadPlane : function (){ _roadPlane.visible =  !_roadPlane.visible;} //for debug purpose

    };

    return Navigation;

});


/**
 * @module LasReader
 */
define('LasReader',[], function(){
    
    /**
     * Utility function to read a las file provided by an "input" tag and parse it through the LasReader object.
     * @example
     * //we need to have an html input tag somewhere in the document with id="file and type="file"
     *          var onLasLoaded = function(lasObject) {
     *               console.log(lasObject);
     *               console.log(lasObject.getPointData(0));
     *           };
     *           document.getElementById('file').onchange = function() {
     *               var f = this.files[0];
     *               LasReader.lasLoader(this.files[0], onLasLoaded);
     *           };
     *           
     * @todo: need to test how to deal with bigint and also there is bigint in the getPoint function that are not handled yet.
     * @alias module:lasLoader
     * @param {File} lasFileObject the File object provided by the "input" tag.
     * @param {function} onLoadCB the callback to trigger when the load and the parsing is done
     * @param {function} onErrorCB the callback to trigger if the load and the parsing fail.
     * @returns {Void}
     */
    var lasLoader = function(lasFileObject, onLoadCB, onErrorCB) {
        var reader = new FileReader();
        reader.onload = function(result) {
            var lasObj = new LasReader(reader.result);
            onLoadCB(lasObj);
        };
        reader.readAsArrayBuffer(lasFileObject);
    };
    /**
     * @constructor
     * @alias module:LasReader
     * @param {type} lasFileData the raw binary datas provided by a FileReader object.
     */
    var LasReader = function(lasFileData) {
        this.rawData = lasFileData;
        this.header = this.loadHeaderFromFile();
    };
    LasReader.prototype = {
        /**
         * read the las header from the binary datas and populate the good header properties according to the las revision number
         * @returns {Number} the offset in bytes from the start of the binary stream after reading the header.
         */
        loadHeaderFromFile : function() {
            var rawData = this.rawData;
            var getHeaderRoot = function() {
                var dv = new DataView(rawData, 0, 90);
                header.sourceId = dv.getUint16(4);
                header.globalEncoding = dv.getUint16(6); //2
                header.id_guid_data1 = dv.getUint32(8), //4
                header.id_guid_data2 = dv.getUint16(12), //2
                header.id_guid_data3 = dv.getUint16(14), //2
                //header.id_guid_data4  : dv.getUint32(16), //8
                header.versionMajor = dv.getUint8(24), //1
                header.versionMinor = dv.getUint8(25), //1
                header.systemId = ""; //32
                header.generatingSoftware = ""; //32
                return 90;
            };
            
            
            var getHeaderDateRevision_1_0 = function(offset) {
                var dv = new DataView(rawData, offset, 4);
                header.flightDateJulian = dv.getUint16(0, true); //2
                header.year = dv.getUint16(2, true); //2
                return offset + 4;
            };
            var getHeaderDateRevision_1_1to4 = function(offset) {
                var dv2 = new DataView(rawData, offset, 4);
                header.fileCreationDayOfYear = dv2.getUint16(0, true); //2
                header.fileCreationYear = dv2.getUint16(2, true); //2
                return offset + 4;
            };
            var getBasicPointDataInfo = function(offset) {
                var dv = new DataView(rawData, offset, 13);
                header.headerSize             = dv.getUint16(0, true); //2
                header.offsetToPointData      = dv.getUint32(2, true); //4
                header.numberOfVLR            = dv.getUint32(6, true); //4
                header.pointDataRecordFormat  = dv.getUint8(10, true);  //1
                header.pointDataRecordLength  = dv.getUint16(11, true); //2
                return offset + 13;
            };
                     
            var getLegacyPointNumbers = function(offset, old) {
                var dv = new DataView(rawData, offset, 24);
                var numpoint = dv.getUint32(0, true); //4
                var numpointReturn = [];
                var loffset = 4;
                for (var i=0; i< 5; i++) {
                    numpointReturn.push(dv.getUint32(loffset, true)); //4
                    loffset += 4;
                }
                if (old) {
                    header.numberOfPointRecords = numpoint;
                    header.numberOfPointsByReturn = numpointReturn;
                } else {
                    header.legacyNumberOfPointRecords = numpoint;
                    header.legacyNumberOfPointsByReturn = numpointReturn;
                }
                return offset + loffset;
            }
               
            var getBBoxInformations = function(offset) {
                var dv = new DataView(rawData, offset, 96);

                header.XScaleFactor    = dv.getFloat64(0, true); //8
                header.YScaleFactor    = dv.getFloat64(8, true); //8
                header.ZScaleFactor    = dv.getFloat64(16, true); //8
                header.XOffset         = dv.getFloat64(24, true); //8
                header.YOffset         = dv.getFloat64(32, true); //8
                header.ZOffset         = dv.getFloat64(40, true); //8
                header.maxX            = dv.getFloat64(48, true); //8
                header.minX            = dv.getFloat64(56, true); //8
                header.maxY            = dv.getFloat64(64, true); //8
                header.minY            = dv.getFloat64(72, true); //8
                header.maxZ            = dv.getFloat64(80, true); //8
                header.minZ            = dv.getFloat64(88, true); //8
                return offset + 96;
            };
                     
            /**
             * load the waveform data part of the header starting at the provided offset
             * @param {number} offset the offset in bytes the reader will start at
             * @return {number} the new position of the reading head.
             */
            var getHeaderWaveFormData = function(offset) {
                var dv = new DataView(rawData, offset, 4 + (15*8));
                header.startOfEVLR                      = dv.getUint32(offset+8, true); //4
                header.numberOfPointByRecord            = [];
                var loffset = 4;
                for (var i=0; i< 15; i++) {
                    header.numberOfPointByRecord.push(dv.getUint32(loffset, true)* Math.pow(2,32) + dv.getUint32(loffset+4, true)); //8
                    loffset += 8;
                };
                return offset + loffset;
           };
           
           // -------------- start building up things together ------------------
            var getHeaderRevion1_0 = function(offset) {
                offset = getHeaderDateRevision_1_0(offset);
                offset = getBasicPointDataInfo(offset);
                offset = getLegacyPointNumbers(offset);
                offset = getBBoxInformations(offset);
                return offset;
            };
            
            var getHeaderRevision1_1= function(offset) {
                offset = getHeaderDateRevision_1_1to4(offset); //different from 1.0
                offset = getBasicPointDataInfo(offset);
                offset = getLegacyPointNumbers(offset, true);
                offset = getBBoxInformations(offset);
                return offset;                
            };
            var getHeaderRevision1_2= function(offset) {
                offset = getHeaderRevision1_1(offset);
            };
            var getHeaderRevision1_3= function(offset) {
                offset = getHeaderRevision1_2(offset);
                var dv = new DataView(rawData, offset, 8);
                header.startOfWaveFormDataPacketRecord  = dv.getUint32(offset, true)* Math.pow(2,32) + dv.getUint32(offset+4, true); //8
                return offset + 8;
            };
            var getHeaderRevision1_4= function(offset) {
                offset = getHeaderDateRevision_1_1to4(offset); //different from 1.0
                offset = getBasicPointDataInfo(offset);
                offset = getLegacyPointNumbers(offset, false);
                offset = getBBoxInformations(offset);
                var dv = new DataView(rawData, offset, 8);
                header.startOfWaveFormDataPacketRecord  = dv.getUint32(offset, true)* Math.pow(2,32) + dv.getUint32(offset+4, true);
                offset += 8;
                offset = getHeaderWaveFormData(offset);
                return offset;
            };            
            /* -------------- let's go ----------------- */
            var header = {};
            var offset = getHeaderRoot();
            
            if (header.versionMajor === 1){
                switch(header.versionMinor) {
                    case 0:
                        offset = getHeaderRevision1_0(offset);
                        break;
                    case 1: 
                        offset = getHeaderRevision1_1(offset);
                        break;
                    case 2: 
                        offset = getHeaderRevision1_2(offset);
                        break;

                    case 3: 
                        offset = getHeaderRevision1_3(offset);
                        break;

                    case 4: 
                        offset = getHeaderRevision1_4(offset);    
                        break;

                }
            }
            return header;
        },
        getRawPointData : function(pointNumber) {
            var pointPosition = this.header.offsetToPointData + (pointNumber * this.header.pointDataRecordLength);            
            var pointData = {}
            pointData.X = pointPosition;
            pointData.Y = pointPosition+4;
            pointData.Z = pointPosition+8;
            pointData.intensity = pointPosition+12;
            return pointData;
        },
        
        /**
         * get the datas associated with the point number
         * @param {number} pointNumber id of the point to be retrieved.
         * @returns {object} an object containing the datas for this point.
         */
        getPointData : function(pointNumber) {
            var pointPosition = this.header.offsetToPointData + (pointNumber * this.header.pointDataRecordLength);

            var b1 = 1;    //00000001
            var b2 = 2;    //00000010
            var b3 = 4;    //00000100
            var b4 = 8;    //00001000
            var b5 = 16    //00010000
            var b6 = 32;   //00100000
            var b7 = 64;   //01000000
            var b8 = 128;  //10000000

            var pdv = new DataView(this.rawData, pointPosition, this.header.pointDataRecordLength)
            var pointData = {}
            var getDataForPointFormat0 = function () {
                pointData.X                = pdv.getInt32(0, true);   // 4
                pointData.Y                = pdv.getInt32(4, true);   // 4
                pointData.Z                = pdv.getInt32(8, true);   // 4
                pointData.intensity        = pdv.getUint16(12, true); // 2 -- to be normalized to 65535 before use
                var packedBit              = pdv.getUint8(14, true);  // 1
                pointData.returnNumber     = packedBit & (b1|b2|b3);  //3bits
                pointData.numberOfReturns  = packedBit >> 3 & (b1|b2|b3) // 3bits
                pointData.scanDirectionFlag= packedBit >> 6 & (b1); // 1 bit
                pointData.edgeOfFlightLine = packedBit >> 7 & (b1); //1 bit
                pointData.classification   = pdv.getUint8(15, true);  //1
                pointData.scanAngleRank    = pdv.getInt8(16, true);   //1
                pointData.userData         = pdv.getUint8(17, true);  //1
                pointData.pointSourceID    = pdv.getUint16(18, true); //2
                return 20;
            }
            var getDataForPointFormat1 = function() {
                var offset = getDataForPointFormat0()
                pointData.gpsTime          = pdv.getFloat64(offset, true); //8
                return offset + 8;
            }

            function getRVB(offset) {
                pointData.red              = pdv.getUint16(offset  , true);  //2
                pointData.green            = pdv.getUint16(offset+2, true);  //2
                pointData.blue             = pdv.getUint16(offset+4, true);  //2
                return offset + 6;
            }

            var getDataForPointFormat2 = function() {
                var offset = getDataForPointFormat0();
                offset = getRVB(offset);
                return offset;
            }
            var getDataForPointFormat3 = function() {
                var offset = getDataForPointFormat0();
                pointData.gpsTime          = pdv.getFloat64(offset, true); //8
                offset = getRVB(offset+8);
                return offset;
            }

            function getWaveFormPacketData(offset) {
                pointData.wavePacketDescriptorIdx      = pdv.getInt8(offset, true);      //1
                pointData.byteOffsetToWaveFormData1    = pdv.getUint32(offset + 1, true);   //4 Achtung this is an int64 !
                pointData.byteOffsetToWaveFormData2    = pdv.getUint32(offset + 5, true);   //4 not provided in dataview
                pointData.waveFormPacketSizeInBytes    = pdv.getUint32(offset + 9, true);   //4
                pointData.returnPointWaveformLocation  = pdv.getFloat32(offset + 13, true); //4
                pointData.Xt                           = pdv.getFloat32(offset + 17, true); //4
                pointData.Yt                           = pdv.getFloat32(offset + 21, true); //4
                pointData.Zt                           = pdv.getFloat32(offset + 25, true); //4
                return offset + 29;
            }
            var getDataForPointFormat4 = function() {
                var offset = getDataForPointFormat1();
                offset = getWaveFormPacketData(offset);
                return offset;
            }

            var getDataForPointFormat5 = function() {
                var offset = getDataForPointFormat3();
                offset = getWaveFormPacketData(offset);
                return offset;
            }

            var getDataForPointFormat6 = function () {
                pointData.X                = pdv.getInt32(0, true);   // 4
                pointData.Y                = pdv.getInt32(4, true);   // 4
                pointData.Z                = pdv.getInt32(8, true);   // 4
                pointData.intensity        = pdv.getUint16(12, true); // 2 -- to be normalized to 65535 before use
                var packedBit1              = pdv.getUint8(14, true);  // 1 
                pointData.returnNumber     = packedBit1 & (b1|b2|b3|b4);  //4bits <!--
                pointData.numberOfReturns  = packedBit1 >> 4 & (b1|b2|b3|b4) //4bits <!--
                var packedBit2              = pdv.getUint8(15, true);  // 1 <!--
                pointData.classificationFlags = packedBit2 & (b1|b2|b3|b4);  //4bits <!--
                pointData.scannerChannel   = packedBit2 >> 4 & (b1|b2); //2bits <!--
                pointData.scanDirectionFlag= packedBit2 >> 6 & (b1); // 1 bit
                pointData.edgeOfFlightLine = packedBit2 >> 7 & (b1); //1 bit
                pointData.classification   = pdv.getUint8(16, true);  //1
                pointData.userData         = pdv.getUint8(17, true);  //1
                pointData.scanAngleRank    = pdv.getInt16(18, true);  //2 <!-- 
                pointData.pointSourceID    = pdv.getUint16(20, true); //2
                pointData.gpsTime          = pdv.getFloat64(22, true); //8
                return 30;
            }

            var getDataForPointFormat7 = function() {
                var offset = getDataForPointFormat6();
                offset = getRVB(offset);
                return offset;
            }
            var getDataForPointFormat8 = function() {
                var offset = getDataForPointFormat7();
                pointData.nir          = pdv.getUint16(offset, true); //2
                return offset +2;
            }
            var getDataForPointFormat9 = function() {
                var offset = getDataForPointFormat6();
                offset = getWaveFormPacketData(offset);
                return offset;
            }
            var getDataForPointFormat10 = function() {
                var offset = getDataForPointFormat8();
                offset = getWaveFormPacketData(offset);
                return offset;
            }


            var pointDataFormat = {
                0: getDataForPointFormat0,
                1: getDataForPointFormat1,
                2: getDataForPointFormat2,
                3: getDataForPointFormat3,
                4: getDataForPointFormat4,
                5: getDataForPointFormat5,
                6: getDataForPointFormat6,
                7: getDataForPointFormat7,
                8: getDataForPointFormat8,
                9: getDataForPointFormat9,
                10: getDataForPointFormat10,
            }
            pointDataFormat[this.header.pointDataRecordFormat]();
            return pointData;
        }
    };
    return {
        LasReader:LasReader,
        lasLoader:lasLoader
        };
});
/**
 * Creates a new Laser object
 * @author alexandre devaux IGN
 * @class Manages laser data
 * @require THREE.JS
 */
define('LaserCloud',['jquery', 'GraphicEngine', 'lib/three', 'Shader', 'Panoramic', 'Dispatcher', 'Cartography','Draw',  'CVML','ProjectiveTexturing2','Utils', 'LasReader', 'Config'],
    function($, gfxEngine, THREE, Shader, Panoramic, Dispatcher, Cartography, Draw, CVML, ProjectiveTexturing2, Utils, LasReader, Config) {

    var _particleSystem = null,
        _particleSystemPicking = null,
        _geometryParticleSystem = new THREE.Geometry(),
        _geometryParticleSystemPicking = new THREE.Geometry(), // sused for the texture rendering for picking
        //_colors = [],
        _colorsPicking = [],
        _dataURL = null,
        _localURL = false,
        _sceneRTT, // Maybe displace to GE
        _rtTexture = null, //new THREE.WebGLRenderTarget( 1000,800),//gfxEngine.getWinWith(), gfxEngine.getWinHeight(),{ minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat }), // Maybe displace to GE
        _zeroEasting, _zeroNorthing, _zeroAltitude, // initialInfo.easting ...
        _shaderLoader = null,
        _indiceTimeLaser = 1., // shader uniform variable to animate point positions 
        _reverseMotion = false,
        _speedMovment = 0.07, // 0.07,
        _snowOn = false,
        _nbPointsBuffer = 1*1048576,// 1024*1024 //500000,
        _bufferGeometry = null,
        _geometryLidar = null,
        _currentNbPointsInBuffer = 0,
        _indiceStartTriangulate = 0,
        _localMode = false,   // at true when dropping large original PLY, to prevent loading other bin from server when moving
        _dataView = null,     // used for local PLY, to keep original file
        _filename = "",       // Filename of local PLY
        _nbLabel =0,          // Nb objects, means when parsing Input ply, max of all label id
        _filterFacadeAndGround = false, // Bool if the box has to filter ground and facade id
        _idSurface = 200000000,
        _currentClassEditing = 0,    // ClassIdCurrentlyEditing        
        _sizeHeader = 0,
        _shaderAttributes,
        _shaderUniforms,
        _movementLocked = 1,  // 1 means activate no translation for faster rendering
        _shaderMatLaserCloud,
        _pickingGeometry,
        _nbTime = 1.,
        _indice_time_laser_tab = [],//new Float32Array(40);
        _nbIndiceMax = 160,
        _pivotNantes = {x:352000,y:0,z:6688000},
        _pivotNantesHalage = {x:339000,y:0,z:6713000},
        _pivotParis6 = {x:649000,y:0,z:6840000},
        _pivotParis2014Louvre = {x:650000,y:0,z:6860000},
        _pivotCasqy = {x:624000,y:0,z:6850000},
        _pivotToulouse = {x:570000,y:0,z:6275000},
        _pivotAurillac = {x:655000,y:0,z:6430000},
        _pivotChampigny = {x:664000,y:-43.7,z:6850000},
        _currentLaserPivot = {},
        _nbClassLidar = 0,
        _zero = null, // Translation substracting the init position to all coords
        _notLoaded= true,
        _newBufferPosition= null,
        _globalOffset = 0,  //TEMP
        _globalOffsetByte = 0,
        _gl = null;
        // EVENT MANAGEMENT
        //*************************************
           
        
    _events = {
        MOVE: function() {
            _notLoaded = true;
            if(_particleSystem.visible && !_localMode)
                LaserCloud.launchLaserAroundCurrentTime(10, 11);
                
                //LaserCloud.showUserMeasures();
        },
        CHANGEPIVOT: function() {
            if(LaserCloud.initiated)
                 LaserCloud.emptyBuffer();
        }
    };



    // SHIM
    // @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window.requestAnimFrame2 = (function() {
        return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(callback, element) {
                    window.setTimeout(callback, 1000 / 60);
                };
    })();


    var LaserCloud = {
        
        initiated: false,
        laserCloudMaster: new THREE.Object3D(), //null;
        nbPointsLoaded: 0,
        indiceLaserFileLoaded: 0,
        indicePacketInBuffer:0,  // Indicate the number of packet in buffer
        tabLaserFilesToLoad: [],
        nbSecondsToLoad: 0,
        nbPointsInBB: 0,
        lengthAPoint: 0,
        // Added properties for Bounding Box
        ptA2: null, ptB2: null, ptC2: null, ptD2: null, point2: null,
        lengthAB: 0, lengthAC: 0, lengthAPoint:0,
                //nbClassLidar: 1000.,  // When selected cause we create class from packet loaded number 
        nbPointsInBB: 0,
        animateOn:false,
        //add atribute to buttons
        btnSwitchPoint : false,
        btnSwitchLine  : false,
        btnSwitchVolume : false,
        computeNormalOn : false,
        annotationOn : false,
            
            
        init: function(zero,dataURL) {

            _zero = zero;
            _dataURL = dataURL.urlPointCloud || Config.dataURL.defaultUrlPointCloud;
            _localURL = _dataURL.indexOf("www") < 0;
           // if(nbPointsBuffer) _nbPointsBuffer = nbPointsBuffer; 
            _rtTexture = new THREE.WebGLRenderTarget(gfxEngine.getWinWith(), gfxEngine.getWinHeight());
            this.initiated = true;
            this.initializeBufferGeometry();
            
            //Measure.init();
            
            Dispatcher.register("MOVE", LaserCloud);
            Dispatcher.register("CHANGEPIVOT",LaserCloud);
            _gl = gfxEngine.getRenderer().getContext();
            
            // when resizing the window for picking!
            $(window).resize(function() {
                _rtTexture.width = window.innerWidth;
                _rtTexture.height = window.innerHeight;
            });
            
        },
        //***********************************************************************
        // New way of loading laser, alpha.
        // One pre-allocated fixed size buffer 

        initializeBufferGeometry: function() {

             for(var i=0;i<_nbIndiceMax ;++i){
              _indice_time_laser_tab[i] = 0.;
             }
            this.createShader();

           
            _currentNbPointsInBuffer = 0;
            _bufferGeometry = new THREE.BufferGeometry();
            _bufferGeometry.dynamic = true;

            _bufferGeometry.attributes = {
                position: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3), // ! not float64 to gpu
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                },
                color: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3),
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                },
                displacement: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3),
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                },
                uniqueid: {
                    itemSize: 1,
                    array: new Float32Array(_nbPointsBuffer),
                    dynamic: true
                },
                classe: {
                    itemSize: 1,
                    array: new Float32Array(_nbPointsBuffer),
                    dynamic: true
                }
            };
       
        
            //*****Picking **********************
            _geometryParticleSystemPicking = new THREE.Geometry();
            _geometryParticleSystemPicking.vertices = new Array(_nbPointsBuffer);
            _geometryParticleSystemPicking.dynamic = true;


            this.initializeBufferValues();

            _particleSystem = new THREE.ParticleSystem(
                    _bufferGeometry,
                    _shaderMatLaserCloud
                    );

            //*****Picking **********************
            _geometryParticleSystemPicking.colors = _colorsPicking;
            var pMaterial = new THREE.ParticleBasicMaterial({size: 0.10, vertexColors: true, depthTest: false});  // map:sprite
            // create the particle system used to get the id (3D pos). Rendered to texture, not to screen.
            _particleSystemPicking = new THREE.ParticleSystem(_geometryParticleSystemPicking, pMaterial);
            // Modified RTT. Texture rendering ac le Color ID for Picking 3D
            _sceneRTT = new THREE.Scene();
            _sceneRTT.add(_particleSystemPicking);
            
            //gfxEngine.addToScene(_particleSystemPicking);
           this.laserCloudMaster.add(_particleSystem);
        },
        
        createShader: function() {

            _shaderAttributes = {
                displacement: {type: 'v3', value: []},
                color: {type: 'v3', value: []},
                uniqueid: {type: 'f', value: []}
            };

            _shaderUniforms = {
                indice_time_laser: {type: 'f', value: _indiceTimeLaser},
                currentidwork: {type: 'f', value: 1000.},
                point_size: {type: 'f', value: 1.},
                alpha: {type: 'f', value: 0.6}, //0.6
                indice_time_laser_tab:{type: 'fv1', value: _indice_time_laser_tab},
                movementLocked: {type:'i', value:_movementLocked},
                texturePoint: {type: 't',
                   value: null//THREE.ImageUtils.loadTexture("images/textures/smoke_particle.png")  
                }
            };

            // create the shader material for the laser particle system
            // !!!!!  VERY IMPORTANT  Depthest : false to have a nice opacity in every direction
            // For BufferGeometry now we need to set everything here. Like transparent 
            _shaderMatLaserCloud = new THREE.ShaderMaterial({
                uniforms: _shaderUniforms,
                attributes: _shaderAttributes,
                vertexShader: Shader.shaderLaserVS.join("\n"),//Shader.shaders['shaderLaser.vs'],
                fragmentShader: Shader.shaderLaserFS.join("\n"),//Shader.shaders['shaderLaser.fs'],
                vertexColors: THREE.VertexColors,
                depthTest: false,
                transparent: true
            });

        },
        
        initializeBufferValues: function() {

            var values_color = _bufferGeometry.attributes.color.array;
            var positions = _bufferGeometry.attributes.position.array;
            var displacements = _bufferGeometry.attributes.displacement.array;
            var uniqueids = _bufferGeometry.attributes.uniqueid.array;
            var classes = _bufferGeometry.attributes.classe.array;


            var color2 = new THREE.Color();
            color2.setHSL(0.2, 0.5, 0.7);
            // we set default properties: position, color, displacement
            var radius = 10;

            for (n = 0; n < _nbPointsBuffer; ++n) {

                positions[ n * 3 + 0 ] = 15000;  // Camera far: 10000
                positions[ n * 3 + 1 ] = 15000;  // so out of frustum
                positions[ n * 3 + 2 ] = 15000;

                displacements[ n * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
                if(_snowOn) displacements[ n * 3 + 1 ] = Math.random()* radius * 10;
                    else
                    displacements[ n * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
                displacements[ n * 3 + 2 ] = (Math.random() * 2 - 1) * radius;

                values_color[ n * 3 + 0 ] = color2.r;
                values_color[ n * 3 + 1 ] = color2.g;
                values_color[ n * 3 + 2 ] = color2.b;

                uniqueids[ n + 0 ] = this.indiceLaserFileLoaded;
                classes[ n + 0 ] = 0;
                //Picking*****
                _colorsPicking[n] = 0;
                _geometryParticleSystemPicking.vertices[n] = new THREE.Vector3(0, 0, 0);
            }
        },
      
      
       // Loader for binary file with no Header. All attributes have to be the same data type
       // pivot is the value we substract to all coordinates
       // Work for xyz, xyzi, xyzikzfzefzfz... 
       // in itowns file sys, each point has a x,y,z,i,c (3dposition,intensity and a class)
       // ex xyzi double -> nbAttributes:4, nbBitsPerAttribute:64
      addPointsToBufferGeneric: function(buffer,nbAttributes,nbBitsPerAttribute,pivot){
          
         var byteArray; 
         switch(nbBitsPerAttribute){
             
             case 64: byteArray = new Float64Array(buffer); break;
             case 32: byteArray = new Float32Array(buffer); break;
             case 16: byteArray = new Int16Array(buffer);   break;
         }
         
	 var positions =    _bufferGeometry.attributes.position.array;
         var values_color = _bufferGeometry.attributes.color.array;
         var uniqueids =    _bufferGeometry.attributes.uniqueid.array;
         
         var color2 = new THREE.Color();
         var pX,pY,pZ,pI,ind;         

         if( (_currentNbPointsInBuffer + byteArray.length * 8/nbBitsPerAttribute) > _nbPointsBuffer ){// + byteArray.length/(4*nbBitsPerAttributes) ))
            _currentNbPointsInBuffer   = 0;   // We add new points remplacing the oldest in buffer
            this.indicePacketInBuffer  = 0;
        }
        
         // NEW TECH, we create a new small buffer that we will use to update the global geometry buffer
         var nbPoints = byteArray.length / nbAttributes;
         for(var p = 0; p < byteArray.length- nbAttributes ; p=p+nbAttributes){ // P+4 cause x,y,z,i in bin

                    pX = byteArray[p]   - pivot.x,
                    pY = byteArray[p+1] - pivot.y ,// Decalage laser/cam
                    pZ = byteArray[p+2] - pivot.z;  
                    // pI = (byteArray[p+3] +25) / 35; Nice lut
                    if(nbAttributes==4) pI = (byteArray[p+3] +25) / 25; else if(nbAttributes==6) pI = byteArray[p+4]/20; else pI= 0.6 + pY/80;
              //if(p<5) console.log(pivot.x);
                    ind = _currentNbPointsInBuffer * 3;
    
                    positions[ ind + 0 ] = pX;
                    positions[ ind + 1 ] = pY;
                    positions[ ind + 2 ] = pZ;
          
                    color2.setHSL(pI,0.5,0.8);
                    values_color[ ind + 0] = color2.r;
                    values_color[ ind + 1] = color2.g;
                    values_color[ ind + 2] = color2.b;

                    uniqueids[ _currentNbPointsInBuffer ] = this.indicePacketInBuffer;

                    // Then for the picking ***********************
                    var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                    var nbZerosMissing = 6 - colorHexFromInt.length;
                    for (var i=0; i< nbZerosMissing; ++i){ colorHexFromInt = '0' + colorHexFromInt;}
                    var colorHex = '#'+colorHexFromInt;
                    _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                    _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = new THREE.Vector3(pX, pY, pZ);
                  
                    _currentNbPointsInBuffer++;

         }
        //         .._newBufferPosition = new Float32Array(nbPoints * 3);
         // console.log("a",a);
          _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;
          _indice_time_laser_tab[this.indicePacketInBuffer] = 0.15;

    //      if (this.indiceLaserFileLoaded %8 ==0 || this.indiceLaserFileLoaded >= this.tabLaserFilesToLoad.length -1) this.updateLaserAttributes(); 
 //       this.updateLaserAttributes(); 
          this.setLockMovement(0);
       
          this.updateLaserAttributesSmartly(nbPoints);//offset); 

          _indiceTimeLaser = 0.5;                    
          if(!this.animateOn){this.animateOn = true; this.animatePoints2(); /*console.log('thisanimate');*/}  // First file
                                                                                    // start animation function
          this.indiceLaserFileLoaded++;// console.log(_currentNbPointsInBuffer);
          this.indicePacketInBuffer++;
          // Load the next file in the list if not last (seems faster than parallel load)
          if(this.indiceLaserFileLoaded < this.tabLaserFilesToLoad.length )
             this.readLaserPointsFileFromItownsGeneric(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded],nbBitsPerAttribute,pivot);
             else{
                setTimeout(function() {
                  LaserCloud.setLockMovement(1);}
                , 800);
              }
           
      },


       // Loader for binary file with no Header. All attributes have to be the same data type
       // pivot is the value we substract to all coordinates
       // Work for xyz, xyzi, xyzikzfzefzfz... 
       // in itowns file sys, each point has a x,y,z,i,c (3dposition,intensity and a class)
       // ex xyzi double -> nbAttributes:4, nbBitsPerAttribute:64
      addPointsToBufferGenericMesh: function(buffer,nbAttributes,nbBitsPerAttribute,pivot){
          
         var byteArray; 
         switch(nbBitsPerAttribute){
             
             case 64: byteArray = new Float64Array(buffer); break;
             case 32: byteArray = new Float32Array(buffer); break;
             case 16: byteArray = new Int16Array(buffer);   break;
         }
         
	 var positions =    _bufferGeometry.attributes.position.array;
         var values_color = _bufferGeometry.attributes.color.array;
         var uniqueids =    _bufferGeometry.attributes.uniqueid.array;
         
         var color2 = new THREE.Color();
         var pX,pY,pZ,pI,ind;         

                 if(_indiceStartTriangulate == 0) _indiceStartTriangulate = _currentNbPointsInBuffer;
         if( (_currentNbPointsInBuffer + byteArray.length * 8/nbBitsPerAttribute) > _nbPointsBuffer ){// + byteArray.length/(4*nbBitsPerAttributes) ))
            _currentNbPointsInBuffer   = 0;   // We add new points remplacing the oldest in buffer
            this.indicePacketInBuffer  = 0;
        }
        
         // NEW TECH, we create a new small buffer that we will use to update the global geometry buffer
         var nbPoints = byteArray.length / nbAttributes;
         for(var p = 0; p < byteArray.length- nbAttributes ; p=p+nbAttributes){ // P+4 cause x,y,z,i in bin

                    pX = byteArray[p]   - pivot.x,
                    pY = byteArray[p+1] - pivot.y ,// Decalage laser/cam
                    pZ = byteArray[p+2] - pivot.z;  
                    if(nbAttributes>3) pI = (byteArray[p+3] +25) / 35; else pI= 0.6 + pY/80;

                    ind = _currentNbPointsInBuffer * 3;
    
                    positions[ ind + 0 ] = pX;
                    positions[ ind + 1 ] = pY;
                    positions[ ind + 2 ] = pZ;
          
                    color2.setHSL(pI,0.5,0.8);
                    values_color[ ind + 0] = color2.r;
                    values_color[ ind + 1] = color2.g;
                    values_color[ ind + 2] = color2.b;

                    uniqueids[ _currentNbPointsInBuffer ] = this.indicePacketInBuffer;

                    // Then for the picking ***********************
                    var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                    var nbZerosMissing = 6 - colorHexFromInt.length;
                    for (var i=0; i< nbZerosMissing; ++i){ colorHexFromInt = '0' + colorHexFromInt;}
                    var colorHex = '#'+colorHexFromInt;
                    _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                    _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = new THREE.Vector3(pX, pY, pZ);
                  
                    _currentNbPointsInBuffer++;

         }
        //         .._newBufferPosition = new Float32Array(nbPoints * 3);
         // console.log("a",a);
          _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;
          _indice_time_laser_tab[this.indicePacketInBuffer] = 0.15;

          this.updateLaserAttributesSmartly(nbPoints);//offset); 

          _indiceTimeLaser = 0.5;                    
          if(!this.animateOn){this.animateOn = true; this.animatePoints2(); /*console.log('thisanimate');*/}  // First file
                                                                                    // start animation function
          this.indiceLaserFileLoaded++;// console.log(_currentNbPointsInBuffer);
          this.indicePacketInBuffer++;
          // Load the next file in the list if not last (seems faster than parallel load)
          if(this.indiceLaserFileLoaded < this.tabLaserFilesToLoad.length )
             this.readLaserPointsFileFromItownsGenericMesh(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded],nbBitsPerAttribute,pivot);
           
      },
      
      
      triangulateLaserCloudSAVE: function(nbPoints){
          
          console.log('triangulateLaserCloud ',_indiceStartTriangulate,_currentNbPointsInBuffer);
          var nbPointsPerTurn = 360;
          var offsetSub = _indiceStartTriangulate* 3;
          var offsetSubEnd = offsetSub + (nbPoints) * 3;
          var view = _bufferGeometry.attributes.position.array.subarray(offsetSub, offsetSubEnd);
          
          var _geometryLidar = new THREE.Geometry();
          
          // Vertices
          for(var i =0; i< nbPoints*3; i+=3){
             
            var v = new THREE.Vector3(view[i],view[i+1],view[i+2]);
            if(i==0)Draw.drawSphereAt(v,0.1);
            //console.log(v);
            _geometryLidar.vertices.push(v);
          }
          
          // Faces
          for(var a=0;a<_geometryLidar.vertices.length - nbPointsPerTurn - 1;++a){
             
             if(a%360 != 0){ 
                _geometryLidar.faces.push( new THREE.Face3( a, a+1, a+nbPointsPerTurn) );
                _geometryLidar.faces.push( new THREE.Face3( a+1, a+1+nbPointsPerTurn, a+nbPointsPerTurn) );
            }
          }
          
          _geometryLidar.computeFaceNormals();
        
          var mat = new THREE.MeshBasicMaterial({color:0xDCE9FA, wireframe:true, wireframeLinewidth: 1, transparent: true, opacity: 0.3});
          mat.side = THREE.DoubleSide;
          var meshLidar = new THREE.Mesh(_geometryLidar, mat);
          gfxEngine.addToScene(meshLidar);  
          
         //this.textureMeshLidar(_geometryLidar);
        
      },
      
       
      triangulateLaserCloud: function(nbPoints){
          
          var maxDist = 0.8; // max distance in meters between consecutive vertices
          console.log('triangulateLaserCloud ',_indiceStartTriangulate,_currentNbPointsInBuffer);
          var nbPointsPerTurn = 360;
          var offsetSub = _indiceStartTriangulate* 3;
          var offsetSubEnd = offsetSub + (nbPoints) * 3;
          var view = _bufferGeometry.attributes.position.array.subarray(offsetSub, offsetSubEnd);
          
          var _geometryLidar = new THREE.Geometry();
          var lastVertex = new THREE.Vector3(view[0],view[1],view[2]);  // first vertex
          
          
          var copyOut = new Array(nbPoints);// view.slice(0);

          for(var i =0; i< nbPoints; ++i){
              copyOut[i] = new THREE.Vector3(view[i*3],view[i*3+1],view[i*3+2]);
          }
          
          var copyOutPP = copyOut.slice(0);
 
          for(var i= nbPointsPerTurn +1; i< copyOut.length -(nbPointsPerTurn +1);++i){
              
              //this.analyzeNeighbourood(copyOut,copyOutPP,i,nbPointsPerTurn,maxDist);
              if (copyOutPP[i].y >-2 && copyOutPP[i].y <11)
                   copyOutPP[i] = this.filterLidarMeshUsingRoofLine(copyOut,i,nbPointsPerTurn,maxDist);
                  // copyOutPP[i] = this.filterLidarMeshComputingFacadePlan(copyOut,i,nbPointsPerTurn,maxDist);
          }
           // Vertices
          for(var i =0; i< nbPoints; i++){
              
              _geometryLidar.vertices.push(copyOutPP[i]);
          }
   
           // Faces
           // ADDED AS OPTION FILTER TOO LARGE TRIANGLES
           var maxDistanceInTriangle = 4.5; // 3 meters max
          for(var a=0;a<_geometryLidar.vertices.length - nbPointsPerTurn - 1;++a){
             
             if(a%360 != 0){ 
                 
                 var v1 = _geometryLidar.vertices[a];
                 var v2 = _geometryLidar.vertices[a+1];
                 var v3 = _geometryLidar.vertices[a+nbPointsPerTurn];
                 var v4 = _geometryLidar.vertices[a+1+nbPointsPerTurn];
                 
                  if(v1.distanceTo(v2)< maxDistanceInTriangle && v1.distanceTo(v3)< maxDistanceInTriangle)
                     _geometryLidar.faces.push( new THREE.Face3( a, a+1, a+nbPointsPerTurn) );
                         
                  if(v2.distanceTo(v3)< maxDistanceInTriangle && v2.distanceTo(v4)< maxDistanceInTriangle)        
                    _geometryLidar.faces.push( new THREE.Face3( a+1, a+1+nbPointsPerTurn, a+nbPointsPerTurn) );
                
            }
          }
          
          _geometryLidar.computeFaceNormals();
        
          var mat = new THREE.MeshBasicMaterial({color:0xDCE9FA, wireframe:true, wireframeLinewidth: 1, transparent: true, opacity: 0.3});
          mat.side = THREE.DoubleSide;
          var meshLidar = new THREE.Mesh(_geometryLidar, mat);
     //     gfxEngine.addToScene(meshLidar);  
          
          this.textureMeshLidar(_geometryLidar);
        
      },
           
           
      // THE CURRENT WORKING ONE             
      // We estimate the vertical accumulation to get most probable xz    
      // (next We ll estimate vertical vector at altitude higher than truck)  
      filterLidarMeshUsingRoofLine:function(arr,pos,nbPointsPerTurn,maxDist){
          
          var nbPointsToEstimate = 3; // 2 meters
          var indice = pos;  // indice to start estimating xz going up
          var sens = true;//arr[pos].y - arr[pos+1].y <0 ; // if positive then we go down (left side of road)
          var currentAlti = arr[indice].y;
          var alti = arr[indice].y;
          var highestAlti = -20;
          var indicehighestAlti = -1;
          var indiceOtherSide = -1;

          
       // We look in a total turn for the indice of the highest point
        for(var i=0; i<nbPointsPerTurn; ++i){
            
            if(arr[pos+i].y >= highestAlti){
                 highestAlti = arr[pos+i].y;
                 indicehighestAlti = pos+i;
            }  
        }
        
        // Then we look for the other highest point from the opposite side
          var hightestaltiV2 = new THREE.Vector2(arr[indicehighestAlti].x,arr[indicehighestAlti].z);
          var otherSideFound = false;
          var a=0;
          var gapSize = 5; // 5 meters between points for minimum gap acceptable
         
          while(!otherSideFound){
              
              var pointNearer = new THREE.Vector2(arr[indicehighestAlti + a].x,arr[indicehighestAlti + a].z);
              var pointFarer  = new THREE.Vector2(arr[indicehighestAlti - a].x,arr[indicehighestAlti - a].z);
              var d = hightestaltiV2.distanceTo(pointNearer);
              var d2 = hightestaltiV2.distanceTo(pointFarer);
              
              if(d>gapSize || d2 >gapSize){
                otherSideFound = true;
                if(d>d2){
                     indiceOtherSide = indicehighestAlti + a;
                }else{
                     indiceOtherSide = indicehighestAlti - a;
                }
             }
             a++;
          }
 
        //  then we need to find which side is associated to the current point
          var tempPosA = new THREE.Vector3(arr[pos].x,arr[indicehighestAlti].y, arr[pos].z);
          var tempPosB = new THREE.Vector3(arr[pos].x,arr[indiceOtherSide].y,   arr[pos].z);
          var currentPointToA = tempPosA.distanceTo(arr[indicehighestAlti]);
          var currentPointToB = tempPosB.distanceTo(arr[indiceOtherSide]);
          
          var dd = Math.max(currentPointToA, currentPointToB);
          
          var currentPosIndiceHigh, otherSideIndiceHigh;
          if(dd == currentPointToA){
              currentPosIndiceHigh = indiceOtherSide;
              otherSideIndiceHigh = indicehighestAlti;
              
          }else{
              currentPosIndiceHigh = indicehighestAlti;
              otherSideIndiceHigh = indiceOtherSide;
          }
          
        // Here are the highest point in the same side same row of the current point and other side point
          var pointSameSideHighest  = arr[currentPosIndiceHigh];
          var pointOtherSideHighest = arr[otherSideIndiceHigh];
          
         var color = Math.random()*0xffffff;
 /*        if(arr[pos].y>10){
            Draw.drawSphereAt(pointOtherSideHighest, 0.1,color);
            Draw.drawSphereAt(pointSameSideHighest, 0.1,color);
         }
     */     
          
        // We search to get 0.3 meters behind roof limit
        // Do a vector 
          var s = new THREE.Vector2(pointSameSideHighest.x,pointSameSideHighest.z);
          var o = new THREE.Vector2(pointOtherSideHighest.x,pointOtherSideHighest.z);
    /*      var so = new THREE.Vector2.subVectors(o,s);
          so.normalize();
     */     
          // We compute the position of the roof line supposing its a bit back from highest laser
          var alpha = Math.atan2(o.y - s.y, o.x - s.x);
          var decalage =  -0.5; // 80cm from roof line
          var vx = decalage * Math.cos(alpha);
          var vz = decalage * Math.sin(alpha);
          var pointWithDecalage = new THREE.Vector3(pointSameSideHighest.x + vx,
                                                    pointSameSideHighest.y,
                                                    pointSameSideHighest.z + vz);
        
          // We compute the plausible position of stuff behind roof line like window etc
          var decalageBackRoof =  -1; // 80cm from roof line
          vx = decalageBackRoof * Math.cos(alpha);
          vz = decalageBackRoof * Math.sin(alpha);
          var positionBackRoof = new THREE.Vector3(pointSameSideHighest.x + vx,
                                                   pointSameSideHighest.y,
                                                   pointSameSideHighest.z + vz);

          
       // We then look if the point is far from roof print
          var currentPointAltiHigh = new THREE.Vector3(arr[pos].x, pointSameSideHighest .y, arr[pos].z);
          var dist = currentPointAltiHigh.distanceTo(pointWithDecalage);//pointSameSideHighest );
          var pointCorrected = arr[pos];
         
          if(dist > maxDist){
              
             // We need to look for a better alti for the point, using horizontal neighbours, min is usually good alti
             var somAlti = 0;
             var altiMin = 1000;
             
             for(var j =0; j<10; ++j){
                 var indice = pos+nbPointsPerTurn * j;
                 if(indice< arr.length){
                    somAlti+=arr[indice].y;
                    if(arr[indice].y<altiMin)
                        altiMin = arr[indice].y
                }
                    
             }
             altiMin = altiMin == 1000 ? arr[pos].y : altiMin;
             
             pointCorrected = new THREE.Vector3(positionBackRoof.x,altiMin,positionBackRoof.z);
         }
         
         return pointCorrected
 
      },
          
          
      // We estimate the vertical accumulation to get most probable xz    
      // (next We ll estimate vertical vector at altitude higher than truck)  
      filterLidarMeshComputingFacadePlan:function(arr,pos,nbPointsPerTurn,maxDist){
          
          var nbPointsToEstimate = 12; // 2 meters
          var indice = pos;  // indice to start estimating xz going up
          var sens = arr[pos].y - arr[pos+1].y <0 ; // if positive then we go down (left side of road)
        //  var alti = arr[indice].y;
          var sensToGo = arr[indice].y > 2;  
          
          
          // First find indice of position to start computing median
          // We need the altitude to be higher than truck
          while (!sensToGo && indice < arr.length){
              if(sens) 
                  indice -=2;
              else
                  indice +=2;
              sensToGo = arr[indice].y > 2 ;  
          }

          var arrVerticalValuesX = [];
          var arrVerticalValuesZ = [];
          for(var i=0;i<nbPointsToEstimate; ++i){
              
              arrVerticalValuesX.push(arr[indice +i].x);
              arrVerticalValuesZ.push(arr[indice +i].z);
              
          }
          
          arrVerticalValuesX.sort(function(a,b){return a - b});
          arrVerticalValuesZ.sort(function(a,b){return a - b});
          
          var indiceMedian = Math.floor((arrVerticalValuesX.length + 1) /2);
          
          var pointMedian = new THREE.Vector3(arrVerticalValuesX[indiceMedian],arr[pos].y,arrVerticalValuesZ[indiceMedian]);
          
         // console.log(arrVerticalValuesX,arrVerticalValuesZ,'pointMedian ',pointMedian,'indiceMedian',indiceMedian);
          var pointCorrected = arr[pos];
          
          // If dist too big we need to compute new point to replace artefact
          // x,z are already computed from median we just need to compute altitude from horizontal neighboors
          if( pointMedian.distanceTo(arr[pos]) > maxDist){
              
              var arrAltiNeighboors = [];
              for (var a=0;a<nbPointsToEstimate; ++a){
                  
                  var indice = pos + a*(nbPointsPerTurn);
                  if (indice<arr.length) arrAltiNeighboors.push(arr[indice].y);
              }
              
              arrAltiNeighboors.sort(function(a,b){return a - b});
              var indiceMedianH = Math.floor((arrAltiNeighboors.length + 1) /2);
              // Adjust point returned with new alti
              pointCorrected = new THREE.Vector3(pointMedian.x,arrAltiNeighboors[indiceMedianH],pointMedian.z);
              
          }
              
              
          return pointCorrected;    
          
      },
              
        
      filterLidarMeshUsingRGE:function(){
          
      },
                    
      // 4 connex        
      analyzeNeighbourood: function(arr,arrOut,pos,nbPointsPerTurn,maxDist){
          
      //    console.log(arr,pos);
            var v = arr[pos];
            var vUp = arr[pos+1]; 
            var vDown = arr[pos-1];  
            var vRight = arr[pos + nbPointsPerTurn]; 
            var vLeft = arr[pos - nbPointsPerTurn];  
            var max =0; var side="";
            
            if(v.y<12){
                var a = v.distanceTo(vDown);
                var b = v.distanceTo(vLeft);
                if(a>b) {max = a; side = "vDown"} else {max = b; side = "vLeft"};
                if(max>maxDist){
                    if(side=="vDown")
                        arrOut[pos] = vDown;
                    else
                        arrOut[pos] = vLeft;
                }
                
                /*
                if (v.distanceTo(vDown)> maxDist){
                    //Draw.drawSphereAt(v,0.2);
                    arr[pos] = arr[pos-1];
                 //   arr[pos].y += arr[pos-1].y - arr[pos-2].y;
                }*/
            }
            /*
            var variationx = v.x - lastVertex.x;
            var variationy = v.x - lastVertex.y;
            var variationz = v.z - lastVertex.z;
            */
          
      },        
      
      
      textureMeshLidar: function(geo){
          
           var mat = ProjectiveTexturing2.getShaderMat();
           var meshLidar  = new THREE.Mesh(geo,mat);//, mat); //new THREE.MeshBasicMaterial({wireframe:true, color:0xff00ff}));
        //   meshLidar.material.side = THREE.DoubleSide;
        //   meshLidar.material.transparent = false;
           gfxEngine.addToScene(meshLidar);
          
      },


      updateLaserAttributes: function() {

            _bufferGeometry.attributes.position.needsUpdate = true;
            _bufferGeometry.attributes.color.needsUpdate = true; 
            _bufferGeometry.attributes.uniqueid.needsUpdate = true;
            
            //Picking
            _geometryParticleSystemPicking.verticesNeedUpdate = true;
            _geometryParticleSystemPicking.colorsNeedUpdate = true;
             // _bufferGeometry.verticesNeedUpdate = true;

       },

        // offset is _currentNbPointsInBuffer * 3; -> the place to start writing new points
        // !! offset for subarray is expressed in arraytype -> float32, not byte like for buffersubdata
        // !! new Float32Array(_bufferGeometry.attributes.position.array,offset,nbPoints *32)  doesnt take offset in account,
        // even if multiple of typearray(float32), https://developer.mozilla.org/en-US/docs/Web/API/Float32Array
        updateLaserAttributesSmartly: function(nbPoints){
            

              var offsetGeometry = (_currentNbPointsInBuffer -  (nbPoints-1)) * 12;
              var offsetSub = (_currentNbPointsInBuffer - (nbPoints-1)) * 3;
              var lengthSub = (nbPoints) * 3;
              var offsetSubEnd = offsetSub + lengthSub;

              // Positions
              var view = _bufferGeometry.attributes.position.array.subarray(offsetSub, offsetSubEnd);
              _gl.bindBuffer(_gl.ARRAY_BUFFER, _bufferGeometry.attributes.position.buffer);
              _gl.bufferSubData(_gl.ARRAY_BUFFER, offsetGeometry,view);
              // _gl.bufferData(_gl.ARRAY_BUFFER, _bufferGeometry.attributes.position.array, _gl.DYNAMIC_DRAW);  // OK all buffer

              // Color
              view = _bufferGeometry.attributes.color.array.subarray(offsetSub, offsetSubEnd);
              _gl.bindBuffer(_gl.ARRAY_BUFFER, _bufferGeometry.attributes.color.buffer);
              _gl.bufferSubData(_gl.ARRAY_BUFFER, offsetGeometry,view);
              
              // id
              view = _bufferGeometry.attributes.uniqueid.array.subarray(offsetSub/3, offsetSubEnd/3);
              _gl.bindBuffer(_gl.ARRAY_BUFFER, _bufferGeometry.attributes.uniqueid.buffer);
              _gl.bufferSubData(_gl.ARRAY_BUFFER, offsetGeometry/3,view);

              //Picking
              _geometryParticleSystemPicking.verticesNeedUpdate = true;
              _geometryParticleSystemPicking.colorsNeedUpdate = true;
              
        },
        
        
        
        //***********************************************************************
        animatePoints2: function() {

           if(_movementLocked !=1){
                for(var i=0;i<_nbIndiceMax ;++i){

                      if(_indice_time_laser_tab[i] >0){
                          _indice_time_laser_tab[i] -= _indice_time_laser_tab[i] * _speedMovment;
                           if (_indice_time_laser_tab[i]<0.001)
                               _indice_time_laser_tab[i]= 0.;
                      }
                }
            }
           requestAnimFrame2(LaserCloud.animatePoints2 );     
      },
      
      
      // Optimize locking when no more lasers are loaded for faster gpu rendering
      setLockMovement: function(value){
            
            _movementLocked = value;
            _shaderUniforms.movementLocked.value = _movementLocked;
            //setTimeout(Panoramic.setLockMovement, 300);  // !! scope
      },
      
      getLockedMovement: function(){
          return _movementLocked;
      },
       

      // Damn file with special order xzy... to optimise loading we dont put 'if' statement
      // and duplicate some code for pivot too... 
      addPointsToBufferIGN: function(buffer,nbAttributes,nbBitsPerAttribute,pivot){
          
         var byteArray; 
         switch(nbBitsPerAttribute){
             
             case 64: byteArray = new Float64Array(buffer); break;
             case 32: byteArray = new Float32Array(buffer); break;
             case 16: byteArray = new Int16Array(buffer); break;
         }
         
	 var positions = _bufferGeometry.attributes.position.array;
         var values_color = _bufferGeometry.attributes.color.array;
         var uniqueids =    _bufferGeometry.attributes.uniqueid.array;
         
         var color2 = new THREE.Color();        
          
         if(_currentNbPointsInBuffer > _nbPointsBuffer){// + byteArray.length/(4*nbBitsPerAttributes) ))
            _currentNbPointsInBuffer   = 0;   // We add new points remplacing the oldest in buffer
            this.indicePacketInBuffer = 0;
        }
          
         for(var p = 0; p < byteArray.length-nbAttributes; p=p+nbAttributes){ // P+4 cause x,y,z,i in bin

                var pX = byteArray[p] - pivot.x,
                pZ = byteArray[p+1] - pivot.z ,
                pY = byteArray[p+2] - pivot.y ;  // Decalage laser/cam
                var pI = 0.5;  // Intensity default    
                //if(pX > 50) console.log(pX,pY,pZ);
                if(nbAttributes>3) pI = byteArray[p+3];
                
                positions[ _currentNbPointsInBuffer * 3 + 0 ] = pX;
                positions[ _currentNbPointsInBuffer * 3 + 1 ] = pY;
                positions[ _currentNbPointsInBuffer * 3 + 2 ] = pZ;
                
                color2.setHSL(pI,0.5,0.8);
                values_color[ _currentNbPointsInBuffer * 3 + 0] = color2.r;
                values_color[ _currentNbPointsInBuffer * 3 + 1] = color2.g;
                values_color[ _currentNbPointsInBuffer * 3 + 2] = color2.b;
               
                uniqueids[ _currentNbPointsInBuffer ] = this.indicePacketInBuffer;
                
                // Then for the picking ***********************
                var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                var nbZerosMissing = 6 - colorHexFromInt.length;
                for (var i=0; i< nbZerosMissing; ++i){ colorHexFromInt = '0' + colorHexFromInt;}
                var colorHex = '#'+colorHexFromInt;
                _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                 var vectorPoint = new THREE.Vector3(pX, pY, pZ); //particle
                _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = vectorPoint;
                //******************
                
                _currentNbPointsInBuffer++;
         }
         
          _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;
          _indice_time_laser_tab[this.indicePacketInBuffer] = 0.3;
          
          this.updateLaserAttributes(); 
          _geometryParticleSystemPicking.verticesNeedUpdate = true;
          _geometryParticleSystemPicking.colorsNeedUpdate = true;
          
          _indiceTimeLaser = 0.5;                    
         if(!this.animateOn){this.animateOn = true; this.animatePoints2();}  // First file
                                                                                    // start animation function
          this.indiceLaserFileLoaded++;
          this.indicePacketInBuffer++
          // Load the next file in the list if not last (seems faster than parallel load)
          if(this.indiceLaserFileLoaded < this.tabLaserFilesToLoad.length)
                    this.readLaserPointsFileFromItownsBINARY(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded],nbBitsPerAttribute,pivot);
      },
      
      
        // Read bin file  using dataView   Light version bruno
        readLaserFileLocalPlySAVE: function(buffer, nbAttributes, nbBitsPerAttribute, pivot) {

            /* !!! Special error when trying to read a float 64 when the offset (the position) is not a multiple of 8...  !!!  */
            /* UPDATE: Using DataView which is now supported by chrome & FF                                                   */
            //ex://6127450
            _dataView = new DataView(buffer);
            if(_currentNbPointsInBuffer>0){this.initializeBufferValues(); _nbLabel = 0;}  // We clean old data buffers
            // We need to detect the 'end_header'
            // 'e' -> 101 sur 8 bits then 'n' -> 110..
            // des qu on voit la suite (ea)der : (101 97) 100 101 114 10 (retour chariot)

            if( (_currentNbPointsInBuffer + 3000000) > _nbPointsBuffer ){// + byteArray.length/(4*nbBitsPerAttributes) ))
                _currentNbPointsInBuffer   = 0;   // We add new points remplacing the oldest in buffer
                this.indicePacketInBuffer  = 0;
            }
            
             var offsetStartCoding = 0;
             var littleEndian = true;         
             var startFound = false;
             var a = 0;
             while (!startFound && a<8000){
                startFound = ((_dataView.getInt8(a,littleEndian) == 100) && (_dataView.getInt8(a+1,littleEndian) == 101) && (_dataView.getInt8(a+2,littleEndian) == 114));// && (_dataView.getInt8(a+3,littleEndian) == 10)) ;
                a++;
             }
             if(a>=8000){ alert("fichier incorrect"); return;} else console.log("hearder end found at ",a);
             var offsetStartCoding = a+3;  // Offset where start the objects 
             if(nbAttributes==28) {offsetStartCoding = a+4;};
             _sizeHeader = offsetStartCoding;
             
            var originalPlyWithNoClass = false;//(_sizeHeader == 856 || _sizeHeader ==922 ); // DIRTY TEST
            
            
            var sizeObjectByte = 86;
            if(!originalPlyWithNoClass) sizeObjectByte = 54;  // with label & class
            
      //      if(nbAttributes==28) {var sizeObjectByte = 82; console.log('PARIS2014');}  // FOR NEW PLY like PARIS 2014, LOUVRE...
             
            var nbPoints = ((buffer.byteLength - offsetStartCoding) / sizeObjectByte) * 1;//pourcentage;

            var positions =    _bufferGeometry.attributes.position.array;
            var values_color = _bufferGeometry.attributes.color.array;
            var uniqueids =    _bufferGeometry.attributes.uniqueid.array;
            var classes =      _bufferGeometry.attributes.classe.array;

            var color2 = new THREE.Color();
            var pX,pY,pZ,pI,ind,label=0,classe=0;   

            for (var i = offsetStartCoding; i < nbPoints * sizeObjectByte; i += sizeObjectByte) {

                pX = _dataView.getFloat32(i + 8, littleEndian) - pivot.x;
                pZ = _dataView.getFloat32(i + 12, littleEndian) - pivot.z;
                pY = _dataView.getFloat32(i + 16, littleEndian) - pivot.y;
                pI = (_dataView.getFloat32(i + 32, littleEndian) + 25) / 35;
                
                if(!originalPlyWithNoClass){
                    
                    label  = _dataView.getUint32(i+44, littleEndian);
                    classe = _dataView.getUint32(i+48, littleEndian);
                    if(i<5000) console.log("label",label);
                    if(label > _nbLabel) _nbLabel = label;
                    if(label>0){color2.setHSL(label/60,1.0,0.5); if(i<15000)console.log("label",label);}
                 //   if(classe !=0) {pI = 0; color2.setHSL(pI,1.0,0.5);} //Math.random();
                       else color2.setHSL(pI,0.5,0.8)
                }else{
                    color2.setHSL(pI,0.5,0.8);
                }
                    
                ind = _currentNbPointsInBuffer * 3;
                
                positions[ ind + 0 ] = pX;
                positions[ ind + 1 ] = pY;
                positions[ ind + 2 ] = pZ;

                
                values_color[ ind + 0] = color2.r;
                values_color[ ind + 1] = color2.g;
                values_color[ ind + 2] = color2.b;

                uniqueids[ _currentNbPointsInBuffer ] = label;
                classes[ _currentNbPointsInBuffer ]   = classe;

            // Then for the picking ***********************
                    var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                    var nbZerosMissing = 6 - colorHexFromInt.length;
                     for (var a = 0; a < nbZerosMissing; ++a) { colorHexFromInt = '0' + colorHexFromInt;}
                    var colorHex = '#'+colorHexFromInt;
                    _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                    _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = new THREE.Vector3(pX, pY, pZ);

                _currentNbPointsInBuffer++;
                
                
            }
            

             _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;
             _indice_time_laser_tab[this.indicePacketInBuffer] = 0.15;

             this.updateLaserAttributes();
             
             _localMode = true;
             var posFirstVertex = new THREE.Vector3(positions[600000],positions[600001],positions[600002]);
             var options = {intersectionToLook:posFirstVertex, surfaceType:"Rectangle"};
             require("Navigation").goToClosestPosition(posFirstVertex.add(gfxEngine.getZeroAsVec3D()),options);
                                                                        
            this.indiceLaserFileLoaded++;  // console.log(_currentNbPointsInBuffer);
            this.indicePacketInBuffer++;
            
            this.setMessageDisplay("",false);
            
            console.log("nb ids: '(label",_nbLabel);
        },
        
        
        // Read bin file  using dataView
        readLaserFileLocalPly: function(buffer, nbAttributes, nbBitsPerAttribute, pivot) {

            /* !!! Special error when trying to read a float 64 when the offset (the position) is not a multiple of 8...  !!!  */
            /* UPDATE: Using DataView which is now supported by chrome & FF                                                   */
            //ex://6127450
            _dataView = new DataView(buffer);
            if(_currentNbPointsInBuffer>0){this.initializeBufferValues(); _nbLabel = 0;}  // We clean old data buffers
            // We need to detect the 'end_header'
            // 'e' -> 101 sur 8 bits then 'n' -> 110..
            // des qu on voit la suite (ea)der : (101 97) 100 101 114 10 (retour chariot)

            if( (_currentNbPointsInBuffer + 3000000) > _nbPointsBuffer ){// + byteArray.length/(4*nbBitsPerAttributes) ))
                _currentNbPointsInBuffer   = 0;   // We add new points remplacing the oldest in buffer
                this.indicePacketInBuffer  = 0;
            }
            
             var offsetStartCoding = 0;
             var littleEndian = true;         
             var startFound = false;
             var a = 0;
             while (!startFound && a<8000){
                startFound = ((_dataView.getInt8(a,littleEndian) == 100) && (_dataView.getInt8(a+1,littleEndian) == 101) && (_dataView.getInt8(a+2,littleEndian) == 114));// && (_dataView.getInt8(a+3,littleEndian) == 10)) ;
                a++;
             }
             if(a>=8000){ alert("fichier incorrect"); return;} else console.log("hearder end found at ",a);
             var offsetStartCoding = a+3;  // Offset where start the objects 
             if(nbAttributes==28) {offsetStartCoding = a+4;};
             _sizeHeader = offsetStartCoding;
             
            var originalPlyWithNoClass = (_sizeHeader == 856 || _sizeHeader ==922 ); // DIRTY TEST
            
            
            var sizeObjectByte = 86;   // New laser file (paris 2014 is 82 bytes, 86 for old like terrmob2)
            if(!originalPlyWithNoClass) sizeObjectByte = 94;  // with label & class
            
            if(nbAttributes==28) {var sizeObjectByte = 82; console.log('PARIS2014');}  // FOR NEW PLY like PARIS 2014, LOUVRE...
             
            var nbPoints = ((buffer.byteLength - offsetStartCoding) / sizeObjectByte) * 1;//pourcentage;

            var positions =    _bufferGeometry.attributes.position.array;
            var values_color = _bufferGeometry.attributes.color.array;
            var uniqueids =    _bufferGeometry.attributes.uniqueid.array;
            var classes =      _bufferGeometry.attributes.classe.array;

            var color2 = new THREE.Color();
            var pX,pY,pZ,pI,ind,label=0,classe=0;   

            for (var i = offsetStartCoding; i < nbPoints * sizeObjectByte; i += sizeObjectByte) {

                pX = _dataView.getFloat32(i + 32, littleEndian) - pivot.x;
                pZ = _dataView.getFloat32(i + 36, littleEndian) - pivot.z;
                pY = _dataView.getFloat32(i + 40, littleEndian) - pivot.y;
                pI = (_dataView.getFloat32(i + 70, littleEndian) + 25) / 35;
                
                if(!originalPlyWithNoClass){
                    
                    label = _dataView.getFloat32(i+86, true);
                    classe = _dataView.getFloat32(i+90, true);
                    if(label > _nbLabel) _nbLabel = label;
                    if(classe !=0) {pI = 0; color2.setHSL(pI,1.0,0.5);} //Math.random();
                       else color2.setHSL(pI,0.5,0.8)
                }else{
                    color2.setHSL(pI,0.5,0.8);
                }
                    
                ind = _currentNbPointsInBuffer * 3;
                
                positions[ ind + 0 ] = pX;
                positions[ ind + 1 ] = pY;
                positions[ ind + 2 ] = pZ;

                
                values_color[ ind + 0] = color2.r;
                values_color[ ind + 1] = color2.g;
                values_color[ ind + 2] = color2.b;

                uniqueids[ _currentNbPointsInBuffer ] = label;
                classes[ _currentNbPointsInBuffer ]   = classe;

            // Then for the picking ***********************
                    var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                    var nbZerosMissing = 6 - colorHexFromInt.length;
                     for (var a = 0; a < nbZerosMissing; ++a) { colorHexFromInt = '0' + colorHexFromInt;}
                    var colorHex = '#'+colorHexFromInt;
                    _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                    _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = new THREE.Vector3(pX, pY, pZ);

                _currentNbPointsInBuffer++;
                
                
            }
            

             _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;
             _indice_time_laser_tab[this.indicePacketInBuffer] = 0.15;

             this.updateLaserAttributes();
             
             _localMode = true;
             var posFirstVertex = new THREE.Vector3(positions[600000],positions[600001],positions[600002]);
             var options = {intersectionToLook:posFirstVertex, surfaceType:"Rectangle"};
         //    require("Navigation").goToClosestPosition(posFirstVertex.add(gfxEngine.getZeroAsVec3D()),options);   // Launch camera move and load pano close to laser points
                                                                        
            this.indiceLaserFileLoaded++;  // console.log(_currentNbPointsInBuffer);
            this.indicePacketInBuffer++;
            
            this.setMessageDisplay("",false);
        },
        
        
        readLaserFileXYZAscii: function(contents, nbAttributes, nbBitsPerAttribute, pivot) {


            if (_currentNbPointsInBuffer > _nbPointsBuffer)// + byteArray.length/(4*nbBitsPerAttributes) ))
                _currentNbPointsInBuffer = 0;   // We add new points remplacing the oldest in buffer


            var positions = _bufferGeometry.attributes.position.array;
            var values_color = _bufferGeometry.attributes.color.array;
            var uniqueids = _bufferGeometry.attributes.uniqueid.array;

            var color2 = new THREE.Color();
            color2.setHSL(0.4 + Math.random(), 0.5, 0.8);

            var lines = contents.match(/^.*((\r\n|\n|\r)|$)/gm);
            var x, y, z, xyz;
            for (var i = 0; i < lines.length; ++i) {
                xyz = lines[i].split(' '); //console.log(xyz);
                x = parseFloat(xyz[0] - pivot.x);
                z = parseFloat(xyz[1] - pivot.z);
                y = parseFloat(xyz[4] - pivot.y);
                //  if(i<10)console.log(x,y,z);

                positions[ _currentNbPointsInBuffer * 3 + 0 ] = x;
                positions[ _currentNbPointsInBuffer * 3 + 1 ] = y;
                positions[ _currentNbPointsInBuffer * 3 + 2 ] = z;


                values_color[ _currentNbPointsInBuffer * 3 + 0] = color2.r;
                values_color[ _currentNbPointsInBuffer * 3 + 1] = color2.g;
                values_color[ _currentNbPointsInBuffer * 3 + 2] = color2.b;



                uniqueids[ _currentNbPointsInBuffer ] = this.indiceLaserFileLoaded;

                // Then for the picking ***********************
                var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                var nbZerosMissing = 6 - colorHexFromInt.length;
                for (var a = 0; a < nbZerosMissing; ++a) {
                    colorHexFromInt = '0' + colorHexFromInt;
                }
                var colorHex = '#' + colorHexFromInt;
                _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                var vectorPoint = new THREE.Vector3(x, y, z); //particle
                _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = vectorPoint;
                //******************

                _currentNbPointsInBuffer++;
            }

            _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;

            this.updateLaserAttributes();
            _geometryParticleSystemPicking.verticesNeedUpdate = true;
            _geometryParticleSystemPicking.colorsNeedUpdate = true;

            _indiceTimeLaser = 0.5;
           if(!this.animateOn){this.animateOn = true; this.animatePoints2();}  // First file
            // start animation function
            this.indiceLaserFileLoaded++;
            // Load the next file in the list if not last (seems faster than parallel load)
            if (this.indiceLaserFileLoaded < this.tabLaserFilesToLoad.length)
                this.readLaserPointsFileFromItownsBINARY(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded]);
            //var l1 = contents.substr(1, 12);//contents.indexOf("n"));
            //console.log(l1);
        },
        
        
        readLaserFileLidarFormat: function(contents, nbAttributes, nbBitsPerAttribute, pivot) {


            if (_currentNbPointsInBuffer > _nbPointsBuffer)// + byteArray.length/(4*nbBitsPerAttributes) ))
                _currentNbPointsInBuffer = 0;   // We add new points remplacing the oldest in buffer


            var positions = _bufferGeometry.attributes.position.array;
            var values_color = _bufferGeometry.attributes.color.array;
            var uniqueids = _bufferGeometry.attributes.uniqueid.array;

            var color2 = new THREE.Color();
            color2.setHSL(0.4 + Math.random(), 0.5, 0.8);

            var lines = contents.match(/^.*((\r\n|\n|\r)|$)/gm);
            var x, y, z, xyz;

            for (var i = 0; i < lines.length; ++i) {
                xyz = lines[i].split(' ');
                x = parseFloat(xyz[0]) / 1000 + 655000 - pivot.x;
                z = parseFloat(xyz[1]) / 1000 + 6860000 - pivot.z;
                y = parseFloat(xyz[2]) / 1000 - pivot.y;
                if (i < 3)
                    console.log(x, y, z);


                positions[ _currentNbPointsInBuffer * 3 + 0 ] = x;
                positions[ _currentNbPointsInBuffer * 3 + 1 ] = y;
                positions[ _currentNbPointsInBuffer * 3 + 2 ] = z;


                values_color[ _currentNbPointsInBuffer * 3 + 0] = color2.r;
                values_color[ _currentNbPointsInBuffer * 3 + 1] = color2.g;
                values_color[ _currentNbPointsInBuffer * 3 + 2] = color2.b;



                uniqueids[ _currentNbPointsInBuffer ] = this.indiceLaserFileLoaded;

                // Then for the picking ***********************
                var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                var nbZerosMissing = 6 - colorHexFromInt.length;
                for (var a = 0; a < nbZerosMissing; ++a) {
                    colorHexFromInt = '0' + colorHexFromInt;
                }
                var colorHex = '#' + colorHexFromInt;
                _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                var vectorPoint = new THREE.Vector3(x, y, z); //particle
                _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = vectorPoint;
                //******************

                _currentNbPointsInBuffer++;
            }

            _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;

            this.updateLaserAttributes();
            _geometryParticleSystemPicking.verticesNeedUpdate = true;
            _geometryParticleSystemPicking.colorsNeedUpdate = true;

            _indiceTimeLaser = 0.5;
           if(!this.animateOn){this.animateOn = true; this.animatePoints2();}  // First file
            // start animation function
            this.indiceLaserFileLoaded++;
            // Load the next file in the list if not last (seems faster than parallel load)
            if (this.indiceLaserFileLoaded < this.tabLaserFilesToLoad.length)
                this.readLaserPointsFileFromItownsBINARY(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded]);
            //var l1 = contents.substr(1, 12);//contents.indexOf("n"));

            //var l1 = contents.substr(1, 12);//contents.indexOf("n"));
            //console.log(l1);
        },
        
        
        readLaserFileASCII: function(buffer, nbAttributes, nbBitsPerAttribute, pivot) {
        },
        
        
        // Loader for binary file with no Header. All attributes have to be the same data type
        // pivot is the value we substract to all coordinates
        // Work for xyz, xyzi, xyzikzfzefzfz... 
        // in itowns file sys, each point has a x,y,z,i,c (3dposition,intensity and a class)
        // ex xyzi double -> nbAttributes:4, nbBitsPerAttribute:64
        addPointsToBufferGenericWithConversion: function(buffer, nbAttributes, nbBitsPerAttribute, pivot, projection1, projection2) {

            var byteArray;
            switch (nbBitsPerAttribute) {

                case 64:
                    byteArray = new Float64Array(buffer);
                    break;
                case 32:
                    byteArray = new Float32Array(buffer);
                    break;
                case 16:
                    byteArray = new Int16Array(buffer);
                    break;
            }

            var positions = _bufferGeometry.attributes.position.array;
            var values_color = _bufferGeometry.attributes.color.array;
            var uniqueids = _bufferGeometry.attributes.uniqueid.array;

            var color2 = new THREE.Color();
            var pI;
            if (_currentNbPointsInBuffer > _nbPointsBuffer)// + byteArray.length/(4*nbBitsPerAttributes) ))
                _currentNbPointsInBuffer = 0;   // We add new points remplacing the oldest in buffer

            for (var p = 0; p < byteArray.length - nbAttributes; p = p + nbAttributes) { // P+4 cause x,y,z,i in bin

                var p1 = Cartography.convertCoord({x: byteArray[p], y: byteArray[p + 2]}, projection1, projection2);
                var pX = p1.x - pivot.x,
                    pY = byteArray[p + 1] - pivot.y,
                    pZ = p1.y - pivot.z;  // Decalage laser/cam
                // Intensity default    
                if (nbAttributes > 3)
                    pI = byteArray[p + 3] / 255;
                else
                    pI = 0.6 + Math.abs(pY / 80);

                positions[ _currentNbPointsInBuffer * 3 + 0 ] = pX;
                positions[ _currentNbPointsInBuffer * 3 + 1 ] = pY;
                positions[ _currentNbPointsInBuffer * 3 + 2 ] = pZ;

                color2.setHSL(pI, 0.5, 0.8);
                values_color[ _currentNbPointsInBuffer * 3 + 0] = color2.r;
                values_color[ _currentNbPointsInBuffer * 3 + 1] = color2.g;
                values_color[ _currentNbPointsInBuffer * 3 + 2] = color2.b;

                uniqueids[ _currentNbPointsInBuffer ] = this.indiceLaserFileLoaded;

                // Then for the picking ***********************
                var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                var nbZerosMissing = 6 - colorHexFromInt.length;
                for (var i = 0; i < nbZerosMissing; ++i) {
                    colorHexFromInt = '0' + colorHexFromInt;
                }
                var colorHex = '#' + colorHexFromInt;
                _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                var vectorPoint = new THREE.Vector3(pX, pY, pZ); //particle
                _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = vectorPoint;
                //******************

                _currentNbPointsInBuffer++;
            }

            _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;

           this.updateLaserAttributes();
            _geometryParticleSystemPicking.verticesNeedUpdate = true;
            _geometryParticleSystemPicking.colorsNeedUpdate = true;

            _indiceTimeLaser = 0.5;
            if(!this.animateOn){this.animateOn = true; this.animatePoints2();}  // First file
            // start animation function
            this.indiceLaserFileLoaded++;
            // Load the next file in the list if not last (seems faster than parallel load)
            if (this.indiceLaserFileLoaded < this.tabLaserFilesToLoad.length)
                this.readLaserPointsFileFromItownsBINARY(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded]);
        },
    
       
        readLaserPointsFileFromItownsBINARY: function(fileName) {

            var self = this;
            var xhr = new XMLHttpRequest();

            xhr.onreadystatechange = function() {  // Asynch version	
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        var buffer = xhr.response;
                        //self.loadLaserBuffer(buffer);
                        //self.addPointsToBuffer(buffer);
                        self.addPointsToBufferIGN(buffer, 4, 64, _zero);  //4 attributes 64bits with pivot _zero
                            } else {  
                                    console.log("Error", xhr.statusText);  
                                    self.indiceLaserFileLoaded++;
                                    self.readLaserPointsFileFromItownsBINARY( self.tabLaserFilesToLoad[ self.indiceLaserFileLoaded],nbBitsPerAttribute,pivot);
                            }  
                    }  
            }
            xhr.open("GET", _dataURL + fileName, true);//, "login", "pass");  //98_88.bin
            xhr.responseType = 'arraybuffer';
            xhr.send(null);	
       },
       
       
       readLaserPointsFileFromItownsGeneric: function(fileName,nbBitsPerAttribute,pivot){

            var self = this;
            var xhr = new XMLHttpRequest();            
            var zero = gfxEngine.getZero();

            xhr.onreadystatechange = function () {  // Asynch version	
                    if (xhr.readyState === 4) {  
                            if (xhr.status === 200) {  	
                                    var buffer = xhr.response;	
                                    //self.loadLaserBuffer(buffer);
                                    //self.addPointsToBuffer(buffer);
                                    self.addPointsToBufferGeneric(buffer,4,nbBitsPerAttribute,pivot);  //4 attributes of nbBitsPerAttribute bits with pivot _zero
                    } else {
                                   // console.log("Error", xhr.statusText);
                                    self.indiceLaserFileLoaded++;
                                    if(self.indiceLaserFileLoaded < self.tabLaserFilesToLoad.length)
                                        self.readLaserPointsFileFromItownsGeneric(self.tabLaserFilesToLoad[self.indiceLaserFileLoaded],32,
                                                                                  {x:zero.x - _currentLaserPivot.x,
                                                                                   y:zero.y - _currentLaserPivot.y,
                                                                                   z:zero.z - _currentLaserPivot.z});
                    }
                }
            }
            
            var urlRequest = _localURL ? (_dataURL + fileName.substring(fileName.indexOf("/") + 1) ) : _dataURL + fileName;
            xhr.open("GET", urlRequest, true);//,  "login", "pass");  //98_88.bin
            xhr.responseType = 'arraybuffer';
            xhr.send(null);
        },
        
        
        readLaserPointsFileFromItownsGenericMesh: function(fileName,nbBitsPerAttribute,pivot){

            var self = this;
            var xhr = new XMLHttpRequest();            
            var zero = gfxEngine.getZero();

            xhr.onreadystatechange = function () {  // Asynch version	
                    if (xhr.readyState === 4) {  
                            if (xhr.status === 200) {  	
                                    var buffer = xhr.response;	
                                    //self.loadLaserBuffer(buffer);
                                    //self.addPointsToBuffer(buffer);
                                    self.addPointsToBufferGenericMesh(buffer,4,nbBitsPerAttribute,pivot);  //4 attributes of nbBitsPerAttribute bits with pivot _zero
                    } else {
                                   // console.log("Error", xhr.statusText);
                                    self.indiceLaserFileLoaded++;
                                    if(self.indiceLaserFileLoaded < self.tabLaserFilesToLoad.length)
                                        self.readLaserPointsFileFromItownsGenericMesh(self.tabLaserFilesToLoad[self.indiceLaserFileLoaded],32,
                                                                                  {x:zero.x - _currentLaserPivot.x,
                                                                                   y:zero.y - _currentLaserPivot.y,
                                                                                   z:zero.z - _currentLaserPivot.z});
                    }
                }
            }
            xhr.open("GET", _dataURL + fileName, true);//,  "login", "pass");  //98_88.bin
            xhr.responseType = 'arraybuffer';
            xhr.send(null);
        },
       
        readLaserFileLocalBINARY: function(buffer, nbAttributes, nbBitsPerAttribute, pivot) {

            this.addPointsToBufferGeneric(buffer, nbAttributes, nbBitsPerAttribute, pivot);
            // this.addPointsToBufferIGN(buffer,nbAttributes,nbBitsPerAttribute,pivot);
        },
        readLaserFileLocalBINARYWithConversion: function(buffer, nbAttributes, nbBitsPerAttribute, pivot, projection1, projection2) {

            this.addPointsToBufferGenericWithConversion(buffer, nbAttributes, nbBitsPerAttribute, pivot, projection1, projection2);
        },
        
        
        // Empty laser buffer totally, for example when jumping to a new pivot
        emptyBuffer: function(){
            console.log('emptyBuffer');
            //this.tabLaserFilesToLoad = [];
            this.initializeBufferValues();
            //_bufferGeometry.attributes.position.array = new Float32Array(_nbPointsBuffer * 3);
            this.updateLaserAttributes();
        },
       
       
        // MAIN LOADING FUNCTION
        launchLaserAroundCurrentTime: function(duration, laserNum) {
            
            _notLoaded = false;   // Means if no movement we won t have to load again when visibility gets back on
            var hours = Panoramic.getPanoHours();
            var seconds = Panoramic.getPanoSecondsInHour();
            var datee = Panoramic.getPanoDate();
            var name = Panoramic.getPanoName();
            var decalageUTC = Panoramic.getDecalageUTC();
            //console.log("laser",seconds-decalageUTC);
            console.log("laser",name, datee, laserNum, hours, seconds, duration);
            if(name.substr(0, 8) == "Paris_12")// Keep functioning for OLD RIEGL
                this.launchLoadingFromSecondsIT(datee, laserNum, hours, seconds-decalageUTC, duration);
            else {           //NEW RIEGL
                 var prefix = name.substr(0, 5);
                if(prefix == "TerMo") _currentLaserPivot = _pivotParis6;
                   else 
                if(prefix == "Nante") _currentLaserPivot = _pivotNantes;
                   else
                if(prefix == "Halag") _currentLaserPivot = _pivotNantesHalage;
                    else
                if(prefix == "CASQY") _currentLaserPivot = _pivotCasqy; 
                    else
                if(prefix == "Toulo") _currentLaserPivot = _pivotToulouse;
                    else
                if(prefix == "Auril") _currentLaserPivot = _pivotAurillac;
                    else
                if(prefix == "Champ") _currentLaserPivot = _pivotChampigny;
                    else        
                if(name.substr(0, 10) == "Paris-1405" || prefix == "Basti" || prefix == "Calib" || name.substr(0, 10) == "Paris-1404" || name.substr(0, 10) == "Paris-1406")  _currentLaserPivot = _pivotParis2014Louvre;
                        
            
                var datee = name.substr(name.indexOf('-')+1,6)
               
                this.launchLaserNewRieglLOD(datee,hours,seconds - decalageUTC,duration/6);
            }

        },
        
        launchLoadingFromSecondsIT: function(datee, laserNum, hour, seconds, duration) {
            
            var zero = gfxEngine.getZero();
            laserNum = 10;
            var second = parseInt(seconds);
            for (var i = parseInt(second - duration / 2); i < parseInt(second + duration / 2); ++i) {

                var fileName = "laser3/" + datee + "/" + hour + "/" + laserNum + "_" + i + ".bin";
                if (($.inArray(fileName, this.tabLaserFilesToLoad) === -1))
                    this.tabLaserFilesToLoad.push(fileName);
            }

            // Then we launch the first file that after loaded will ask the next file etc.  FIFO
            //this.readLaserPointsFileFromItownsBINARY(this.tabLaserFilesToLoad[0],64,_zero);
            this.readLaserPointsFileFromItownsBINARY(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded],64,zero);
        },
        
        
        //Test with riegl360
        launchLaserNewRiegl: function(datee,hours,seconds,duration){

           // duration /=2;
            var decalage = 3;
            var zero = gfxEngine.getZero();
            
            //this.tabLaserFilesToLoad = [];
            var second = hours * 3600 + seconds + decalage;
            for(var i = parseInt(second - duration/2) * 10 ; i< parseInt(second + duration/2) * 10 ; ++i){

                var fileName = "laserNewRiegl/"+datee+"/"+i+".bin";
                if(($.inArray(fileName, this.tabLaserFilesToLoad)=== -1)) 
                     this.tabLaserFilesToLoad.push(fileName);
            }
            this.readLaserPointsFileFromItownsGeneric(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded],32,
                                                                                  {x:zero.x - _currentLaserPivot.x,
                                                                                   y:zero.y - _currentLaserPivot.y,
                                                                                   z:zero.z - _currentLaserPivot.z});
        },
        
           
        // Test with riegl360 with 2 level of definitions
        launchLaserNewRieglLOD: function(datee,hours,seconds,duration){

           // duration /=2;
            var decalage = 3;
            var zero = gfxEngine.getZero();
            
            //this.tabLaserFilesToLoad = [];
            var second = 3600 * hours + seconds;// + decalage;
            var fileNameMin="", fileNameMax="";
            
            // Empty files to load (temp)
            this.tabLaserFilesToLoad = [];
            this.indiceLaserFileLoaded = 0;
    
            //LR
            for(var i = 0 ; i< 1 * duration  ; i+=0.1){
                
                var nummin = (second - i) * 10;
                var nummax = (second + i) * 10;
                fileNameMin = "laserNewRiegl/"+datee+"/LR/"+nummin+".bin";
                fileNameMax = "laserNewRiegl/"+datee+"/LR/"+nummax+".bin";
                
                var posMin = $.inArray(fileNameMin, this.tabLaserFilesToLoad);
                var posMax = $.inArray(fileNameMax, this.tabLaserFilesToLoad);
                
                if( (posMin === -1) || (this.tabLaserFilesToLoad.length - posMin> 20) ) 
                     this.tabLaserFilesToLoad.push(fileNameMin);
                if( i>0 && ((posMax === -1) || (this.tabLaserFilesToLoad.length - posMax> 20)) ) 
                     this.tabLaserFilesToLoad.push(fileNameMax);
            }
            
            
            // HR
            for(var i = 0 ; i< 1*duration ; i+=0.1){
                
                var nummin = (second - i) * 10;
                var nummax = (second + i) * 10;
                fileNameMin = "laserNewRiegl/"+datee+"/HR/"+nummin+".bin";
                fileNameMax = "laserNewRiegl/"+datee+"/HR/"+nummax+".bin";
                
                var posMin = $.inArray(fileNameMin, this.tabLaserFilesToLoad);
                var posMax = $.inArray(fileNameMax, this.tabLaserFilesToLoad);
                
                if( (posMin === -1) || (this.tabLaserFilesToLoad.length - posMin> 20) ) 
                     this.tabLaserFilesToLoad.push(fileNameMin);
                if( i>0 && ((posMax === -1) || (this.tabLaserFilesToLoad.length - posMax> 20)) ) 
                     this.tabLaserFilesToLoad.push(fileNameMax);
            }
            
       
            //  console.log(this.tabLaserFilesToLoad);
            if(this.indiceLaserFileLoaded < this.tabLaserFilesToLoad.length)
                 this.readLaserPointsFileFromItownsGeneric(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded],32,
                                                                                  {x:zero.x - _currentLaserPivot.x,
                                                                                   y:zero.y - _currentLaserPivot.y,
                                                                                   z:zero.z - _currentLaserPivot.z});
          
        },
             
             
        testLaserAngular: function(){
            console.log('test Angular');
             //LR
            var duration = 130;
            var datee = "131010";
            var zero = gfxEngine.getZero();
            
            //this.tabLaserFilesToLoad = [];
            var second = 46087;// + decalage;
            var fileNameMin="", fileNameMax="";
            
            for(var i = 0 ; i< 2 * duration  ; i+=0.1){
                
                var nummin = (second - i) * 10;
                var nummax = (second + i) * 10;
                fileNameMin = "laserNewRiegl/"+datee+"/LRAngular/"+nummin+".bin";
                fileNameMax = "laserNewRiegl/"+datee+"/LRAngular/"+nummax+".bin";
                
                var posMin = $.inArray(fileNameMin, this.tabLaserFilesToLoad);
                var posMax = $.inArray(fileNameMax, this.tabLaserFilesToLoad);
                
                if( (posMin === -1) || (this.tabLaserFilesToLoad.length - posMin> 200) ) 
                     this.tabLaserFilesToLoad.push(fileNameMin);
       //         if( i>0 && ((posMax === -1) || (this.tabLaserFilesToLoad.length - posMax> 200)) ) 
        //             this.tabLaserFilesToLoad.push(fileNameMax);
            }
            
             this.readLaserPointsFileFromItownsGenericMesh(this.tabLaserFilesToLoad[this.indiceLaserFileLoaded],32,
                                                                                  {x:zero.x - _currentLaserPivot.x,
                                                                                   y:zero.y - _currentLaserPivot.y,
                                                                                   z:zero.z - _currentLaserPivot.z});
        },
        
        
        // LAS lidar file loading function
        loadLasFile: function (filename,pivot){


                 var self = this;
                 var xhr = new XMLHttpRequest();            
                 var zero = gfxEngine.getZero();
                 // 43.11575365753033, y: 54.760090470367814, z: 5.807350948914382
                 
                 xhr.onreadystatechange = function () {  // Asynch version	
                         if (xhr.readyState === 4) {  
                                 if (xhr.status === 200) {  	
                                         var buffer = xhr.response;	
                                         self.addLasPointsToBuffer(buffer,pivot);  //4 attributes of nbBitsPerAttribute bits with pivot _zero
                                 }
                     }
                 }
                 xhr.open("GET", "http://www.itowns.fr/nokiaHere/lidar/" + filename, true);  //98_88.bin
                 xhr.responseType = 'arraybuffer';
                 xhr.send(null);


        },
        
        // LAS point cloud
        addLasPointsToBuffer: function(buffer,pivot){
            
             var lasObj = new LasReader.LasReader(buffer);
             console.log("lasOBJ: ",lasObj);
             
             
                var positions =    _bufferGeometry.attributes.position.array;
                var values_color = _bufferGeometry.attributes.color.array;
                var uniqueids =    _bufferGeometry.attributes.uniqueid.array;

                var color2 = new THREE.Color();
                var pX,pY,pZ,pI,ind;         

             var geo = new THREE.Geometry();       
             var LasReaderObject = lasObj;
             var projItowns = new OpenLayers.Projection("EPSG:2154");
             var projLAS = new OpenLayers.Projection("EPSG:4326");  // nokia las wgs84
             
             for (var p=0; p< LasReaderObject.header.numberOfPointRecords; p++) {

                    var lasPoint = LasReaderObject.getPointData(p);
                        
                    var vec = new THREE.Vector3((LasReaderObject.header.YScaleFactor * lasPoint.Y*1.0) + LasReaderObject.header.YOffset,
                                                (LasReaderObject.header.ZScaleFactor * lasPoint.Z*1.0) + LasReaderObject.header.ZOffset ,
                                                (LasReaderObject.header.XScaleFactor * lasPoint.X*1.0) + LasReaderObject.header.XOffset);//.applyMatrix4(transformMatrix);    
                                                

                     
                 //       var p1 = Cartography.convertCoord({y: vec.x, x: vec.z}, "EPSG:4326","EPSG:2154");  // 4326 for wgs84 ! 
                        var p1 = new OpenLayers.Geometry.Point(vec.z, vec.x);
                        p1 = p1.transform(projLAS, projItowns);
                                                       
                        p1.x -= pivot.x;
                        p1.y -= pivot.z;
                        vec.y -= pivot.y + 0.6;  // 0.6 bias SUPPOSED ellipsoid conversion or nokia forgot to mention??
                        
                        if ( p<10) {
                            console.log(vec.x,vec.z,vec.y,p1);
                        }   
                        ind = _currentNbPointsInBuffer * 3;
                                                    
                        positions[ ind + 0 ] = p1.x;
                        positions[ ind + 1 ] = vec.y;
                        positions[ ind + 2 ] = p1.y;

                        color2.setHSL(0.5,0.5,0.8);
                        values_color[ ind + 0] = color2.r;
                        values_color[ ind + 1] = color2.g;
                        values_color[ ind + 2] = color2.b;

                        uniqueids[ _currentNbPointsInBuffer ] = this.indicePacketInBuffer;

                        // Then for the picking ***********************
                        var colorHexFromInt = _currentNbPointsInBuffer.toString(16);
                        var nbZerosMissing = 6 - colorHexFromInt.length;
                        for (var i=0; i< nbZerosMissing; ++i){ colorHexFromInt = '0' + colorHexFromInt;}
                        var colorHex = '#'+colorHexFromInt;
                        _colorsPicking[_currentNbPointsInBuffer] = new THREE.Color(colorHex);
                        _geometryParticleSystemPicking.vertices[_currentNbPointsInBuffer] = new THREE.Vector3(p1.x, vec.y, p1.y);

                        _currentNbPointsInBuffer++;

                        geo.vertices.push(vec);
            }
            

          _shaderUniforms.currentidwork.value = this.indiceLaserFileLoaded;
          _indice_time_laser_tab[this.indicePacketInBuffer] = 0.15;

          this.setLockMovement(0);
          console.log('nb points LAS: ',LasReaderObject.header.numberOfPointRecords);
          this.updateLaserAttributes();
          //this.updateLaserAttributesSmartly(LasReaderObject.header.numberOfPointRecords);//offset); 

          _indiceTimeLaser = 0.5;                    
          if(!this.animateOn){this.animateOn = true; this.animatePoints2(); /*console.log('thisanimate');*/}  // First file
                                                                                    // start animation function
          this.indiceLaserFileLoaded++;// console.log(_currentNbPointsInBuffer);
          this.indicePacketInBuffer++;
            
            geo.las = LasReaderObject;
        },
       
        
        processEvent: function(event) {
            if (_events[event]) {
                _events[event]();
            }
        },
        setReverseMotion: function(b) {
            _indiceTimeLaser = 0.5;//_reverseMotion = b;
        },
        setPointSize: function(newValue) {
            if (this.initiated)
                _particleSystem.material.uniforms['point_size'].value = newValue;
        },
        changeVisibility: function() {
            if (this.initiated)
                _particleSystem.visible = !_particleSystem.visible;
        },
        setVisibility: function(b) {
            if (this.initiated)
                _particleSystem.visible = b;
        },
        changeAlpha: function(val) {
            if (this.initiated)
                _particleSystem.material.uniforms['alpha'].value = val;
        },
     /*
        getXYZFromClick2D: function(mouseX, mouseY) {

            var arr = new Uint8Array(4);//(wi * he * 4);
            //console.log(gfxEngine.getWinHeight(), mouseY,gfxEngine.getWinHeight() - mouseY );
            gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});
            ctx.readPixels(mouseX, gfxEngine.getWinHeight() - mouseY, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);    // ATTENTION sens inverse pour les Y lors du readPixels
            
            var r = arr[0];
            var g = arr[1];
            var b = arr[2];
      //      console.log(r,g, b);
            var posXYZ = new THREE.Vector3(-1, -1, -1);
            if (!(r === 255 && g === 255 && b === 255)) {
                var colorClicked = new THREE.Color();
                colorClicked.setRGB(r / 255, g / 255, b / 255);
                posXYZ = this.findXYZFromColorID(colorClicked.getHex());
            }
           
            return posXYZ;
        },
    */
                // Function that finds the best 3D position under the mouse using the pointCloud
         getXYZFromClick2D: function(mouseX, mouseY, radius) {
             
            var arrayNeighbours = []; // Arrray of points (vec3) close to click (from projected view...)
            var zero = gfxEngine.getZero();
            var radius = radius || 170;
            var arr = new Uint8Array(radius*radius*4);//(wi * he * 4);
            gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});
            ctx.readPixels(mouseX - radius/2, gfxEngine.getWinHeight() - mouseY - radius/2 , radius, radius, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);    // ATTENTION sens inverse pour les Y lors du readPixels

            var min = 1000;
            var colorClicked = new THREE.Color();
            var posXYZ = new THREE.Vector3(-1, -1, -1);
            var arrCoord2D = []; // array containing 2D coords of point in projectiv coord
            var arrCoord3D = [];
            //var distFromCenter = [];  // array containing dist from center (mouse click) in 2D of the points
            var indiceClosestPointFromClick = 0;
    
            for(var a=0; a<arr.length - 4; a+=4){
                 
                // Coordinates in texture crop  (mouse coord in texture crop is (radius/2, radius/2)) 
                var i = (a/4) % radius;
                var j = (a/4) / radius;
                
                var r = arr[a];
                var g = arr[a+1];
                var b = arr[a+2];
                
                if (!(r == 0 && g == 0 && b == 0)){   // Color of scene background, SHOULD BE A PARAMETER, not always black
                    arrCoord2D.push(new THREE.Vector2(i,j)); 
                    var colorClicked = new THREE.Color();
                    colorClicked.setRGB(r / 255, g / 255, b / 255);
                    posXYZ = this.findXYZFromColorID(colorClicked.getHex());
                    arrCoord3D.push(posXYZ);
                    var distFromClick  = Math.sqrt( (i - radius/2) * (i - radius/2) + (j - radius/2) * (j - radius/2));
                    //distFromCenter.push(distFromClick); 
                    if(distFromClick < min){ min = distFromClick; indiceClosestPointFromClick = arrCoord2D.length - 1;}
                }
            }

            // Draw.drawSphereAt(arrCoord3D[indiceClosestPointFromClick],0.05);
            // Then get best 3D points representing neighbour and then normal
            var norm = this.getBestRepresentingNormalFrom(arrCoord3D,indiceClosestPointFromClick) || new THREE.Vector3();
            
            // Create plane at position with normal for intersection with ray
            if(!this.planeLocal){
                var geomPlane = new THREE.PlaneGeometry(2, 2, 1);
                this.planeLocal= new THREE.Mesh(geomPlane, new THREE.MeshBasicMaterial({side:THREE.DoubleSide,color:0xff00ff, transparent:true,opacity:0.3}));
                gfxEngine.addToScene(this.planeLocal); this.planeLocal.visible = false;
            }
            this.planeLocal.position = arrCoord3D[indiceClosestPointFromClick]; //console.log("plane position: ", this.planeLocal.position);
            
            // Orient plane
            var vec = norm.clone();
            var up = new THREE.Vector3(0, 0, 1);  //(0,1,0);
            var axis = new THREE.Vector3().crossVectors(up, vec);
            if (vec.y === 1 || vec.y === -1) {
                axis = new THREE.Vector3(1, 0, 0);
            }

            var radians = Math.acos(vec.dot(up));
            var mat = new THREE.Matrix4();
            mat = Utils.rotateByAxis( mat,axis, radians);
            this.planeLocal.rotation.setFromRotationMatrix(mat);
             // ! Needs a rendering pass (matrix world update? weird)
            gfxEngine.renderOnce();
            // Compute intersection with plane
            var objArray = gfxEngine.getIntersected(mouseX, mouseY, [this.planeLocal]);
          //  console.log(mouseX,mouseY);
            if (objArray[0]) {
                    var p = objArray[0].point; // Pos 3D intersected
                    posXYZ = p;
             }

            return posXYZ; //this.getBest3DposFromArray(mouseX, mouseY, arrayNeighbours); //arrayNeighbours;
        },
        
        
        // Option: indiceClosestPointFromClick specifi the base of plane
        getBestRepresentingNormalFrom: function(arrayPoints,indiceClosestPointFromClick){
            
            var a,b,c = null;
            var a = indiceClosestPointFromClick != undefined ? arrayPoints[indiceClosestPointFromClick] : arrayPoints[0];
            var i = 0;
            while (!c && i< arrayPoints.length){
                
                var v = arrayPoints[i];
                if(!b){
                    if (Math.abs(v.x - a.x) >=0.04) b = v;
                }
                else{
                    if (Math.abs(v.z - b.z) >=0.04) c = v;}

                i++;
            }
            
            if(c) return this.computeNormalFrom3Points(a,b,c,false);  // bool to draw normal and surface
            
        },
        
        // We have the 3D points neighbours of the clic we need to find the best 3D pos under mouse
        // reconstructing a surface and intersecting with clic-cam ray
        getBest3DposFromArray: function(mouseX,mouseY, arrPos){
            
            var min = 100;
            
            for(var i=0; i<arrPos.length; ++i){
                
                var dist = arrPos;
            }
        },
      
        
        
        // PREVIOUSLY  getNeighboursXYZFromClick2D (look vertical objects)
        getMaxVerticalAccumulationPoint: function(mouseX, mouseY) {
            
            var arrayNeighbours = this.getNeighboursXYZFromClick2D(mouseX, mouseY,40);
            var posAndCoef = this.analyzeShapeFromNeighbours(arrayNeighbours);
            
            return posAndCoef;
        },
        
        // Return arrray of points (vec3) close to click (from projeted view...)
         getNeighboursXYZFromClick2D: function(mouseX, mouseY, radius) {
             
            var arrayNeighbours = []; 
            var zero = gfxEngine.getZero();
            var radius = radius || 40 ;
            var arr = new Uint8Array(radius*radius*4);//(wi * he * 4);
            gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});
            ctx.readPixels(mouseX - radius/2, gfxEngine.getWinHeight() - mouseY - radius/2 , radius, radius, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);    // ATTENTION sens inverse pour les Y lors du readPixels

            for(var i=0; i<arr.length - 4; i+=4){
                var r = arr[i];
                var g = arr[i+1];
                var b = arr[i+2];
                
                if (!(r == 0 && g == 0 && b == 0)) {
                    var colorClicked = new THREE.Color();
                    colorClicked.setRGB(r / 255, g / 255, b / 255);
                    var posXYZ = this.findXYZFromColorID(colorClicked.getHex());
                    arrayNeighbours.push(posXYZ);
                }
                //console.log(r,g,b);
            }
            
            return arrayNeighbours;
        },
        
        
        // arrayPoints is array of vec3, around click
        // look for vertical structure
        analyzeShapeFromNeighbours: function(arrayPoints) {
            
          //  console.log(arrayPoints.length);
            var l = arrayPoints.length;
            //var tabAccu = new Array(l);
            var tabAccu = []; tabAccu.length = l;
            var maxAccu = 0;
            var indiceMaxAccu = -1;
            var seuil = 0.08;
            for (var i=0; i< arrayPoints.length; ++i){
                
                var currentPoint = arrayPoints[i]; 
                for (var j=0; j< arrayPoints.length; ++j){
                
                    var dist = Math.sqrt( (currentPoint.x - arrayPoints[j].x) *(currentPoint.x - arrayPoints[j].x) + 
                                          (currentPoint.z - arrayPoints[j].z) *(currentPoint.z - arrayPoints[j].z));
                 
                    if (dist < seuil){
                      
                        if(tabAccu[i] == undefined) tabAccu[i] = 0; else tabAccu[i]++;
                        if(tabAccu[i]>maxAccu){maxAccu = tabAccu[i]; indiceMaxAccu = i;}
                    }                     
                                              
                 }
                
            }
            
            return {pos:arrayPoints[indiceMaxAccu],note:maxAccu};          
        },
        
        
        
        extractPointsFromPCA : function(pca, opt){
           var ret = [], coff = 2;
               ret.push(pca.m);
               Draw.drawSphereAt(new THREE.Vector3(ret[ret.length-1][0],ret[ret.length-1][1],ret[ret.length-1][2]),0.03);
           for(var i = 1; i < opt.num; i++){
                    if(ret.length === opt.num) return ret;    
                    var variance = [0,0,0];
                        variance[0] = i*coff*Math.sqrt(pca.pca.S[0]);
                        variance[2] = i*coff*Math.sqrt(pca.pca.S[2]);
                    var delta = CVML.dotMV(pca.pca.U, variance);
                     //console.log(delta);
                     ret.push(CVML.addVec(pca.m,delta));
                     Draw.drawSphereAt(new THREE.Vector3(ret[ret.length-1][0],ret[ret.length-1][1],ret[ret.length-1][2]),0.03);
                     if(opt.bidirectional){
                         if(ret.length === opt.num) return ret;
                         ret.push(CVML.subVec(pca.m,delta));
                         Draw.drawSphereAt(new THREE.Vector3(ret[ret.length-1][0],ret[ret.length-1][1],ret[ret.length-1][2]),0.03);
                         
                     }
           }
        },        
        
        computeNormalPointCloud : function(arrP, indP){
            var arr = [];
            var mX = 0, mY = 0, mZ =0;
            for(var i= 0; i< indP.length; i++){
                    arr.push([arrP[indP[i]].x,arrP[indP[i]].y,arrP[indP[i]].z]);
                    mX += arrP[indP[i]].x;
                    mY += arrP[indP[i]].y;
                    mZ += arrP[indP[i]].z;
            }
            var mPt = [mX/indP.length,mY/indP.length,mZ/indP.length];
            var pca = CVML.pca(arr,mPt);
            return {pca:pca,m:mPt};
        },        
                
        
        fitLineToNeighboursPointFromClick: function(mouseX, mouseY) {

            var arrayNeighbours2D = [];
            var arrayNeighbours3D = [];
            var radius1 = 40;
            var radius2 = 120;
            
            var arr = new Uint8Array(radius1*radius2*4);//(wi * he * 4);
                gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});

            ctx.readPixels(mouseX - radius2/2, gfxEngine.getWinHeight() - mouseY - radius1/2 , radius2, radius1, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);
            var lr = 0, lg = 0, lb = 0;
            for(var i=0; i<arr.length - 4; i+=4){
                var r = arr[i];
                var g = arr[i+1];
                var b = arr[i+2];
                 
                if (!(r === 0 && g === 0 && b === 0)&&!(r === lr && g === lg && b === lb)) {
                    var colorClicked = new THREE.Color();
                        colorClicked.setRGB(r / 255, g / 255, b / 255);
                    var posXYZ = this.findXYZFromColorID(colorClicked.getHex());
                    arrayNeighbours3D.push(posXYZ);
                    arrayNeighbours2D.push(new CVML.Point2D(posXYZ.x,posXYZ.z));
                }
                lr = r, lg = g, lb = b;
            }            
            
            //console.log(arrayNeighbours3D);
            //Draw.drawArrPoints(arrayNeighbours3D);
            var ret = CVML.RobustLineFitting(arrayNeighbours2D, 0.03);
            var pca = this.computeNormalPointCloud(arrayNeighbours3D,ret.inliers);
            var opt = {num:4, bidirectional:false};
            this.extractPointsFromPCA(pca,opt); 
            
            if(this.IsComputeNormalOn()){
                    Draw.drawArrPoints(arrayNeighbours3D);
                    Draw.drawInliersPoints(arrayNeighbours3D,ret.inliers);
            } 
        },
        
         
         getNeighboursReflectanceFromClick2D: function(mouseX, mouseY) {
             
            var arrayNeighbours = []; 
            var arrayRGB = [];
            var zero = gfxEngine.getZero();
            var radius = 40;
            var arr = new Uint8Array(radius*radius*4);//(wi * he * 4);
            gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});
            ctx.readPixels(mouseX - radius/2, gfxEngine.getWinHeight() - mouseY - radius/2 , radius, radius, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);    // ATTENTION sens inverse pour les Y lors du readPixels

            for(var i=0; i<arr.length - 4; i+=4){
                var r = arr[i];
                var g = arr[i+1];
                var b = arr[i+2];
                
                if (!(r == 0 && g == 0 && b == 0)) {
                    var colorClicked = new THREE.Color();
                    colorClicked.setRGB(r / 255, g / 255, b / 255);
                    var posXYZ = this.findXYZFromColorID(colorClicked.getHex());
                    arrayNeighbours.push(posXYZ);
                    
                    var rgb = this.findReflectanceFromColorID(colorClicked.getHex());
                    arrayRGB.push(rgb);
                    
                    
                }
                //console.log(r,g,b);
                
            }
            
             var posAndCoef = this.analyzeShapeFromNeighbours(arrayNeighbours);
            // console.log(vec3);
           
            return posAndCoef;
        },
        
        
        
        getZebraFromClick2D: function(mouseX, mouseY) {
            
            var zero = gfxEngine.getZero();
            var arr = new Uint8Array(4);//(wi * he * 4);
            gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});
            ctx.readPixels(mouseX, gfxEngine.getWinHeight() - mouseY, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);    // ATTENTION sens inverse pour les Y lors du readPixels

            var r = arr[0];
            var g = arr[1];
            var b = arr[2];

            var posXYZ = new THREE.Vector3(-1, -1, -1);
            if (!(r == 0 && g == 0 && b == 0)) {
                
                 // POS
                var colorClicked = new THREE.Color();
                colorClicked.setRGB(r / 255, g / 255, b / 255);
                posXYZ = this.findXYZFromColorID(colorClicked.getHex());
                
                // REFLECTANCE
                var rgb = this.findReflectanceFromColorID(colorClicked.getHex());
                
                // Analyze
                //var indice = colorClicked.getHex() * 3;
                this.analyzeRegionOnReflectance(rgb,posXYZ);
                console.log(rgb);
            }
            
            return posXYZ;
        },
        
        
        
        analyzeRegionOnReflectance: function(rgb,pos){
            
             var arraySeg = [];
             for (var i = 0; i < _currentNbPointsInBuffer; ++i) {

                var point = new THREE.Vector3(_bufferGeometry.attributes.position.array[i * 3    ],
                                              _bufferGeometry.attributes.position.array[i * 3 + 1],
                                              _bufferGeometry.attributes.position.array[i * 3 + 2]);
                        
                var color   = new THREE.Vector3(_bufferGeometry.attributes.color.array[i * 3    ],
                                                _bufferGeometry.attributes.color.array[i * 3 + 1],
                                                _bufferGeometry.attributes.color.array[i * 3 + 2]);  
                                              
                if (point.distanceTo(pos) <  0.15 ){
                    if( Math.abs(rgb.z - color.z) <0.03 && Math.abs(rgb.y - color.y) <0.03 && Math.abs(pos.y - point.y) <0.25){
                        this.colorizePointAtPos(i,new THREE.Vector3(1,1,1));
                        arraySeg.push(point);
                        // PUT UP
                        // _bufferGeometry.attributes.position.array[i * 3 + 1] += 1;
                    }
                }                        
                                              
             }
             
             var arrCorners = this.extractCorners(arraySeg);
             for(var a=0; a<arrCorners.length; ++a){
                 Draw.drawSphereAt(arrCorners[a],0.05); 
             }
             //_bufferGeometry.attributes.color.needsUpdate = true;
             this.updateLaserAttributes();
        },
        
        
        findXYZFromColorID: function(hex) {

            var pos = new THREE.Vector3(0, 0, 0);
            var indice = hex * 3;
            pos = new THREE.Vector3(_bufferGeometry.attributes.position.array[indice],
                        _bufferGeometry.attributes.position.array[indice + 1],
                        _bufferGeometry.attributes.position.array[indice + 2]);
                       // console.log(hex,pos);
            return pos;
        },
        

    
        findReflectanceFromColorID: function(hex) {

            var rgb = new THREE.Vector3(0, 0, 0);
            var indice = hex * 3;
            rgb = new THREE.Vector3(_bufferGeometry.attributes.color.array[indice],
                        _bufferGeometry.attributes.color.array[indice + 1],
                        _bufferGeometry.attributes.color.array[indice + 2]);

            return rgb;
        },
        
        colorizePointAtPos: function(pos,rgb){
            
            _bufferGeometry.attributes.color.array[pos *3   ] = rgb.x;
            _bufferGeometry.attributes.color.array[pos *3+ 1] = rgb.y;
            _bufferGeometry.attributes.color.array[pos *3+ 2] = rgb.z;            
            _bufferGeometry.attributes.color.needsUpdate = true; 
        },

        
        // Look if points are corners
        extractCorners: function(arr){
            
            var arrCorners = [];
            for (var i = 0; i < arr.length; ++i) {
                
                var p = arr[i];
                var cL = true; var cR = true; var cU = true; var cD = true;
                var j = 0;
                while ( (cL == true || cR == true || cU ==true || cD==true) && j< arr.length ){
                    var p1 = arr[j];
                    if( p.distanceTo(p1) <  0.15 ){   // Look in the point close neighbourhood
                        
                        cL = p1.x >= p.x && cL;
                        cR = p1.x <= p.x && cR;
                        cU = p1.z <= p.z && cU;
                        cD = p1.z >= p.z && cD;     
                    }
                    
                    j++;
                }
                
                if (cL == true || cR == true || cU ==true || cD==true){
                    arrCorners.push(p);
                }
               
            }
        
            console.log(arr.length);
            console.log(arrCorners.length);
            return  arrCorners;
        },
        
        
        // TEMP for PMR module, estimate slope Using local points
         estimateSlope: function(mouseX, mouseY, radius) {
            //var arrPoints = this.getNeighboursXYZFromClick2D(mouseX, mouseY, 40);
           // console.log(arrPoints);
            var arrayNeighbours = []; 
            var zero = gfxEngine.getZero();
            var radius = radius || 32 ;
            var arr = new Uint8Array(radius*radius*4);//(wi * he * 4);
            gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});
            ctx.readPixels(mouseX - radius/2, gfxEngine.getWinHeight() - mouseY - radius/2 , radius, radius, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);    // ATTENTION sens inverse pour les Y lors du readPixels

            for(var i=0; i<arr.length - 4; i+=4){
                
                var r = arr[i];
                var g = arr[i+1];
                var b = arr[i+2];
                
                if (!(r == 0 && g == 0 && b == 0)) {
                    var colorClicked = new THREE.Color();
                    colorClicked.setRGB(r / 255, g / 255, b / 255);
                    var posXYZ = this.findXYZFromColorID(colorClicked.getHex());
                      this.colorizePointAtPos(colorClicked.getHex(),new THREE.Vector3(1,0,0));
                    arrayNeighbours.push(posXYZ);
                }
                //console.log(r,g,b);
            }
            
            this.analyzeSlopeFromArr(arrayNeighbours);
 
        },
        
        
        // Function to compute automatically Width of road, pavements and also heights of buildings
        // Draw Option indicates if it stays or follow move (mouse move or up)
        estimateWidth: function(mouseX, mouseY, drawOption) {

            var arr = new Uint8Array(4);//(wi * he * 4);
            //console.log(gfxEngine.getWinHeight(), mouseY,gfxEngine.getWinHeight() - mouseY );
            gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});
            ctx.readPixels(mouseX, gfxEngine.getWinHeight() - mouseY, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);    // ATTENTION sens inverse pour les Y lors du readPixels

            var r = arr[0];
            var g = arr[1];
            var b = arr[2];
            //console.log(r,g, b);
            var posXYZ = new THREE.Vector3(-1, -1, -1);
            if (!(r === 255 && g === 255 && b === 255)) {
                
                var colorClicked = new THREE.Color();
                colorClicked.setRGB(r / 255, g / 255, b / 255);
               // posXYZ = this.findXYZFrdomColorID(colorClicked.getHex());
                var hex = colorClicked.getHex();
                var indice = hex * 3;   // Indice of position in array of point under mouse
               
                var lOk = false;
                var rOk = false;
                var maxSearch = 5000; 
                var maxYDif = 0.01;
                var minDist = 2;
                var nbPointsLocalAnalyze = 4;
                
                var arrPos = _bufferGeometry.attributes.position.array;
                var initialPos = new THREE.Vector3(arrPos[indice],
                                                   arrPos[indice + 1],
                                                   arrPos[indice + 2]);
                                                   
                var currentPos = new THREE.Vector3(arrPos[indice],
                                                   arrPos[indice + 1],
                                                   arrPos[indice + 2]);
                     
                var i = 0;  
                var ind = indice;
                
                
                // First we look if the user wants to measures something vertical or horizontal
                // Depending on neighbours orientation
                
                // VERTICAL SEARCH
                var up =   arrPos[ind - 2] < initialPos.y && initialPos.y < arrPos[ind + 4] && (arrPos[ind + 4] - arrPos[ind - 2]) > maxYDif * 2;
                var down = arrPos[ind - 2] > initialPos.y && initialPos.y > arrPos[ind + 4] && (arrPos[ind - 2] - arrPos[ind +4 ]) > maxYDif * 2;
                
                if( up || down){
                    
                    var p;
                    if(up)
                        p = this.searchForPointToward(indice,"top");                  
                    else
                        p = this.searchForPointToward(indice,"bottom");      

                       posR = p.posR;
                       posL = p.posL;
                       // adjust XZ of bottom point
                       posL.x = initialPos.x;
                       posL.z = initialPos.z;
                       
                       var dist =   posL.y - posR.y;
                       
                       if(drawOption == "Stay"){
                            Draw.drawOneMoreLine(posL,posR);  
                            Draw.drawSphereAt(posL,0.05,0xff00ff);
                            Draw.drawSphereAt(posR,0.05,0xff00ff);
                            Draw.showTextAtPos3D(dist.toFixed(1)+'m  ',initialPos,50);
                       }else{
                           Draw.drawLine(posL,posR);  
                           Draw.showTextAtPos3DSameMesure(dist.toFixed(1)+'m  ',initialPos);
                            
                       }
                
                }
                else     // HORIZONTAL SEARCH
                {

                    //look left first
                    while(!lOk && i< maxSearch){
                        i++;
                        var acc = 0;  
                        for(var j=0; j<nbPointsLocalAnalyze;++j){

                             ind = indice + (i+j) * 3;
                             var posL = new THREE.Vector3(arrPos[ind    ],
                                                          arrPos[ind + 1],
                                                          arrPos[ind + 2]);

                                //    this.colorizePointAtPos(ind/3,new THREE.Vector3(1,0,0));
                             var difYL =  posL.y - currentPos.y;
                              // Option stronger but much slower to avoid shadow
                            /* if(Math.sqrt( (posL.x - currentPos.x) *(posL.x - currentPos.x) + 
                                           (posL.z - currentPos.z) *(posL.z - currentPos.z)) < 2*maxYDif)*/
                                acc += difYL;

                             currentPos = posL.clone();
                             j+=3;
                        }

                      lOk = (Math.abs(acc) > maxYDif*1.5);// && (Math.abs(acc) < 60*maxYDif);

                  }


                  var indiceL = ind;//-3;
                  var posL = new THREE.Vector3(arrPos[indiceL    ],
                                               arrPos[indiceL + 1],
                                               arrPos[indiceL + 2]);

                  i = 0; 
                  currentPos = new THREE.Vector3(arrPos[indice],
                                                 arrPos[indice + 1],
                                                 arrPos[indice + 2]);
                  //look left first
                  while(!rOk && i<maxSearch ){
                        i++;  
                        var acc = 0;  
                        for(var j=0; j<nbPointsLocalAnalyze;++j){

                             ind = indice - (i+j) * 3;
                             var posR = new THREE.Vector3(arrPos[ind    ],
                                                          arrPos[ind + 1],
                                                          arrPos[ind + 2]);

                            // this.colorizePointAtPos(ind/3,new THREE.Vector3(0,0,1));
                             var difYR =  posR.y - currentPos.y;
                             // Option stronger but much slower to avoid shadow
                          /*  if(Math.sqrt( (posR.x - currentPos.x) *(posR.x - currentPos.x) + 
                                          (posR.z - currentPos.z) *(posR.z - currentPos.z)) < 10*maxYDif)*/
                                acc += difYR;
                             currentPos = posR.clone();
                             j+=3;
                        }

                      rOk = (Math.abs(acc) > maxYDif*1.5);// && (Math.abs(acc) < 10*maxYDif);
                  }
                  var indiceR = ind;//-3;

                  var posR = new THREE.Vector3(arrPos[indiceR    ],
                                               arrPos[indiceR + 1],
                                               arrPos[indiceR + 2]);

                  // Temp for obstacle
                  if( Math.abs(posR.y - posL.y) > 10*maxYDif){
                      if(posR.y>posL.y) posR.y = posL.y; else posL.y = posR.y;
                  }

                  //a.add(new THREE.Vector3(0,2,0))));//cb));// new THREE.addVectors(a,cb));
                  var posMiddle = new THREE.Vector3((posL.x+posR.x)/2,(posL.y+posR.y)/2 - 0.4,(posL.z+posR.z)/2);
                  var dist = posR.distanceTo(posL).toFixed(2); 
                  var distPlanar = Math.sqrt( (posR.x - posL.x) *(posR.x - posL.x) + 
                                              (posR.z - posL.z) *(posR.z - posL.z));
                  var slope = Math.abs(posR.y - posL.y) / distPlanar;
                  
                 // Draw.drawLine(posL,posR);
                 // Draw.showTextAtPos3DSameMesure(dist+'m  '+slope.toFixed(1)+'%',posMiddle);
                  
                  if(drawOption == "Stay"){
                      
                       Draw.drawOneMoreLine(posL,posR);  
                       Draw.showTextAtPos3D(dist+'m  '+slope.toFixed(1)+'%',posMiddle,45);
                       Draw.drawSphereAt(posL,0.05,0xff00ff);
                       Draw.drawSphereAt(posR,0.05,0xff00ff);
                       Draw.setZebraPosition(posL,posR,'ON');
                       
                  }else{
                       Draw.setZebraPosition(posL,posR);
                       Draw.drawLine(posL,posR);  
                       Draw.showTextAtPos3DSameMesure(dist+'m  '+slope.toFixed(1)+'%',posMiddle, 45);
                           
                  }
                  // console.log(posL,posR);
                }
            }
        },
   

        searchForPointToward: function(indice,direction){
            
            
            var arrPos = _bufferGeometry.attributes.position.array;
            var initialPos = new THREE.Vector3(arrPos[indice],
                                               arrPos[indice + 1],
                                               arrPos[indice + 2]);

            var currentPos = new THREE.Vector3(arrPos[indice],
                                               arrPos[indice + 1],
                                               arrPos[indice + 2]);

            var i = 0;  
            var ind = indice;

            var lOk = false;
            var rOk = false;
            var maxSearch = 8000; 
            var maxYDif = 0.01;
            var minDist = 6;
            var nbPointsLocalAnalyze = 4;
            var indiceL,indiceR;
            var posR, posL;
            
            if(direction=="top"){    
                
                while(!lOk && i< maxSearch){
                        i++;
                        ind = indice + i * 3;
                        //this.colorizePointAtPos(ind/3,new THREE.Vector3(1,0,0));
                        var pos = new THREE.Vector3(arrPos[ind    ],
                                                    arrPos[ind + 1],
                                                    arrPos[ind + 2]);

                        var dist = currentPos.distanceTo(pos);
                        currentPos = pos.clone();
                        lOk = dist > minDist;
                   }
                   indiceL = ind - 3;// -3*4;
                   
                   
                   i = 0; 
                   currentPos = new THREE.Vector3(arrPos[indice],
                                                  arrPos[indice + 1],
                                                  arrPos[indice + 2]);                                                       
                   while(!rOk && i< maxSearch){
                       var acc = 0;  
                       i++; 
                       for(var j=0; j<nbPointsLocalAnalyze*24;++j){

                         ind = indice - (i+j) * 3;
                         posL = new THREE.Vector3(arrPos[ind    ],
                                                  arrPos[ind + 1],
                                                  arrPos[ind + 2]);

                         var difYL =  posL.y - currentPos.y;
                         acc += difYL;
                         //this.colorizePointAtPos(ind/3,new THREE.Vector3(0,1,1));
                         currentPos = posL.clone();
                         j+=3;
                      }
                      rOk = (Math.abs(acc) < maxYDif/4);
                   }
                   indiceR = ind - 3;

            }else{
                 
                while(!lOk && i< maxSearch){
                        i++;
                        ind = indice - i * 3;
                        //this.colorizePointAtPos(ind/3,new THREE.Vector3(1,0,0));
                        var pos = new THREE.Vector3(arrPos[ind    ],
                                                    arrPos[ind + 1],
                                                    arrPos[ind + 2]);

                        var dist = currentPos.distanceTo(pos);
                        currentPos = pos.clone();
                        lOk = dist > minDist;
                   }
                   indiceL = ind + 3;

                   i = 0; 
                   currentPos = new THREE.Vector3(arrPos[indice],
                                                  arrPos[indice + 1],
                                                  arrPos[indice + 2]);                                                       
                   while(!rOk && i< maxSearch){
                       var acc = 0;  
                       i++; 
                       for(var j=0; j<nbPointsLocalAnalyze*2;++j){

                         ind = indice + (i+j) * 3;
                         posL = new THREE.Vector3(arrPos[ind    ],
                                                  arrPos[ind + 1],
                                                  arrPos[ind + 2]);

                         var difYL =  posL.y - currentPos.y;
                         acc += difYL;
                         //this.colorizePointAtPos(ind/3,new THREE.Vector3(0,0,1));
                         currentPos = posL.clone();
                         j+=3;
                      }
                      rOk = (Math.abs(acc) < maxYDif/3);

                   }
                   indiceR = ind - 3;
           } 
         //*nbPointsLocalAnalyze;//-3;
           
           
           posR = new THREE.Vector3(arrPos[indiceR    ],
                                    arrPos[indiceR + 1],
                                    arrPos[indiceR + 2]);

           posL = new THREE.Vector3(arrPos[indiceL    ],
                                    arrPos[indiceL + 1],
                                    arrPos[indiceL + 2]);

           // adjust XZ of bottom point
           posR.x = initialPos.x;
           posR.z = initialPos.z;
           posL.x = initialPos.x;
           posL.z = initialPos.z;


           return {posL:posL,posR:posR};
        },
        
        
        analyzeSlopeFromArr: function(arrayPoints){
            
            var a,b,c = null;
            var a = arrayPoints[0];
            var i = 1;
            while (!c && i< arrayPoints.length){
                
                var v = arrayPoints[i];
                if(!b){
                    if (Math.abs(v.x - a.x) >0.1) b = v;}
                else{
                    if (Math.abs(v.z - b.z) >0.1) c = v;}

                i++;
            }
            
            if(c) this.computeNormalFrom3Points(a,b,c);
        },
        
        /*
        analyzeSlopeFromArr: function(arrayPoints){
            

            var l = arrayPoints.length;
            var tabAccu = []; tabAccu.length = l;
            var maxAccu = 0;
            var indiceMaxAccu = -1;
            var seuil = 0.08;
            var maxSlope = 0;
            for (var i=0; i< arrayPoints.length; ++i){
                
                var currentPoint = arrayPoints[i]; 
                for (var j=0; j< arrayPoints.length; ++j){
                
                    var dist = Math.sqrt( (currentPoint.x - arrayPoints[j].x) *(currentPoint.x - arrayPoints[j].x) + 
                                          (currentPoint.z - arrayPoints[j].z) *(currentPoint.z - arrayPoints[j].z));
                    
                    if (dist>0.1){
                       var difH =  Math.abs(currentPoint.y - arrayPoints[j].y);    
                       var slope = difH/dist;
                       if (slope > maxSlope) maxSlope = slope;
                   }

                  //  console.log(slope);                  
                 }
            }
            console.log(maxSlope);
            return maxSlope;
        },
        */
        
        
        computeNormalFrom3Points: function(a,b,c,drawOn){

            var cb = new THREE.Vector3(), ab = new THREE.Vector3();

            cb.subVectors( c, b );
            ab.subVectors( a, b );
            cb.cross( ab );
            cb.normalize();
            
            if(drawOn){
                Draw.drawLine(a,new THREE.Vector3(a.x + cb.x,a.y+cb.y,a.z+cb.z));//a.add(new THREE.Vector3(0,2,0))));//cb));// new THREE.addVectors(a,cb));
                Draw.drawSurface(a,cb); console.log(cb);
                var intensitySlope =  0.3 + 4 * (Math.abs(cb.x) + Math.abs(cb.z));
                if(intensitySlope >1) intensitySlope = 1;
                Draw.setSurfaceColor(intensitySlope);
            }
            
            return cb;
        },
        
        /**
         * Functions for selection, bounding box, inside checkings...
         * 
         */
        changeRepere: function(ptA, ptB, ptC, ptD, alpha) {

            this.lengthAB = (ptB.x - ptA.x) / Math.cos(-alpha);
            this.lengthAC = (ptC.x - ptA.x) / Math.sin(-alpha);

            this.ptA2 = ptA;
            this.ptB2 = new THREE.Vector3(ptA.x + this.lengthAB, ptB.y, ptA.z);
            this.ptC2 = new THREE.Vector3(ptA.x, ptC.y, ptA.z + this.lengthAC);
        },
        
        
        // Function that colorize 3D points inside a bounding box.
        // h is the height of the box
        checkAllPointsInBB: function(ptA, ptB, ptC, ptD, alpha, h) {

            _nbLabel++;
            
            _currentClassEditing = 0;//require('GUI').getCurrentClassEditing();
            _idSurface = 0;//require('GUI').getIdFromFR("surface");
            
            this.changeRepere(ptA, ptB, ptC, ptD, alpha);
            this.nbPointsInBB = 0;
            var color2 = new THREE.Color();
            color2.setHSL(0.2, 0.5, 1.);
            // Then for all 3D points we project in the new coordinate system and check if inside polygon2 (new)
            for (var i = 0; i < _currentNbPointsInBuffer; ++i) {

                var point = new THREE.Vector3(_bufferGeometry.attributes.position.array[i * 3],
                        _bufferGeometry.attributes.position.array[i * 3 + 1],
                        _bufferGeometry.attributes.position.array[i * 3 + 2]);
                this.lengthAPoint = Math.sqrt((point.x - ptA.x) * (point.x - ptA.x) + (point.z - ptA.z) * (point.z - ptA.z));
                var beta = Math.atan2(point.z - ptA.z, point.x - ptA.x);
                this.point2 = new THREE.Vector3(ptA.x + this.lengthAPoint * Math.cos(beta - alpha), point.y, ptA.z + this.lengthAPoint * Math.sin(beta - alpha));

                var configOk = false;
                if (this.ptA2.x < this.ptB2.x) {

                    if (this.ptA2.z < this.ptC2.z) {
                        configOk = this.point2.x > this.ptA2.x && this.point2.x < this.ptB2.x && this.point2.z > this.ptA2.z && this.point2.z < this.ptC2.z;
                    }
                    else {
                        configOk = this.point2.x > this.ptA2.x && this.point2.x < this.ptB2.x && this.point2.z < this.ptA2.z && this.point2.z > this.ptC2.z;
                    }
                } else {
                    if (this.ptA2.z < this.ptC2.z) {
                        configOk = this.point2.x < this.ptA2.x && this.point2.x > this.ptB2.x && this.point2.z > this.ptA2.z && this.point2.z < this.ptC2.z;
                    }
                    else {
                        configOk = this.point2.x < this.ptA2.x && this.point2.x > this.ptB2.x && this.point2.z < this.ptA2.z && this.point2.z > this.ptC2.z;
                    }
                }

                configOk = configOk && (this.ptA2.y <= this.point2.y) && (this.ptA2.y + h >= this.point2.y);
                
                // Pass to filter ground and facade
                if(_filterFacadeAndGround){
                    var classeCurrentPoint = _bufferGeometry.attributes.classe.array[i];
                    configOk =  configOk && ( (classeCurrentPoint < _idSurface) || (classeCurrentPoint >= _idSurface + 100000000 ) );
                }

                if (configOk) {
                    this.nbPointsInBB++;
                    _bufferGeometry.attributes.color.array[i * 3] = color2.r;
                    _bufferGeometry.attributes.color.array[i * 3 + 1] = color2.g;
                    _bufferGeometry.attributes.color.array[i * 3 + 2] = color2.b;
                    _bufferGeometry.attributes.uniqueid.array[i] = _nbLabel;
                    _bufferGeometry.attributes.classe.array[i] = _currentClassEditing;
                    // New stuff to move directly the points ******************************************

                    /*
                     _particleSystem.material.attributes.displacementy.value[i] =10;
                     _particleSystem.material.attributes.displacementx.value[i] =0;
                     _particleSystem.material.attributes.displacementz.value[i] =0;
                     */
                    // *****************************************************************************
                }
            }

            //_particleSystem.material.uniforms['currentidwork'].value = this.nbClassLidar;  // To move the point using the shader
            this.updateLaserAttributes();
            // *****************************************************************************
            
        },
        
        specifyClassForPointsSameID: function(mouseX, mouseY){

            var arr = new Uint8Array(4);//(wi * he * 4);
            //console.log(gfxEngine.getWinHeight(), mouseY,gfxEngine.getWinHeight() - mouseY );
            gfxEngine.renderToTexture(_sceneRTT, gfxEngine.getCamera(), _rtTexture, true); // Render to texture, not shown on screen with the color id
            var ctx = gfxEngine.getContext();//"experimental-webgl", {preserveDrawingBuffer: true});
            ctx.readPixels(mouseX, gfxEngine.getWinHeight() - mouseY, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, arr);    // ATTENTION sens inverse pour les Y lors du readPixels
            
            var r = arr[0];
            var g = arr[1];
            var b = arr[2];
      //      console.log(r,g, b);
            var posXYZ = new THREE.Vector3(-1, -1, -1);
            if (!(r === 255 && g === 255 && b === 255)) {
                
                 var colorClicked = new THREE.Color();
                 colorClicked.setRGB(r / 255, g / 255, b / 255);
                 var hex = colorClicked.getHex();
                
                 var pos = new THREE.Vector3(0, 0, 0);
                 var indice = hex ;//* 3;
                 
                 // Search all points with same id that indice
                 var idObjectUnderPoint = _bufferGeometry.attributes.uniqueid.array[indice];
                 console.log("id of object selected: ",idObjectUnderPoint);
                 for (var i = 0; i < _currentNbPointsInBuffer; ++i) {

                    if (_bufferGeometry.attributes.uniqueid.array[i] == idObjectUnderPoint){
                           _bufferGeometry.attributes.classe.array[i] = _currentClassEditing;
                           this.colorizePointAtPos(i,new THREE.Vector3(1,1,1));
                    }

                 } 
           }

        },
        
        setFilterSurface: function(filterBool){
            _filterFacadeAndGround = filterBool;
            console.log(filterBool);
        },

        // Cartography conversion
        convert: function(x1, y1) {

            var p1 = Cartography.convertCoord({x: x1, y: y1}, "EPSG:27561", "EPSG:2154");
            //var currentPosGeom = new OpenLayers.Geometry.Point(_currentPos.easting, _currentPos.northing);                    
            // converting from lambert93 to viewer srs
            //currentPosGeom = currentPosGeom.transform(new OpenLayers.Projection("EPSG:2154"), _viewer.getMap().getProjectionObject());
            //console.log(p1.x,p1.y);
        },
        
        pairWiseRegistration: function() {
            //+69  + 31  + 301
            var x, y, z, ity;
            for (var i = 0; i < _currentNbPointsInBuffer; ++i) {

                if (_bufferGeometry.attributes.uniqueid.array[i] == _nbClassLidar - 1) {

                    _bufferGeometry.attributes.position.array[i * 3] = _bufferGeometry.attributes.position.array[i * 3] + 69
                    _bufferGeometry.attributes.position.array[i * 3 + 1] = _bufferGeometry.attributes.position.array[i * 3 + 1] + 41;
                    _bufferGeometry.attributes.position.array[i * 3 + 2] = _bufferGeometry.attributes.position.array[i * 3 + 2] + 301;
                    /*      
                     _bufferGeometry.attributes.displacement.array[i*3] = -69
                     _bufferGeometry.attributes.displacement.array[i*3+1] =  -41;
                     _bufferGeometry.attributes.displacement.array[i*3+2] =  -301;
                     */
                }
            }
            _shaderUniforms.currentidwork.value = _nbClassLidar - 1;
            LaserCloud.setReverseMotion
            _bufferGeometry.attributes.displacement.needsUpdate = true;
            this.updateLaserAttributes();

        },
        
        
        getZero: function() {
            return _zero;
        },
        
        getNotLoaded: function(){
            return _notLoaded;
        },
        
        
        getNbClassLidar: function() {
            return _nbClassLidar;
        },
        
        
        getShaderMat: function(){
              return _shaderMatLaserCloud;  
        },


        getGeometryVertices: function(){
          
            return _bufferGeometry;
            //_geometryParticleSystemPicking.vertices;
        },     
        /*
        savePOIInputs: function(pt1, description) {
            console.log('save POI');
            $.post("php/postUserInputs.php",
                    {
                        inputType: 0,
                        p1: [pt1.x, pt1.y, pt1.z],
                        text: description
                    },
            function(resultMsg) {
                console.log("Storing operation : " + resultMsg);
            });
       },
         */
        
       savePointInputs: function(pt1) {
            $.post("php/postUserInputs.php",
                    {
                        inputType: 1,
                        p1: [pt1.x, pt1.y, pt1.z]
                    },
            function(resultMsg) {
                console.log("Storing operation : " + resultMsg);
            });
        },
        
        saveLineInputs: function(pt1, pt2) {
            $.post("php/postUserInputs.php",
                    {
                        inputType: 2,
                        p1: [pt1.x, pt1.y, pt1.z],
                        p2: [pt2.x, pt2.y, pt2.z]
                    },
            function(resultMsg) {
                console.log("Storing operation : " + resultMsg);
            });
        },
                     
        saveBBInputs: function(pt1, pt2, pt3, pt4, height) {
            $.post("php/postUserInputs.php",
                    {
                        inputType: 3,
                        p1: [pt1.x, pt1.y, pt1.z],
                        p2: [pt2.x, pt2.y, pt2.z],
                        p3: [pt3.x, pt3.y, pt3.z],
                        p4: [pt4.x, pt4.y, pt4.z],
                        h: height
                    },
                    function(resultMsg) {
                        console.log("Storing operation : " + resultMsg);
                    });
        },
        
        setAnnotationOnOff: function(b){
          
            console.log('setAnnotationOnOff');
            this.annotationOn = b;
        },
        
        getAnnotationOnOff: function(){
          
            return this.annotationOn;
        },
   
        setComputeNormalOn : function(e){
                this.computeNormalOn    = e;
        },
       
        IsComputeNormalOn : function(){
             return this.computeNormalOn;
        },
        
        getLocalMode : function(){
            return _localMode;
        },
        
        setLocalMode: function(value){
            _localMode = value;
        },
        
        setFilename: function(name){
            _filename = name;
        },
        
        // Print message on screen(text) remove it depending on value
        setMessageDisplay: function(text,value){
            
           if(value){ 
                console.log('loading');
                var element = document.createElement("div");
                element.innerHTML = '<font style="font-family: Impact; font-size:20vw; position:absolute; top:50%; left: 35%; margin-top: -10vw; margin-left: -10vw; color:white"> LOADING </font>';
                element.id="loading";

                var div = document.getElementById("dynamicInput");
                div.appendChild(element);
           }else{
               $('#loading').remove();
           }

           
        }
        
        

    };

    return LaserCloud;
});


  
/**
 * Creates a new Measure obj
 * @author alexandre devaux IGN
 * @class Manages measures
 * 
 */

define('Measure',['jquery', 'GraphicEngine', 'lib/three','Panoramic', 'Dispatcher',  'Draw', 'Navigation'],
    function($, gfxEngine, THREE, Panoramic, Dispatcher, Draw, Navigation) {

    var _posCurrent = null, // vec3 current position
        _RAY_SEARCH = 550,   // ray of search for measures in DB
        _tabMeasures = [],
        _measures =  {},
        _poiArray = null,
        _currentGID = 0,
        _poiIterator = 0,
        _lastMeasure = {},
        


        // EVENT MANAGEMENT
        //*************************************
    _events = {
        MOVE: function() {
            if ($("#connected").length==1)
                Measure.updateMeasureAroundPosition();
        }
    };



    var Measure = {
        
        initiated: false,
        
        init: function() {

            console.log('Measure initiated');
            _posCurrent = Panoramic.getPanoPos();
            _tabMeasures = [];
            this.showUserMeasures();
            Dispatcher.register("MOVE", Measure);
            this.initiated = true;
        },
        
        
       updateMeasureAroundPosition: function(){
                           
             var newPos = Panoramic.getPanoPos();
             var dist = newPos.distanceTo(_posCurrent);                 
             if(dist > _RAY_SEARCH){  // We remove existing measures and load new ones
                  Draw.removeAllMeasures();
                  console.log('load NEW MEASURES');
                  this.showUserMeasures();
                  //update last position
                  _posCurrent = newPos;
             }            
       },

                
        //fonction de tests, appelee dans le traitement de l'event MOVE
        showUserMeasures: function(){
           //console.log('show user measures',$("#connected"));
            if ($("#connected").length==1){ console.log('user is connected');  // Test if user is connected
                var currentPanoInfos = Panoramic.getPanoInfos();
                var params = "easting="+currentPanoInfos.easting+"&northing="+currentPanoInfos.northing+"&ray="+_RAY_SEARCH;
                $.getJSON("php/getUserInputs.php?"+params, function(data){
                    _measures = data; console.log(data);
                   // _poiArray = JSON.parse(data.poi);
                    Measure.drawUserMeasures();
                });
            }    
        },

        
        drawUserMeasures: function(){
           // console.log("Draw.drawLines");
            Draw.drawLines(_measures.lines);
            Draw.drawPOI(_measures.poi);
        },

        drawMeasure: function(pt){
            
            Draw.drawPOI([{x:pt.x,y:pt.y,z:pt.z,description:"QT"}]);
        },
        
        drawAlgoResults: function(data,id){
            
            console.log("Draw algo results");
            Draw.drawProfiles(data,id);
          //  Draw.createMesh(data);
        },
        
        
        // Launch alex H program through zooproject and display result (dynamically)
        launchAlgoAH: function(){

          $.getJSON("http://172.20.0.158/cgi-bin/zoo_loader.cgi?ServiceProvider=&metapath=&Service=WPS&Request=Execute&Version=1.0.0&Identifier=totalprofil&DataInputs=x1_1=1904.461792;y1_1=21219.601562;z1_1=37.966621;x1_2=1904.458496;y1_2=21219.748047;z1_2=37.965637;x1_3=1904.447632;y1_3=21219.892578;z1_3=37.969490;x1_4=1904.430542;y1_4=21220.134766;z1_4=37.967007;x2_1=1900.932617;y2_1=21219.376953;z2_1=37.785740;x2_2=1900.92443;y2_2=21219.521484;z2_2=37.777386;x2_3=1900.916260;y2_3=21219.716797;z2_3=37.778072;x2_4=1900.909668;y2_4=21219.861328;z2_4=37.767097",
            function(){});
          
          this.showAlgoMeasures();
          
        },        
                  
        //fonction de tests, appelee dans le traitement de l'event MOVE
        showAlgoMeasures: function(){
           
            console.log('showAlgoMeasures');
            var idAlgo = 1; 
            $.getJSON("php/getAlgoResults.php?idAlgo="+idAlgo, function(data){

               if( data.length > _currentGID){
                   
                    Measure.drawAlgoResults(data,_currentGID);
                    _currentGID = data.length;                  
              }
              
               setTimeout(Measure.showAlgoMeasures, 500);
            });
            
        },
        
        
        processEvent: function(event) {
            if (_events[event]) {
                _events[event]();
            }
        },
        
        getMeasures: function(){
            return _measures;
        },

        setMeasures: function(m){

            _measures = m;
        },
        
         getPoiArray: function(){
            return _poiArray;
        },

        setPoiArray: function(poi){

            _poiArray = poi;
        },
        
        
        addPOI: function(poiPos,poiDescription){

           var pSon = {x:parseFloat(poiPos.x),y:parseFloat(poiPos.y),z:parseFloat(poiPos.z),description:poiDescription};

        
           if(!_measures.poi){
               var nameItem = "p0";
               _measures.poi = {};
               _measures.poi[nameItem] = pSon;
           }
           else{
              var l = Object.keys(_measures.poi).length;  // To get clean length of object pois
              var nameItem = "p"+l;
              _measures.poi[nameItem] = pSon;
           }

           console.log(_measures);   
        },
        
        
        goToPOI: function(side){
            
            var poiToGo;
            var l = Object.keys(_measures.poi).length; 
            
            if(side=='next'){
                _poiIterator++
            }else{
                _poiIterator--;
            }
            
            var i = (l +_poiIterator) % l;
            if (i<0) i +=l;
            var poiName = 'p'+i;
             
            poiToGo = _measures.poi[poiName];
            console.log(poiToGo);
            var posToGo = new THREE.Vector3(poiToGo.x,poiToGo.y,poiToGo.z);
            var option = {intersectionToLook:posToGo.clone().sub(gfxEngine.getZeroAsVec3D()),surfaceType:"Rectangle"};
            Navigation.goToClosestPosition(posToGo,option);
            
        },
        
         getLastMeasure: function(){
            return _lastMeasure;
        },
        
        setLastMeasure: function(m){
            _lastMeasure = m;
        }

        
    };
    
   
    
    return Measure;
    
});
/* 
 * Interface for main function. Initialize map, set position, orientation, layers...
 * The canvas to integrate the API is called containerITOWNS
 *  !!!!!! TEMP, the API should be composed of different module, map, events... ex API.events, API.maps,
 */


define("API",['jquery', 'GraphicEngine', 'Navigation', 'Panoramic', 'LaserCloud', 'Measure', 'Dispatcher', 'Cartography', 'Cartography3D', 'Config'],
        function($, gfxEngine, Navigation,   Panoramic,   LaserCloud,   Measure,   Dispatcher, Cartography, Cartography3D, Config){
    

         API = function(options){
             
            this.dataURL = options.dataURL || Config.dataURL;  // Specify if using local files or distant : "local", "distant"
           // Config.init("stereopolis");
            
            this.positionInit = options.positionInit || {x:651182.91,y:39.6,z:6861343.03};
            gfxEngine.setZero(this.positionInit);
            
            Panoramic.init(this.positionInit, this.dataURL);   // By default
            Dispatcher.register("MOVE", Panoramic);

            if(options.usingBati3D) {
                this.addLayer("3DBuilding",this.dataURL);
            }
            
            if(options.usingLaserCloud) {
                this.addLayer("pointCloud",this.dataURL);
            }

            this.version = 0.1;
            Dispatcher.register('MOVE', API);
            Dispatcher.register('ZOOM', API);
            Dispatcher.register('ORIENTATION', API);
            Dispatcher.register('MEASURE', API);
            this.initialized = true;
        };
        
        
        // EVENT MANAGEMENT
        
         var _events = {
            MOVE : function (){
                //console.log("move pos");
            },
            ZOOM : function (){
                //console.log("FOV changed");
            },
            ORIENTATION : function (){
                //console.log("ori changed");
            },
            MEASURE : function (){
                console.log(Measure.getLastMeasure());
                //console.log("ori changed");
            }
        };
        
        API.processEvent = function(event){

            if (_events[event]){
                _events[event]();
            }
        };


/*
        API.prototype.initialize = function() {

            console.log('initializing API');

            var mapOptions = {
              center: { easting: 651473, northing: 6862600}, 
              zoom: 8
            };

        };
 */       
        API.prototype.setInitialized = function(b){
            
            this.initialized = b;
        };
        
        API.prototype.isInitialized = function(){
            
            return this.initialized;
        };
        
        
        

        // PANORAMIC **************************************************************************
        
        // Set position to go usin object {x,y,z} or 3 parameters 
        API.prototype.setPanoramicPosition = function(pos) {
            
            console.log("setPanoramicPosition to", pos);
            Navigation.goToClosestPosition(pos);  // !! scopeNavigation.goToClosestPosition(pos);

        };
        
        // Get current pos
        API.prototype.getPanoramicPosition = function() {
           
            var v = Panoramic.getPanoPos();
            return {easting:v.x, northing:v.z, hauteur:v.y};
            // Send signal to linked object
        };
        
        // Set where to look at just in plani, One angle from north, heading (same as yaw)
        API.prototype.setPanoramicOrientation = function(heading) {
            gfxEngine.cameraLookAtHeading(0,0,0, heading);  // !! scopeNavigation.goToClosestPosition(pos);
        };
        
        // Set where to look  with yaw (same as heading) and pitch
        API.prototype.setPanoramicOrientationYawPitch = function(yaw,pitch) {
            gfxEngine.cameraLookAtYawPitch(0,0,0, yaw,pitch);  // !! scopeNavigation.goToClosestPosition(pos);
        };
        // get cam yaw (same as heading) and pitch
        API.prototype.getPanoramicOrientationgetCameraYawPitch = function(){
            return gfxEngine.getCameraYawPitch();
        };
        // Set camera field of view in degree
        API.prototype.setCameraFOV = function(fov){
            gfxEngine.setCameraFov(fov);
        };
        // Get camera field of view in degree
        API.prototype.getCameraFOV = function(){
            return gfxEngine.getCameraFov();
        };
        // Get last 3D measure ({x,y,z})
        API.prototype.getLastMeasure = function(){
            return Measure.getLastMeasure();
        };
        
        API.prototype.addMeasure = function(pt){
            Measure.drawMeasure(pt);
        };
             
        API.prototype.setPanoramicVisible= function(bool){
            Panoramic.setVisibility(bool);
        };
        
        API.prototype.setLowResolution = function(bool){
            gfxEngine.setLowReso(bool);
        };
        
        // Layers **************************************************************************
        
        API.prototype.addLayer = function(layerName, dataURL){
            
           // console.log("addLayer", layerName);
            
            if(layerName == "pointCloud"){
                
                if(Panoramic.isInitiated()){  // PointCloud depends on pano info (time)
                
                    if (!LaserCloud.initiated) {
                            Measure.init();
                            LaserCloud.init(gfxEngine.getZero(), dataURL); //Init itself and its shaders
                            gfxEngine.addToScene(LaserCloud.laserCloudMaster);
                            LaserCloud.launchLaserAroundCurrentTime(10, 11);
                            //LaserCloud.setVisibility(true);
                        }
                        else {
                            if (LaserCloud.getNotLoaded() && !LaserCloud.getLocalMode())
                                LaserCloud.launchLaserAroundCurrentTime(10, 11);
                        }

                        LaserCloud.setVisibility(true);
                        LaserCloud.btnSwitchPoint = true;
                 }else{
                    setTimeout(function(){API.prototype.addLayer("pointCloud",dataURL);}, 150);
                }
            }

            if(layerName == "3DBuilding"){
                    if (!Cartography3D.isCartoInitialized()) {
                                Cartography3D.initCarto3D(dataURL);
                                Panoramic.setVisibility(false);
                    }
            }   
            
            /*
            if(layerName == "TerrestrialImages"){
                Panoramic.init();
            }
            */
        };
        
        
         API.prototype.removeLayer = function(layerName){
             
             console.log("removeLayer", layerName);
             //Change setvitibility to remove ???
             if(layerName == "pointCloud"){
                LaserCloud.setVisibility(false);
             }
             
             if(layerName == "3DBuilding"){
                Cartography3D.removeAllDalles();
             }
             
         };
        

        API.prototype.setLayerVisibility = function(layerName, b){
             
             console.log("removeLayer", layerName);
             if(layerName == "pointCloud"){
                LaserCloud.setVisibility(b);
             }
             
             if(layerName == "3DBuilding"){
                Cartography3D.setVisibility(b);
             }
             
         };

            
            
    
         // Events **************************************************************************
        
        
        /**
         * 
         * @param {type} obj
         * @param {type} att
         * @param {type} call
         * @returns {undefined}
         */
        API.prototype.addListener = function(obj,att,call){
            
            // Static test for juste move function
            if(att=="MOVE")
                _events.MOVE = call;//function(){console.log("waoooooooooooooooo");};
            else
                if(att=="ZOOM")
                    _events.ZOOM = call;//function(){console.log("waoooooooooooooooo");};
            else
                if(att=="ORIENTATION")
                    _events.ORIENTATION = call;
            else
                if(att=="MEASURE")
                    _events.MEASURE = call;
            
        };
        
        
        
        // INPUTS DIV **************************************************************
         API.prototype.createSearchInput = function(){
                         
            $containerSE = $(gfxEngine.getContainerID());
            //$container = $('#containerITOWNS');
            $containerSE.append('<div id="divSearchInput"> <input  name="myfieldname" id="searchInput" value="Adresse, Ville..." style="background-color: rgba(0,0,0,0.5); position:absolute;  right: 50px; width: 250px; top:50px;  z-index: 99;" /> </div>');
            $('#divSearchInput').mousedown(this.textInputClick);
            $('#divSearchInput').mouseup(this.textInputClick);
            $('#divSearchInput').mousemove(this.textInputClick);
            $('#divSearchInput').click(this.textInputClick);
            $('#divSearchInput').keyup(this.textInputChange);
        };
        
        API.prototype.textInputClick = function(e){
            console.log("click");
            e.stopPropagation();
          //  e.originalEvent.preventDefault();
        };
        
        API.prototype.textInputChange = function(e){
            
               if (e.keyCode == 13) {  // Enter key

                    var p = $("#searchInput").val();
                    if (parseFloat(p.substring(3, 4)) >= 0.0) {  // Coordinate
                        var tabCoord = p.split(" ");
                        Navigation.goToClosestPosition({x: tabCoord[0], y: 0, z: tabCoord[1]}, {distance: 250});
                    } else
                    if (p.indexOf('_') > 0) {
                        Navigation.loadPanoFromNameAndLookAtIntersection(p);
                    }    // Pano name
                    else
                        Cartography.sendOLSRequest(p, false);  // Address

                    }
        };
        // LASER    
   
        return API;
    
});
/**
* 
* @author AD IGN
* Class generating shaders for projective texturing for one photo. This class can be used 
* to texture any mesh. We need to set the matrix of Orientation of the projector
* and its projective camera information.
*/

define ('ProjectiveTexturingPhoto',['GraphicEngine','lib/three','Ori','Shader','Utils','Draw'],
function (graphicEngine, THREE, Ori, Shader, Utils,Draw) {

            window.requestAnimSelectionAlpha = (function(){
                         return  window.requestAnimationFrame || 
                         window.webkitRequestAnimationFrame   || 
                         window.mozRequestAnimationFrame      || 
                         window.oRequestAnimationFrame        || 
                         window.msRequestAnimationFrame       || 
                         function(callback, element){
                             window.setTimeout(callback, 1000 / 60);
                         };
               })();
    
        var _initiated = false;
        var _alphaP = 1;
        var _shaderMat = null;
	var tabImages = [];  // Get the 20 images (>=10) to pass to shaders . Img at indice 0 is 21, 1 is 22, ... 10 is 21bis, 11 is 22bis... 19 is 43 bis
	var tabTranslations =[];
	var tabRotations=[];
	//initImages();    // Prepare image loading space used in the shaders, 20 img
	var tabMatrices = [];//var matrice21 //proj_cam* mv_current_21* rot21
	var tabMatMVP = [];
        var pat=new RegExp("-[0-9][0-9]-");  // To detect and change camera number
        
        var _texture = null;
        var _mobileVersion = 0;

        var _translation = new THREE.Vector4(0.,0.,0.,1.);
        var _matOriPos = null;  
        
        var _proj_cam  = new THREE.Matrix4(  1129.284,	0,	0.,	0.,
                                           0.,        1129.284,	0.,	0.,
                                           1042.178,  1020.435,	0.,	1.,
                                           0.,          0.,     0.,	0.);
        var _matMVP = null;                                 
                                           

        var rot21 = new THREE.Matrix4(	1,0,0,0,
                                        0,1,0,0,
                                        0,0,1,0,
                                        0,0,0,1);

        var mat300;


     
        var ProjectiveTexturingPhoto = {
         
            imgName:'',
            nbL2Loaded : 0,     // Indicate the number of image loaded at level2 
                             // If 10 then we can load level 3
                             // This technic allow to not load level 3 when navigating fast
                          
                
         init: function(matRot){
             
             _mobileVersion = graphicEngine.isMobileEnvironment() ? 1:0;
                // 1286	4	1621404,789	8173125,316	2295,630	0,1450	0,1570	-32,5938	209374,8182	1286.tif
             var posTest = new THREE.Vector3(1621404.789,8173125.316,2295.630);
             var rotX = 0.1450;
             var rotY = 0.1570;
             var rotZ = -32.5938; // axe des Z dans itowns too, ROLL
             var projItowns = new OpenLayers.Projection("EPSG:2154");
             var projCASQY  = new OpenLayers.Projection("EPSG:3949");  // Lambert93 CC49
             var p1 = new OpenLayers.Geometry.Point(posTest.x, posTest.y);
             p1 = p1.transform(projCASQY, projItowns);
             console.log(p1);
             
             //this.initPosOrientationCameraMatrice(p1.x,p1.z,p1.y,rotX,rotY,rotZ);
             this.initPosOrientationCameraMatrice(0,0,0,rotX,rotY,rotZ);
             
             this.initMatrices();
             
             this.initTranslations(p1,posTest.z);
             _initiated = true;
             
             this.createShaderForImage();
             
         },
         
         
         
         // Get Orientation matrices for camera, relatif
         // all cam in the same local ref
         initPosOrientationCameraMatrice: function(x,y,z,heading,pitch,roll){
            
          // _matOriPos = this.computeMatOriFromHeadingPitchRoll(heading,pitch,roll);
              heading = parseFloat(heading) / 180 * Math.PI ;  // Deg to Rad // Axe Y
              pitch   = parseFloat(pitch)   / 180 * Math.PI ;  // Deg to Rad // axe X
              roll    = parseFloat(roll)    / 180 * Math.PI ;  // Deg to Rad   // axe Z
             var m = new THREE.Matrix4();
             m.makeRotationFromEuler(new THREE.Euler(roll,0,0,"ZYX"));
             //m.makeRotationZ(Math.PI/2);
           _matOriPos = m;

         },
         

          computeMatOriFromHeadingPitchRoll: function(heading,pitch,roll){
              
              heading = parseFloat(heading) / 180 * Math.PI ;  // Deg to Rad // Axe Y
              pitch   = parseFloat(pitch)   / 180 * Math.PI ;  // Deg to Rad // axe X
              roll    = parseFloat(roll)    / 180 * Math.PI ;  // Deg to Rad   // axe Z
              console.log("heading,pitch,roll ",heading,pitch,roll );
              
              // With quaternion  //set rotation.order to "YXZ", which is equivalent to "heading, pitch, and roll"
              var q = new THREE.Quaternion();
              //q.setFromEuler(new THREE.Euler(heading,pitch,roll,'YXZ'),true);
              q.setFromEuler(new THREE.Euler(roll,heading,pitch,'YXZ'),true);
              var matTotale = new THREE.Matrix4().makeRotationFromQuaternion(q);//qRoll);//quater);
              
              return matTotale;//.transpose(); //mat2 //matRotation;
          },
          
          
          getProjCam: function(num){
               
              _proj_cam = new THREE.Matrix4( 200,	0,	0.,	0.,
                                             0.,       200,	0.,	0.,
                                             200,      200,	0.,	1.,
                                             0.,        0.,     0.,	0.);
                                           
          },
              
                
         // Initialize matrices using global rotation (21) and local for each cam
         initMatrices: function(){
             
            _matMVP = new THREE.Matrix4().multiplyMatrices(_matOriPos,_proj_cam).transpose();  // Don't forget to transpose before sending to GPU
           
            // _matMVP = require("ProjectiveTexturing2").getTabMatrices()[0];//new THREE.Matrix4();
            console.log("_matMVP",_matMVP);

         },
         
         
         // Init translation using cam pos in applanix ref and global rotation
         initTranslations: function(point,alti){
             
             var zero = graphicEngine.getZeroAsVec3D();
             _translation = new THREE.Vector4(point.x - zero.x,alti - zero.y,point.y - zero.z);
             console.log(_translation);
             Draw.drawSphereAt(_translation,20);
             //var translation300 = Ori.getSommet(300).clone().applyProjection( rot21.clone()); translation300.w = 1;
             //tabTranslations.push(translation300);

             
         },
         
         
        // Init Images, Rotations and Translations
	initImages: function(){

            for(var i = 0; i< 10; ++i){
                var img = new Image(); img.crossOrigin = 'anonymous';
                tabImages.push(img);
                tabRotations.push(rot21);
            }
	},
         
         
       createShaderForImage: function(imgUrl,qlt){

           
            var width = 1920;
            var height = 1080;

            var distoAndMax300 = new THREE.Vector4(0,0,0,0);//Ori.getDistortionAndR2ForCamAsVec4(300);

            var wid = _mobileVersion == 1 ? 512:1024;
            var uniforms5 = {
                
                    //disto_and_max_tab:{type: 'fv1', value: arrAllDistoandMax},
                    intrinsic300: {type:"v4",value:distoAndMax300},

                    alpha:{type:'f',value:_alphaP},
                    fog:  { type: "i", value: 0 }, 

                    mvpp_current_0:{type: 'm4',value: _matMVP},
                    factorTranslation0:{type:"v4",value: _translation},

                    texture0: {
                            type: 't',
                            value: THREE.ImageUtils.loadTexture("http://www.itowns.fr/casqy/obliques/499_1286S.jpg")  
                    }
                   
            };

            // create the shader material for Three
            _shaderMat = new THREE.ShaderMaterial({
                    uniforms:     	uniforms5,
                    vertexShader:   Shader.shaders['shaderTextureProjectivePhoto.vs'],
                    fragmentShader: Shader.shaders['shaderTextureProjectivePhoto.fs'],
                    side: THREE.BackSide,   
                    transparent:true
            });

            return _shaderMat;
	},

        changePanoTextureAfterloading: function (imgName,wid,qlt,translation,rotation,nbLevel){

             //console.log("changePanoTextureAfterloading");
             this.imgName = imgName;
             this.nbL2Loaded = 0;
             require("Cartography3D").tweenGeneralOpacity();
                          
             this.chargeOneImageCam(imgName,'texture1',1,wid,qlt,translation,rotation,6,nbLevel);
             this.chargeOneImageCam(imgName,'texture2',2,wid,qlt,translation,rotation,7,nbLevel);
             this.chargeOneImageCam(imgName,'texture3',3,wid,qlt,translation,rotation,8,nbLevel);
             this.chargeOneImageCam(imgName,'texture4',4,wid,qlt,translation,rotation,9,nbLevel);
             this.chargeOneImageCam(imgName,'texture0',0,wid,qlt,translation,rotation,5,nbLevel);
        },
        
          changePanoTextureAfterloadingTurboTruckMode: function (imgName,wid,qlt,translation,rotation,nbLevel){
            
             //console.log("changePanoTextureAfterloading");
             this.imgName = imgName;
             this.nbL2Loaded = 0;
             this.chargeOneImageCam(imgName,'texture1',1,512,85,translation,rotation,6,0);
    
        },
        
        
         // Load an Image(html) then use it as a texture. Wait loading before passing to the shader to avoid black effect
         // Param nbLevel means if we load a better level or not. 0 or 1
        chargeOneImageCam: function (imgName,nameTexture,num,wid,qlt,translation,rotation,numImg,nbLevel){
           
            // We tell the shader that the actual new texture has to become the old one to make a new transition with the real new one just loaded.
            if(_mobileVersion==0){
                _shaderMat.uniforms[nameTexture].value =_shaderMat.uniforms[nameTexture+'bis'].value;
                _shaderMat.uniforms['factorTranslation'+num].value = tabTranslations[numImg];
                _shaderMat.uniforms['mvpp_current_'+num].value = tabMatrices[numImg];
            }

            var translationPlusSom = translation.clone().add((Ori.getSommet(300+num).clone().applyProjection( rotation.clone()))); translationPlusSom.w = 1;
            tabTranslations[numImg] = translationPlusSom; 		
            tabMatrices[numImg] = (new THREE.Matrix4().multiplyMatrices( rotation.clone(),tabMatMVP[numImg - 5].clone()) ).transpose();
              
            // Load the new image
            var img = new Image(); img.crossOrigin = 'anonymous';
            var that = this;
            img.onload = function () { 
                
                _shaderMat.uniforms['indice_time'+num].value = .8; //if(num==1) console.log('now!');
                _shaderMat.uniforms['mvpp_current_'+num+'bis'].value = tabMatrices[numImg];
                _shaderMat.uniforms['factorTranslation'+num+'bis'].value = translationPlusSom;
                
                _shaderMat.uniforms[nameTexture+'bis'].value = new THREE.Texture(this,THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter,THREE.LinearFilter,THREE.RGBFormat);
                _shaderMat.uniforms[nameTexture+'bis'].value.needsUpdate = true;
                if(nbLevel==1) that.changeQuality(imgName,nameTexture,num,512,qlt,numImg);  // Load level 2
                //if(graphicEngine.getSpeedTurnCam() != 0.1 && num == 3) graphicEngine.setSpeedTurnCam(0.1);
            };
            img.src = "http://www.itowns.fr/cgi-bin/iipsrv.fcgi?FIF=/iipimagesV2/"+imgName.replace(pat,"-30"+num+"-")+".jp2&WID="+wid+"&QLT="+qlt+"&CVT=JPEG";
        },
        
        
           // Load Better Quality. Level 2 (512@50) and 3 (1920@80).
           changeQuality: function(imgName,nameTexture,num,wid,qlt){
               
                var that = this;
                var img = new Image(); img.crossOrigin = 'anonymous';
                img.src = "http://www.itowns.fr/cgi-bin/iipsrv.fcgi?FIF=/iipimagesV2/"+imgName.replace(pat,"-30"+num+"-")+".jp2&WID="+wid+"&QLT="+qlt+"&CVT=JPEG";
                img.onload = function () { 
                        //tabImages[num+5] = this;
                        _shaderMat.uniforms[nameTexture+'bis'].value = new THREE.Texture(this,THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter,THREE.LinearFilter,THREE.RGBFormat);
                        _shaderMat.uniforms[nameTexture+'bis'].value.needsUpdate = true;
                        if(qlt == 50) that.nbL2Loaded++; 
                        if(graphicEngine.getSpeedTurnCam() != 0.1 && num == 3) {graphicEngine.setSpeedTurnCam(0.1); } //require("Cartography3D").setOpacity(0.4);
                }
           },
           
               
           
           // Recursive function
           // After load image load next one etc at same level
           changeQualitySerial: function(tabImageToLoad,imgName,wid,qlt){

                    var num = tabImageToLoad.shift(); 
                    var nameTexture = 'texture'+num;
                    var that = this;
                    var img = new Image(); img.crossOrigin = 'anonymous';
                    img.src = "http://www.itowns.fr/cgi-bin/iipsrv.fcgi?FIF=/iipimagesV2/"+imgName.replace(pat,"-30"+num+"-")+".jp2&WID="+wid+"&QLT="+qlt+"&CVT=JPEG";
                    img.onload = function () { 
                        
                        if (that.imgName == imgName){
                            //tabImages[num+5] = this;
                            tabImages[parseInt(num)+5] = this;
                            _shaderMat.uniforms[nameTexture+'bis'].value = new THREE.Texture(this,THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter,THREE.LinearFilter,THREE.RGBFormat);
                            _shaderMat.uniforms[nameTexture+'bis'].value.needsUpdate = true;

                            if(qlt == 50) that.nbL2Loaded++;
                            if(tabImageToLoad.length>0) that.changeQualitySerial(tabImageToLoad,imgName,wid,qlt); 
                       }
                            
                    }  
           },    
           
           
           loadQualityLevel: function(wid,qlt,imgName){

                //setTimeout(function(){ProjectiveTexturing.loadQualityLevelNow(1920,80,imgName);},2000);  
                setTimeout(function(){ProjectiveTexturing2.loadQualityLevelNowSerial(wid,qlt,imgName);},2000);  
           },
           
  
           // Serial launch
           loadQualityLevelNowSerial: function(wid,qlt,imgName){

                if (this.imgName==imgName){    // Means that we are still in the same image
                   console.log(this.imgName);
                   console.log('load level3');   // waiting for higher resolution
                   var tabImageToLoad = ['0','1','2','3','4'];
                   this.changeQualitySerial(tabImageToLoad,this.imgName,wid,qlt);
               }

               //this.nbL2Loaded = 0;
           },

           
           // Return a i,j coordinate in the image where it projects from a 3D position. Same as the original GPU code
           groundToImage: function(pos){

                var newpos0 = pos.clone().sub( _shaderMat.uniforms['factorTranslation0bis'].value); 
                var newpos1 = pos.clone().sub( _shaderMat.uniforms['factorTranslation1bis'].value); 
                var newpos2 = pos.clone().sub( _shaderMat.uniforms['factorTranslation2bis'].value); 
                var newpos3 = pos.clone().sub( _shaderMat.uniforms['factorTranslation3bis'].value); 
                var newpos4 = pos.clone().sub( _shaderMat.uniforms['factorTranslation4bis'].value); 
                
                var v_texcoord0bis =  _shaderMat.uniforms['mvpp_current_0bis'].value.multiplyVector4( new THREE.Vector4(newpos0.x, newpos0.y,newpos0.z,1));
                var v_texcoord1bis =  _shaderMat.uniforms['mvpp_current_1bis'].value.multiplyVector4( new THREE.Vector4(newpos1.x, newpos1.y,newpos1.z,1));
                var v_texcoord2bis =  _shaderMat.uniforms['mvpp_current_2bis'].value.multiplyVector4( new THREE.Vector4(newpos2.x, newpos2.y,newpos2.z,1));
                var v_texcoord3bis =  _shaderMat.uniforms['mvpp_current_3bis'].value.multiplyVector4( new THREE.Vector4(newpos3.x, newpos3.y,newpos3.z,1));
                var v_texcoord4bis =  _shaderMat.uniforms['mvpp_current_4bis'].value.multiplyVector4( new THREE.Vector4(newpos4.x, newpos4.y,newpos4.z,1));

                var corrected0bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic300'].value, v_texcoord0bis.clone());
                var corrected1bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic301'].value, v_texcoord1bis.clone());
                var corrected2bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic302'].value, v_texcoord2bis.clone());
                var corrected3bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic303'].value, v_texcoord3bis.clone());
                var corrected4bis = this.correctDistortionAndCoord(_shaderMat.uniforms['intrinsic304'].value, v_texcoord4bis.clone());
                
                // z is actually representing w
                var coordImage;
                if(corrected0bis.x > 0 && corrected0bis.y>0 && corrected0bis.z >0)
                        {coordImage = corrected0bis; coordImage.z = 0;}
                 else
                   if(corrected1bis.x > 0 && corrected1bis.y>0 && corrected1bis.z >0)
                        {coordImage = corrected1bis; coordImage.z = 1;}
                  else
                    if(corrected2bis.x > 0 && corrected2bis.y>0 && corrected2bis.z >0)
                        {coordImage = corrected2bis; coordImage.z = 2;}
                  else
                    if(corrected3bis.x > 0 && corrected3bis.y>0 && corrected3bis.z >0)
                        {coordImage = corrected3bis; coordImage.z = 3;}
                  else
                    if(corrected4bis.x > 0 && corrected4bis.y>0 && corrected4bis.z >0)
                        {coordImage = corrected4bis; coordImage.z = 4;}
                
                var pat = new RegExp("-[0-9][0-9]-");  // To detect and change camera number
                console.log(this.imgName);
                var imgName = this.imgName.replace(pat,"-30"+coordImage.z+"-").replace(/^.*[\\\/]/, '');
                var infoIJ = {i: coordImage.x*2048,j: coordImage.y*2048, imgName:imgName};
                return infoIJ;
               
           },
          

        
           correctDistortionAndCoord: function(dist,v_texcoord){
               
                 var cpps = 1042.178;
                 var lpps = 1020.435;
                 var width = 2048.0;
                 var height = 2048.0;
                 // vec2 pps = vec2(cpps,lpps);
            
                //var v = v_texcoord.xy/v_texcoord.w - pps;
                var v_b = new THREE.Vector3(v_texcoord.x/v_texcoord.w - cpps,
                                            v_texcoord.y/v_texcoord.w - lpps,
                                            0);
                            
                var v2 = v_b.dot(v_b);

                if(v2>dist.w) 
                    return new THREE.Vector3(-2.,-2.,-2.); // false;
                
                var  r = v2*(dist.x+v2*(dist.y+v2*dist.z));

                //var  normCoord = v_texcoord.xy/(v_texcoord.w) + r*v;
                var  normCoord = new THREE.Vector3(v_texcoord.x/v_texcoord.w + r*v_b.x,
                                                   v_texcoord.y/v_texcoord.w + r*v_b.y,
                                                   0);

                return new THREE.Vector3(normCoord.x/width , 1. - normCoord.y/height, v_texcoord.w); 
                //vec2(normCoord.x/width , 1. - normCoord.y/height); 
        },
                
           changeDistortion: function(){
            
            if(_shaderMat.uniforms['r3'].value != 0.){
                
                _shaderMat.uniforms['r3'].value = 0.;
                _shaderMat.uniforms['r5'].value = 0.;
                _shaderMat.uniforms['r7'].value = 0.;

                _shaderMat.uniforms['r30'].value = 0.;
                _shaderMat.uniforms['r50'].value = 0.;
                _shaderMat.uniforms['r70'].value = 0.;

            }
            else
                {

                _shaderMat.uniforms['r3'].value = -1.414241e-007;
                _shaderMat.uniforms['r5'].value = 3.56829e-014;
                _shaderMat.uniforms['r7'].value = -4.239262e-021;

                _shaderMat.uniforms['r30'].value = -1.335994e-007;
                _shaderMat.uniforms['r50'].value = 3.335513e-014;
                _shaderMat.uniforms['r70'].value = -3.928705e-021;
            }
              
            _shaderMat.uniforms['r3'].value.needsUpdate = true;
            _shaderMat.uniforms['r5'].value.needsUpdate = true;
            _shaderMat.uniforms['r7'].value.needsUpdate = true;
            _shaderMat.uniforms['r30'].value.needsUpdate = true;
            _shaderMat.uniforms['r50'].value.needsUpdate = true;
            _shaderMat.uniforms['r70'].value.needsUpdate = true;
        },
        
        
        changeBlending: function(){
            
            if( _shaderMat.uniforms['blendingOn'].value == 1)
                   _shaderMat.uniforms['blendingOn'].value = 0;
               else
                   _shaderMat.uniforms['blendingOn'].value = 1;

           _shaderMat.uniforms['blendingOn'].value.needsUpdate = true;
            
        },


       getShaderMat: function(){
          return _shaderMat;  
        },
        
        
        isInitiated: function(){
            return _initiated;
        },
       
        
        tweenGeneralOpacity: function(){
            console.log(" tweenGeneralOpacity");
            var i = _shaderMat.uniforms.alpha.value;
            if(i>0){
                i -= (1- (i-0.01))*0.02;
                if(i<0) i=0;
                _shaderMat.uniforms.alpha.value = i;
            }	
           requestAnimSelectionAlpha(this.tweenGeneralOpacity.bind(this));
        },
        
        tweenGeneralOpacityUp: function(){
            //console.log(" tweenGeneralOpacity", _shaderMat.uniforms.alpha.value);
            var i = _shaderMat.uniforms.alpha.value;
            if(i<1){
                i += ((i+0.01))*0.04;
                if(i>1) i=1;   
                _shaderMat.uniforms.alpha.value = i;
                
                requestAnimSelectionAlpha(this.tweenGeneralOpacityUp.bind(this));
            }	
          
        },
        
        
        setGeneralOpacity: function(value){
            _alphaP = value;
            _shaderMat.uniforms.alpha.value = _alphaP;
        },
        
        
        setFogValue: function(v){
           _shaderMat.uniforms.fog.value = v;
        },
        	
                
	tweenAllIndiceTimes: function (){
           
            this.tweenIndiceTime(0);
            this.tweenIndiceTime(1);
            this.tweenIndiceTime(2);
            this.tweenIndiceTime(3);
            this.tweenIndiceTime(4);
          
            if(this.nbL2Loaded==5 && _mobileVersion==0) {           // Test to load Level 3
                    this.nbL2Loaded=0;
                    this.loadQualityLevel(2048,80,this.imgName);
            }

            requestAnimSelectionAlpha(this.tweenAllIndiceTimes.bind(this));
	},
	
        
	tweenIndiceTime: function (num){

            var i = _shaderMat.uniforms['indice_time'+num].value;
            if(i>0){
                i -= (1- (i-0.01))*0.08;
                if(i<0) i=0;
                _shaderMat.uniforms['indice_time'+num].value = i;
            }	
	},
        
        
        setIndiceTimeCam: function(num,time){
            _shaderMat.uniforms['indice_time'+num].value = time;
        },
	
        
        setRotationHeading: function(rot){
                
           rot21 = rot;
        }
        
        
     }
     return ProjectiveTexturingPhoto
  }
  
)
         ;

/**
 * Creates a module to handle weather effects
 * @author alexandre devaux IGN
 * @class Manages laser data
 * @require THREE.JS
 */
define('lib/postprocessing/WeatherEffects',['jquery', 'GraphicEngine', 'lib/three', 'Shader', 'Panoramic', 'Dispatcher', 'Cartography','Draw', 'ProjectiveTexturing2', 'Utils'],
    function($, gfxEngine, THREE, Shader, Panoramic, Dispatcher, Cartography, Draw, ProjectiveTexturing2, Utils) {
        
                
        
    var _shaderAttributes = null,
        _shaderUniforms = null,
        _indice_time = 0,
        _nbPointsBuffer = 10000,
        _nbPointsForCloud = 4000,
        _bufferGeometry = null,
        _bufferGeometryCloud,
        _shaderMat = null,
        _shaderMatCloud = null,
        _particleSystem = null,
        _particleSystemCloud = null,
        _effectNum = 0,
        _effectIntensity = 0,
        _time_step = 0.1,
        _farFog = 100;


    window.requestAnimFrameW = (function() {
        return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(callback, element) {
                    window.setTimeout(callback, 1000 / 60);
                };
    })();





    var WeatherEffects = {
        
        initiated: false,
        
        init: function() {
            
            this.initializeBufferGeometry();
            this.initiated = true;
            this.animateTime();
            this.setClimate(90);
        },
        
        addToScene: function(){
            
            gfxEngine.addToScene(_particleSystem);
            gfxEngine.addToScene(_particleSystemCloud);
            
        },
        
        removeFromScene: function(){
            
            gfxEngine.removeFromScene(_particleSystem);
            gfxEngine.removeFromScene(_particleSystemCloud);
        },
        
        animateTime: function(){

           _indice_time += _time_step;
           _particleSystem.material.uniforms['indice_time'].value = _indice_time;
           _particleSystemCloud.material.uniforms['indice_time'].value = _indice_time;
           
           gfxEngine.setTimeEffect(_indice_time);
           
           requestAnimFrameW(WeatherEffects.animateTime);     
        },
       
        initializeBufferGeometry: function() {

            this.createShader();
            this.createShaderCloud();

            _bufferGeometry = new THREE.BufferGeometry();
            _bufferGeometry.dynamic = true;
            
            _bufferGeometryCloud = new THREE.BufferGeometry();
            _bufferGeometryCloud.dynamic = true;

            _bufferGeometry.attributes = {
                
                position: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3), // ! not float64 to gpu
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                },
                color: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3),
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                },
                displacement: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsBuffer * 3),
                    numItems: _nbPointsBuffer * 3,
                    dynamic: true
                }, 
                size: {
                    itemSize: 1,
                    array: new Float32Array(_nbPointsBuffer ),
                    numItems: _nbPointsBuffer,
                    dynamic: false
                } 
            };
            
            
            _bufferGeometryCloud.attributes = {
                
                position: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsForCloud * 3), // ! not float64 to gpu
                    numItems: _nbPointsForCloud * 3,
                    dynamic: true
                },
                color: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsForCloud * 3),
                    numItems: _nbPointsForCloud * 3,
                    dynamic: true
                },
                displacement: {
                    itemSize: 3,
                    array: new Float32Array(_nbPointsForCloud * 3),
                    numItems: _nbPointsForCloud * 3,
                    dynamic: true
                }, 
                size: {
                    itemSize: 1,
                    array: new Float32Array(_nbPointsForCloud ),
                    numItems: _nbPointsForCloud,
                    dynamic: false
                } 
            };
       
            this.initializeBufferValues();
            this.initializeBufferValuesCloud();

            _particleSystem = new THREE.ParticleSystem(_bufferGeometry, _shaderMat);
            _particleSystemCloud = new THREE.ParticleSystem(_bufferGeometryCloud, _shaderMatCloud);
            
        },
        
        createShader: function() {

            _shaderAttributes = {
                displacement: {type: 'v3', value: []},
                color: {type: 'v3', value: []},
                size: {type: 'f', value: []}
            };

            _shaderUniforms = {
                indice_time: {type: 'f', value: _indice_time},
                point_size: {type: 'f', value: 1},
                alpha: {type: 'f', value: 0.7},
                textureSnow: {type: 't',
                   value: THREE.ImageUtils.loadTexture("images/textures/snowflake.png")//smoke_particle.png")  
                },
                textureDrop: {type: 't',
                   value: THREE.ImageUtils.loadTexture("images/textures/raindrop2flip.png")//smoke_particle.png")  
                },
                textureCloud: {type: 't',
                   value: THREE.ImageUtils.loadTexture("images/textures/smoke_particle.png")//smoke_particle.png")  
                },
                effectNum: {type: 'i', value:_effectNum},
                effectIntensity: {type: 'f', value:_effectIntensity},
                farFog: {type: 'f', value:_farFog}
            };

            // create the shader material for the laser particle system
            // !!!!!  VERY IMPORTANT  Depthest : false to have a nice opacity in every direction
            // For BufferGeometry now we need to set everything here. Like transparent 
            _shaderMat = new THREE.ShaderMaterial({
                uniforms: _shaderUniforms,
                attributes: _shaderAttributes,
                vertexShader: Shader.shaders['shaderWeather.vs'],
                fragmentShader: Shader.shaders['shaderWeather.fs'],
                vertexColors: THREE.VertexColors,
                depthTest: false,
                transparent: true
            });

        },
        
        createShaderCloud: function() {

            _shaderAttributes = {
                displacement: {type: 'v3', value: []},
                color: {type: 'v3', value: []},
                size: {type: 'f', value: []}
            };

            _shaderUniforms = {
                indice_time: {type: 'f', value: _indice_time},
                point_size: {type: 'f', value: 1},
                alpha: {type: 'f', value: 0.7},
                textureSnow: {type: 't',
                   value: THREE.ImageUtils.loadTexture("images/textures/snowflake.png")//smoke_particle.png")  
                },
                textureDrop: {type: 't',
                   value: THREE.ImageUtils.loadTexture("images/textures/raindrop2flip.png")//smoke_particle.png")  
                },
                textureCloud: {type: 't',
                   value: THREE.ImageUtils.loadTexture("images/textures/smoke_particle.png")//smoke_particle.png")  
                },
                effectNum: {type: 'i', value:5},
                effectIntensity: {type: 'f', value:_effectIntensity},
                farFog: {type: 'f', value:_farFog}
            };

            // create the shader material for the laser particle system
            // !!!!! DepthTest to true so clouds stay behind building and depthwrite to false
            // For BufferGeometry now we need to set everything here. Like transparent 
            _shaderMatCloud = new THREE.ShaderMaterial({
                uniforms: _shaderUniforms,
                attributes: _shaderAttributes,
                vertexShader: Shader.shaders['shaderWeather.vs'],
                fragmentShader: Shader.shaders['shaderWeather.fs'],
                vertexColors: THREE.VertexColors,
                depthTest:true,
                depthWrite:false,
                transparent: true
                //blending: THREE.AdditiveBlending
            });
            // _shaderMatCloud.blending = blending: THREE.AdditiveBlending
            //_shaderMatCloud.alphaTest = 0.5;

        },
        
        initializeBufferValues: function() {
            
            var positions = _bufferGeometry.attributes.position.array;
            var values_color = _bufferGeometry.attributes.color.array;
            var displacements = _bufferGeometry.attributes.displacement.array;
            var size = _bufferGeometry.attributes.size.array;

            var color2 = new THREE.Color();
            color2.setHSL(0.2, 0.5, 0.7);
            // we set default properties: position, color, displacement
            var radius = 100;

            for (n = 0; n < _nbPointsBuffer; ++n) {

                positions[ n * 3 + 0 ] = (Math.random() * 2 - 1) * radius - radius/2;  // Camera far: 10000
                positions[ n * 3 + 1 ] =  Math.random()  * radius*3;  // so out of frustum
                positions[ n * 3 + 2 ] = (Math.random() * 2 - 1) * radius - radius/2;

                displacements[ n * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
                displacements[ n * 3 + 1 ] = -Math.random() * radius * 3;
                displacements[ n * 3 + 2 ] = (Math.random() * 2 - 1) * radius;

                values_color[ n * 3 + 0 ] = color2.r;
                values_color[ n * 3 + 1 ] = color2.g;
                values_color[ n * 3 + 2 ] = color2.b;
                
                size[n*3] = Math.random() * 10;

            }
        },
        
                
        initializeBufferValuesCloud: function() {
            
            var positions = _bufferGeometryCloud.attributes.position.array;
            var values_color = _bufferGeometryCloud.attributes.color.array;
            var displacements = _bufferGeometryCloud.attributes.displacement.array;
            var size = _bufferGeometryCloud.attributes.size.array;

            var color2 = new THREE.Color();
            color2.setHSL(0.2, 0.5, 0.7);
            // we set default properties: position, color, displacement
            var radius = 50;

            for (n = 0; n < _nbPointsBuffer; ++n) {

                positions[ n * 3 + 0 ] = (Math.random() * 2 - 1) * radius ;  // Camera far: 10000
                positions[ n * 3 + 1 ] = 30 + Math.random()  * radius/2;  // so out of frustum
                positions[ n * 3 + 2 ] = (Math.random() * 2 - 1) * radius ;

                displacements[ n * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
                displacements[ n * 3 + 1 ] =  (Math.random() * 2 - 1) * radius;
                displacements[ n * 3 + 2 ] = (Math.random() * 2 - 1) * radius;

                values_color[ n * 3 + 0 ] = color2.r;
                values_color[ n * 3 + 1 ] = color2.g;
                values_color[ n * 3 + 2 ] = color2.b;
                
                size[n*3] = Math.random() * 10;

            }
        },
      
      
        changeEffect:function(effectNum){
            
            _effectNum = (effectNum || _effectNum +1) % 2 ;
            _particleSystem.material.uniforms['effectNum'].value = _effectNum;

        },
        
        // @param value from 0 to 100, 0 is nice weather, 100 is for storm
        // NO SNOWWWW
        setClimate: function(value){
            
            _effectIntensity = value;

            gfxEngine.setFarFog(2400 - _effectIntensity * 23.5);  
            gfxEngine.setIntensityEffect(_effectIntensity);
    
        },
        
        // @param value from 0 to 100, 0 is nice weather, 100 is for storm
        setClimateALLSAVEWITHSNOWANDRAIN: function(value){
            
            _effectIntensity = value;
            _particleSystem.material.uniforms['effectIntensity'].value = _effectIntensity;
            _particleSystemCloud.material.uniforms['effectIntensity'].value = _effectIntensity;
            
            //var newValue = value - 50;
            if(value<=50)
               this.setTimeStep(value/100.);
           else
               this.setTimeStep((value-50)/200);
           //this.setTimeStep(1.1 -(value/100));
            
            //gfxEngine.setFarFog(1050 - _effectIntensity * 10);
            gfxEngine.setFarFog(2400 - _effectIntensity * 23.5);  
            gfxEngine.setIntensityEffect(_effectIntensity);
            
            // SOUND
            if(Utils.snd2) Utils.snd2.volume = 1. - _effectIntensity/100.;
            if(Utils.snd2) Utils.snd.volume = _effectIntensity/100.;
            gfxEngine.setLensFlareIntensity(_effectIntensity);
            
        },
        
        setTimeStep: function(value){
            _time_step = value;
        },
        
       setEffectsClimateOn: function(b){
            
            gfxEngine.setEffectsClimateOn(b);
        },
        
        // RAIN AND SNOW WITH FOG AND SOUND
        setEffectsClimateOnSAVEWITHALLEFFECTS: function(b){
            
            
            if(!this.initiated){
               this.init();
               this.addToScene();
            }

            if(b){
                if (!this.initiated) this.init();
                this.addToScene();
                this.playRain("100431__2hear__rain-thunder-roll.mp3");
                this.playSummer("156894__ramston__spring-ambience-city-horizon-birds-light-traffic-car-01.mp3");
            }else{
                this.removeFromScene(); 
                this.stopCurrentMP3();
            }
            
            gfxEngine.setEffectsClimateOn(b);
        },
     
         // rain + thunder 100431__2hear__rain-thunder-roll
         playRain:function(mp3name){
          
            mp3name = mp3name || this.mp3Name;
            if(Utils.snd) Utils.snd.pause();    
            Utils.snd = new Audio('sounds/'+mp3name); // buffers automatically when created
            Utils.snd.loop = true;
            Utils.snd.play();
            Utils.snd.volume = 0.9;
            
         },
         
         // rain + thunder 100431__2hear__rain-thunder-roll
         playSummer:function(mp3name){
          
            mp3name = mp3name || this.mp3Name;
            if(Utils.snd2) Utils.snd2.pause();    
            Utils.snd2 = new Audio('sounds/'+mp3name); // buffers automatically when created
            Utils.snd2.loop = true;
            Utils.snd2.play();
            Utils.snd2.volume = 0.1;
         },
         
         
         stopCurrentMP3: function(){
            if(Utils.snd)  Utils.snd.pause();
            if(Utils.snd2) Utils.snd2.pause();
         }
      
        
        
    };
    
    return WeatherEffects;
            
    }
            
);
/* 
 * Spherical Panoramic viewer using equirectangular images
 */




    define ('SphericalPanoramic',['GraphicEngine','jquery', 'Config', 'lib/three','Utils','Ori','TileTexture','Draw','CVML','Cartography'],
        function(gfxEngine, $, Config, THREE, Utils, Ori, TileTexture, Draw, CVML) {
            
            
            
           var _geometry,
               _material,
               _mesh;
            
            
           var SphericalPanoramic ={
            
                init: function(imgName){

                    imgName = imgName || 'http://www.itowns.fr/nokiaHere/images/pano1.jpg';
                    _geometry = new THREE.SphereGeometry( 500,32,32);// 60, 40 );
                    //_geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );

                    _material = new THREE.MeshBasicMaterial( {
                            map: THREE.ImageUtils.loadTexture( imgName )
                    } );
                    
                    _material.side = THREE.DoubleSide;

                    _mesh = new THREE.Mesh( _geometry, _material );
             //       _mesh.rotation.y = -Math.PI/2;  // To get center of pano at north (heading:0Â°)

                    gfxEngine.addToScene( _mesh );
                },


                setEquirectangularImage: function(imgURL){
                    
                    _material.map = THREE.ImageUtils.loadTexture( imgURL );
                        
                },
                
                
                setOrientation: function(ori){
                    
                },
                
                
                setHeading: function(val){
                    
                    _mesh.rotation.y = val/180 * Math.PI - Math.PI/2;
                },
                
                
                setPitch: function(val){
                    
                    _mesh.rotation.x = val/180 * Math.PI ;
                },
                
                setRoll: function(val){
                    
                    _mesh.rotation.z = val/180 * Math.PI ;
                },
                
                                // Trick for spherical texturing (-Math.PI/2)
                computeSpecificMatOriFromHeadingPitchRoll: function(heading,pitch,roll){

                      heading = parseFloat(heading) / 180 * Math.PI - Math.PI/2 - 0.025;  // Deg to Rad // Axe Y
                      pitch   = parseFloat(pitch)   / 180 * Math.PI ;  // Deg to Rad // axe X
                      roll    = parseFloat(roll)    / 180 * Math.PI ;  // Deg to Rad   // axe Z
                         console.log("heading,pitch,roll ",heading,pitch,roll );
                      // With quaternion  //set rotation.order to "YXZ", which is equivalent to "heading, pitch, and roll"
                      var q = new THREE.Quaternion();
                      //q.setFromEuler(new THREE.Euler(heading,pitch,roll,'YXZ'),true);
                      q.setFromEuler(new THREE.Euler(roll,heading,pitch,'YXZ'),true);
                      var matTotale = new THREE.Matrix4().makeRotationFromQuaternion(q);//qRoll);//quater);
                      
                      _mesh.setRotationFromMatrix(matTotale);
                      
                      return matTotale;//.transpose(); //mat2 //matRotation;
                },
                
                
                // Trick for spherical texturing (-Math.PI/2)
                computeSpecificMatOriFromHeadingPitchRollSAVE: function(heading,pitch,roll){

                      heading = parseFloat(heading) / 180 * Math.PI - Math.PI/2;  // Deg to Rad // Axe Y
                      pitch = parseFloat(pitch)/ 180 * Math.PI ;  // Deg to Rad // axe X
                      roll = parseFloat(roll)/ 180 * Math.PI ;  // Deg to Rad   // axe Z

                      // With quaternion  //set rotation.order to "YXZ", which is equivalent to "heading, pitch, and roll"
                      var q = new THREE.Quaternion();
                      q.setFromEuler(new THREE.Euler(pitch,heading,roll,'YXZ'),true);
                      var matTotale = new THREE.Matrix4().makeRotationFromQuaternion(q);//qRoll);//quater);
                      
                      _mesh.setRotationFromMatrix(matTotale);
                      
                      return matTotale;//.transpose(); //mat2 //matRotation;
                },
                                     
            }

            return SphericalPanoramic;
            
        });
define ('Events',['Cartography', 'Navigation', 'GraphicEngine', 'LaserCloud','jquery', 'lib/three', 'Draw',
        'MeshManager','ProjectiveTexturing2','ProjectiveTexturingPhoto','Ori','Measure','Panoramic','lib/postprocessing/WeatherEffects',
        'Utils','SphericalPanoramic', 'Dispatcher'],
    function (Carto, Navigation, gfxEngine, LaserCloud , $, THREE, Draw, MeshManager, ProjectiveTexturing2, ProjectiveTexturingPhoto,Ori,
    Measure, Panoramic, WeatherEffects,  Utils, SphericalPanoramic, Dispatcher)
    {


        /**PRIVATE MEMBERS****************************************************************************************/

        // ATTRIBUTES

        //mouse properties

        var _mouseButtons = {
            0 : false,   //left
            1 : false,   //middle
            2 : false   //right
        };


        var _mouseLastXDown = null,
        _mouseLastYDown = null,
        _mouseSensitivity = null,
        _mouseX = null,
        _mouseY = null,
        _mouse3D = null,    // 3D position on mouse using raycasting
        _ClickAndGoActivated = true,
        _intersects = null,
        _keepMoving = false,
        _keepMovingFirstLaunched = false,
        _draging = false,
        _moveSpeed = 0.03,
        _pointLine1 = null,
        _pointLine2 = null,
        _lastPointLine2 = null,
        _tabPointsMesureX = [],
        _zero       = null,
        _textOpt    = {style :{fontSize:76}, delimiter :',', name :"geoLocation"},
        _light = new THREE.Vector3(0,0,0);

        var startSelection = null;
        var endSelection = null;
        var _screenshot = null;
        var _SELECTED = null;
        var _removeDrop = {68: false, 16: false};
        var _indice = null;
      

        function onDocumentMouseDown(event) {
            //event.stopPropagation();
           // event.originalEvent.preventDefault(); // hack to  remove text selection mouse cursor
            _mouseButtons[event.button] = true;

                _mouseX = event.clientX ;
                _mouseY = event.clientY ;

                _mouseLastXDown = event.clientX;
                _mouseLastYDown = event.clientY;

                onPointerDownPointerX = event.clientX;
                onPointerDownPointerY = event.clientY;

		var bDroit = (_mouseButtons[2] == true);
               // console.log("bDroit",bDroit);
                if(!event.ctrlKey &&(LaserCloud.btnSwitchPoint && event.button === 2) || (LaserCloud.btnSwitchPoint && event.shiftKey) ){

                    if(/*!$("#chbxSnappON").prop("checked")*/true) {
                            var zero = gfxEngine.getZero();
                            var pointLineMesureX = LaserCloud.getXYZFromClick2D(_mouseX,_mouseY);
                               _tabPointsMesureX.push(pointLineMesureX);
                               var id= Draw.drawSphereAt(pointLineMesureX,0.04,0xFAE361,true);  // Useradded = true
                            var realx = pointLineMesureX.x + parseFloat(zero.x),
                                realy = pointLineMesureX.y + parseFloat(zero.y),
                                realz = pointLineMesureX.z + parseFloat(zero.z);
                            var text = "E:"  +   realx.toFixed(2)  + ","
                                     + "N:"  +   realz.toFixed(2)  + ","
                                     + "h:"  +   realy.toFixed(2)  + ","
                                     + "id:" +  id;
                            var position = {x:pointLineMesureX.x,y:pointLineMesureX.y + 0.25,z:pointLineMesureX.z};
                                Draw.addTextPanel(text,position,_textOpt);

                                
                                Measure.setLastMeasure({x:realx,y:realy,z:realz});
                                Dispatcher.send("MEASURE");

                                  
                    }else{
                                LaserCloud.fitLineToNeighboursPointFromClick(_mouseX,_mouseY);
                    }
                }

                if((LaserCloud.btnSwitchLine && event.button === 2 && !event.shiftKey)
                                        ||(LaserCloud.btnSwitchLine && (event.button === 0) && event.shiftKey) ){    // Distance measurement
                        _pointLine1 = LaserCloud.getXYZFromClick2D(_mouseX,_mouseY);
                }


                if (!event.altKey){
                    // Draw boundingbox for 3D extraction
                    if(event.ctrlKey && event.button === 2){

                        if(!LaserCloud.btnSwitchVolume)
                             LaserCloud.estimateWidth(_mouseX,_mouseY,"Move");
                     }else

                     if(LaserCloud.btnSwitchVolume && (event.button === 2 || event.shiftKey)) {

                            if(Draw.tabBoundingBox.length == 0){
                                _pointLine1 = LaserCloud.getXYZFromClick2D(_mouseX,_mouseY);
                                //console.log(_pointLine1);
                                Draw.tabBoundingBox.push(_pointLine1);
                            }
                            else if (Draw.tabBoundingBox.length == 2 && !Draw.drawBB){  // We begin the width knowing the base and keeping parallelism
                                Draw.drawBB = true;
                            }
                            else if (Draw.drawBB == true){
                                Draw.drawBB2 = true;
                            }
                     }



                }
        }

        function onDocumentMouseUp(event) {
            
            //event.stopPropagation();
           // event.originalEvent.preventDefault();
            var bDroit = (_mouseButtons[2] == true);
            _mouseButtons[event.button] = false;

            if(Draw.drawBB2){
                Draw.BBCreated = false;
                Draw.drawBB2 = false;
                Draw.drawBB = false;
                Draw.tabBoundingBox = [];
                LaserCloud.checkAllPointsInBB(Draw.ptAtemp,Draw.ptBtemp,Draw.ptCtemp,Draw.ptDtemp,Draw.alphaBB,Draw.heightBB);  // Compute pointSelection within the bounding box
                Draw.ptAtemp.add(gfxEngine.getZeroAsVec3D());
                Draw.ptBtemp.add(gfxEngine.getZeroAsVec3D());
                Draw.ptCtemp.add(gfxEngine.getZeroAsVec3D());
                Draw.ptDtemp.add(gfxEngine.getZeroAsVec3D());
                if (false/*$("#connected").length==1*/)    // SAVE BB TO DB
                    LaserCloud.saveBBInputs(Draw.ptAtemp,Draw.ptBtemp,Draw.ptCtemp,Draw.ptDtemp, Draw.heightBB);
            }
            else{

                // If we are measuring in 3D and want to keep values drawn on screen
                if(LaserCloud.btnSwitchLine && !event.ctrlKey){
                    if(_pointLine1 !== null && _pointLine2 !== null){
                        if(_pointLine2.y !==-1 && _pointLine1.y!==-1 && _pointLine2.y && _pointLine1.y){  // Test de cohÃ©rence si point laser trouve
                            var dist = _pointLine1.distanceTo(_pointLine2).toFixed(2);
                            if(dist < 80){
                                Draw.drawOneMoreLine(_pointLine1,_pointLine2);
                                var pente = 100* Math.abs(_pointLine2.y - _pointLine1.y)/ Math.sqrt((_pointLine2.x - _pointLine1.x) * (_pointLine2.x - _pointLine1.x)
                                                                                                    +(_pointLine2.z - _pointLine1.z) * (_pointLine2.z - _pointLine1.z));
                                if(pente>200) pente = 200;
                                // We compute the distance between the 2 vertex
                                Draw.showTextAtPos3D(dist+"m "+pente.toFixed(1)+"%",_pointLine2/*gfxEngine.getPositionCloserToCam(pointLineMesure2,0.1)*/,40);

                                //draw on map
                                var zero = gfxEngine.getZero();
                                var p1 = new THREE.Vector3(_pointLine1.x + parseFloat(zero.x),
                                                           _pointLine1.y + parseFloat(zero.y),
                                                           _pointLine1.z + parseFloat(zero.z));
                                var p2 = new THREE.Vector3(_pointLine2.x + parseFloat(zero.x),
                                                           _pointLine2.y + parseFloat(zero.y),
                                                           _pointLine2.z + parseFloat(zero.z));

                                Carto.showLineMeasureOnMap(p1,p2,Carto.getLaserLayer(),"EPSG:2154",{ strokeWidth: 1.5,strokeColor: "#aaff0f" });
                                if (false/*$("#connected").length==1*/)    // SAVE LINE TO DB
                                    LaserCloud.saveLineInputs(_pointLine1.clone().add(gfxEngine.getZeroAsVec3D()),
                                                              _pointLine2.clone().add(gfxEngine.getZeroAsVec3D()));

                           }
                        }
                        _pointLine1 = null;
                        _pointLine2 = null;
                    }
                }

                mouseXOnMouseUp = event.clientX;
                mouseYOnMouseUp = event.clientY;

                
                if( MeshManager.getCurrentObject().name =="RGE" && !bDroit && mouseXOnMouseUp == _mouseX && mouseYOnMouseUp == _mouseY && !event.shiftKey){
                    
                 //   clickAndGo(Draw.getSurfaceType());  //clickAndGo("SkyToGround"); 
                    if(!Panoramic.getVisibility() /*&& !$("#checkbox2").prop("checked") && !$("#checkbox1").prop("checked")*/) {  // From aerial to terrestrial
                        if(Draw.getSurfaceType() == "Circle")
                             clickAndGo("SkyToGround"); 
                         else
                             clickAndGo(Draw.getSurfaceType()); 
                        gfxEngine.setBase3DGlasses(6);
                       /* $("#checkbox2").prop("checked", true);*/
                        Panoramic.tweenGeneralOpacityUp();
                        Panoramic.setVisibility(true);
                        MeshManager.setSkyBoxVisibility(false);
                    }else
                        clickAndGo(Draw.getSurfaceType()); 
                    //setTimeout(Panoramic.setVisibility, 1000);
                }
            }

                if(event.ctrlKey && event.button === 2 && !LaserCloud.btnSwitchVolume){

                        //TEMP PMR
                        //LaserCloud.estimateSlope(_mouseX,_mouseY);
                        LaserCloud.estimateWidth(mouseXOnMouseUp,mouseYOnMouseUp,"Stay");
                    }

            _draging = false;
        }

        function onDocumentMouseWheel( event ) {
     
            event.preventDefault();  // **Not mandatory here **
            console.log(event.originalEvent.wheelDelta, event.originalEvent.detail );
            var wheelData = event.originalEvent.wheelDelta/120;
            var isFireFox = (navigator.userAgent.indexOf('Firefox') != -1); 
            if(isFireFox) wheelData = - event.originalEvent.detail /3;
            gfxEngine.cameraZoom(-5*wheelData);
            
            Dispatcher.send("ZOOM");
            Draw.setSurfaceScaleAndOpacity(gfxEngine.getCameraFov()/120); //10-160
            // Draw.drawSurface(_mouse3D,_intersects[0].face.normal);

            // if there is a seleted object & shift is pressed, then resize object
            if (_SELECTED !== null && event.shiftKey) {

            	var border = 0.12; // inner css plane border
            	var wheel = event.originalEvent.wheelDeltaX/12000;

            	_SELECTED.fontPlane.scale.x += wheel;
            	_SELECTED.fontPlane.scale.y += wheel;

            	_SELECTED.cssPlane.scale.x += wheel - (wheel*border);
            	_SELECTED.cssPlane.scale.y += wheel - (wheel*border);

            }
        }


        function onDocumentMouseMove(event) {

            var _mouseX = event.clientX ;
            var _mouseY = event.clientY ;
            

            if ((_mouseButtons[0] === true) && !event.shiftKey) { //left mouse button pressed

                _draging = true;
                if(event.altKey){

                    //@todo Clean it
                    var difX =  (_mouseX - _mouseLastXDown)*_moveSpeed; // movespeed to set
                    var difY = -(_mouseY - _mouseLastYDown)*_moveSpeed;

                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(1,0,0),difX);		// On translate ds le repere camera
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(0,0,1),difY);
                    var translatX = gfxEngine.getCamera().position.x;					// On recup les nouvelles positions
                    var translatZ = gfxEngine.getCamera().position.z;
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(1,0,0),-difX);		// On remet en position initiale pour pouvoir tweener.
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(0,0,1),-difY);

                    gfxEngine.translateCameraSmoothly( translatX,gfxEngine.getTranslatCam().y,translatZ);
                }
                else {     // camera ROTATION

                   // var longitudeRot = ( _mouseLastXDown - event.clientX ) * _mouseSensitivity;
                    var angleCameraLat = gfxEngine.getAngleCameraLat();
                    var angleCameraLon = gfxEngine.getAngleCameraLon();

                    var angleCamLat = angleCameraLat + ( _mouseLastYDown - event.clientY ) * _mouseSensitivity;
                    var angleCamLon = angleCameraLon + ( _mouseLastXDown - event.clientX ) * _mouseSensitivity;
                    if (angleCamLat > -1.57 && angleCamLat < 1.57) angleCameraLat = angleCamLat;   // To avoid gumball effects
                    angleCameraLon = angleCamLon;

                    gfxEngine.setCameraLonLatAngle(angleCameraLon,angleCameraLat);

                    var targetDist = gfxEngine.getTargetDist();

                    var x = -targetDist * Math.sin(angleCameraLon);
                    var z = -targetDist * Math.cos(angleCameraLon);
                    var y =  targetDist * Math.tan(angleCameraLat);


                    gfxEngine.setWantedCamRotation(x,y,z);
                    // Send event
                    Dispatcher.send("ORIENTATION");

                    _mouseLastXDown = event.clientX;
                    _mouseLastYDown = event.clientY;

                   // Carto.rotatePositionMarker(angleCameraLon);
                }
            }else{

                

                //   ******   *CLICK & GO  ***** Test mouse over mesh bati for google style effect over facades and roads********
                if(  MeshManager.getCurrentObject().name =="RGE" && _ClickAndGoActivated && !event.ctrlKey){

                    //var mB = MeshManager.getCurrentObject();  // Get rge mesh or at least a road plane
                    var mB = MeshManager.getCurrentMeshForClickAndGo();
                    var mFES = MeshManager.getMeshFES();
                    _intersects = gfxEngine.getIntersected(event.clientX,event.clientY, [mB,mFES]);//gfxEngine.getScene().children);
                    if(_intersects[0]){
                        _mouse3D = new THREE.Vector3(_intersects[0].point.x,_intersects[0].point.y,_intersects[0].point.z);   // y+0.05 to put over mesh RGE to see clean
                        Draw.drawSurface(_mouse3D,_intersects[0].face.normal);                   //CLICKANDGO
                    }
                }
            }

            //laser measure
            if((LaserCloud.btnSwitchLine && event.button === 2 && !event.shiftKey)
                          || (LaserCloud.btnSwitchLine && (event.button === 0) && event.shiftKey) ){
                    _pointLine2 = LaserCloud.getXYZFromClick2D(_mouseX,_mouseY);

                    if(_pointLine2.y !==-1 && _pointLine1.y!==-1 && _pointLine2.y && _pointLine1.y){  // Test de coherence si point laser trouve
                            var dist = _pointLine1.distanceTo(_pointLine2).toFixed(2);
                            if(dist < 80){

                                  Draw.drawLine(_pointLine1,_pointLine2);
                                  // Pente in %
                                  var pente = 100 * Math.abs(_pointLine2.y - _pointLine1.y)/ Math.sqrt((_pointLine2.x - _pointLine1.x) * (_pointLine2.x - _pointLine1.x)
                                                                                                    +(_pointLine2.z - _pointLine1.z) * (_pointLine2.z - _pointLine1.z));
                                  if(pente>200) pente = 200;
                                    // We compute the distance between the 2 vertex
                                  Draw.showTextAtPos3DSameMesure(dist+"m "+pente.toFixed(1)+"%",_pointLine2/*gfxEngine.getPositionCloserToCam(pointLineMesure2,0.1)*/,40);
                                  _lastPointLine2 = _pointLine2;
                            }

                    } else{
                           if(_lastPointLine2!=null) _pointLine2 = _lastPointLine2;
                    }

             }

              //TEMP PMR
              if(event.ctrlKey && event.button === 2 && !LaserCloud.btnSwitchVolume){

                     //LaserCloud.estimateSlope(_mouseX,_mouseY);
                     LaserCloud.estimateWidth(_mouseX,_mouseY,"Move");
              }

             if((LaserCloud.btnSwitchVolume && event.button === 2) || (LaserCloud.btnSwitchVolume && event.shiftKey) )
             {
                    if(!Draw.drawBB){
                        if(Draw.tabBoundingBox.length == 1 ){
                            Draw.tabBoundingBox.push( LaserCloud.getXYZFromClick2D(_mouseX,_mouseY));
                        }else  if(Draw.tabBoundingBox.length == 2){
                            Draw.tabBoundingBox[1] = LaserCloud.getXYZFromClick2D(_mouseX,_mouseY);
                            Draw.drawBBTemp(Draw.tabBoundingBox[0],Draw.tabBoundingBox[1],Draw.tabBoundingBox[0],Draw.tabBoundingBox[1],0);
                        }
                        Draw.alphaBB = Math.atan2(Draw.tabBoundingBox[1].z - Draw.tabBoundingBox[0].z, Draw.tabBoundingBox[1].x - Draw.tabBoundingBox[0].x);
                    }
                    else if (!Draw.drawBB2) {
                        var d = (_mouseX - onPointerDownPointerX)/10;

                        var ptA = Draw.tabBoundingBox[0];
                        var ptB = Draw.tabBoundingBox[1];

                        var xc = ptA.x + Math.cos(Draw.alphaBB+1.57) * d;
                        var zc = ptA.z + Math.sin(Draw.alphaBB+1.57) * d;
                        var yc = ptA.y;
                        var ptC = new THREE.Vector3(xc,yc,zc);

                        var xd = ptB.x + Math.cos(Draw.alphaBB+1.57) * d;
                        var zd = ptB.z + Math.sin(Draw.alphaBB+1.57) * d;
                        var yd = ptB.y;
                        var ptD = new THREE.Vector3(xd,yd,zd);

                        Draw.ptAtemp = ptA;
                        Draw.ptBtemp = ptB;
                        Draw.ptCtemp = ptC;
                        Draw.ptDtemp = ptD;

                        Draw.drawBBTemp(ptA,ptB,ptC,ptD,0);
                    }
                    else
                    {
                        Draw.heightBB = (onPointerDownPointerY - _mouseY)/10;
                        Draw.drawBBTemp(Draw.ptAtemp,Draw.ptBtemp,Draw.ptCtemp,Draw.ptDtemp,Draw.heightBB);
                    }
              }

           

            // TRANSLATE ON RIGHT MOUSE
            if(!event.ctrlKey && !event.altKey && event.button === 2 && !LaserCloud.btnSwitchVolume && ! LaserCloud.btnSwitchLine ){

                    //@todo Clean it
                    var difX =  -(_mouseX - _mouseLastXDown)*_moveSpeed *2* gfxEngine.getCamera().position.y/10; // movespeed to set
                    var difY =   (_mouseY - _mouseLastYDown)*_moveSpeed *6* gfxEngine.getCamera().position.y/10;

                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(1,0,0),difX);		// On translate ds le repere camera
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(0,0,1),difY);
                    var translatX = gfxEngine.getCamera().position.x;					// On recup les nouvelles positions
                    var translatZ = gfxEngine.getCamera().position.z;
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(1,0,0),-difX);		// On remet en position initiale pour pouvoir tweener.
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(0,0,1),-difY);

                    gfxEngine.translateCameraSmoothly( translatX,gfxEngine.getTranslatCam().y,translatZ);
            }


        };


        function OnDocumentKeyDown(event) {
            
            console.log("key Down");
            
            switch (event.keyCode){
                
                case 38: gfxEngine.getTranslatCam().y += 1 * _moveSpeed*33; break;
                case 40: gfxEngine.getTranslatCam().y -= 1 * _moveSpeed*33; break;
                //case 37: Navigation.loadNextPanoByName(Panoramic.getPanoNameAtIndice(1));
                //case 39: Navigation.loadNextPanoByName(Panoramic.getPanoNameAtIndice(-1));
            }
                        
        };

        //@TODO Move to navigation
        function clickAndGo(surfaceType){

        	// if css object loaded, start to detect their distances
        	// fontPlane needed to be activated on computing distance
        	

    		var posWantedLamb93 = _mouse3D.clone().add(gfxEngine.getZeroAsVec3D());
       		Navigation.goToClosestPosition(posWantedLamb93,{intersectionToLook:_mouse3D.clone(),surfaceType:surfaceType, distance:30});

        };



        /*********************************************************************************************************/

        /**
     * Manages mouse and keyboard event
     * @export Events
     */
        var Events = {
            init : function (initialInfo, initialPano, mouseSensitivity, moveSpeed) {


                //console.log('************ initializing event module');
                var $viewerContainer = $(gfxEngine.getContainerID());
                
                $($viewerContainer).mousedown(onDocumentMouseDown);
                $($viewerContainer).mousemove(onDocumentMouseMove);
                $($viewerContainer).mouseup(onDocumentMouseUp);
                $($viewerContainer).bind('mousewheel onwheel DOMMouseScroll ',onDocumentMouseWheel);
                $($viewerContainer).bind("contextmenu",function(e){
                        return false;
                });

                //$($viewerContainer).keyup(OnDocumentKeyUp);
                 $($viewerContainer).keydown(OnDocumentKeyDown);

                _mouseSensitivity = mouseSensitivity || 0.002;
                _moveSpeed = moveSpeed || _moveSpeed;

                _zero = gfxEngine.getZero();


                // SOCKET IO *********************************************************************
                // *******************************************************************************
                if(gfxEngine.getNodeControllerOn()){

                    _socketIO = io.connect("http://labuat.homepc.it:8088");
                    _socketIO.on('user message', message);
                }
                  function message (from, msg) {

                        /*var LR = eventData.gamma;
                          var FB = eventData.beta;
                          var DIR = eventData.alpha;*/
                     if(!_keepMovingFirstLaunched){_keepMovingFirstLaunched = true; Events.moveTowardDirection();}
                     Events.deviceOrientationHandler(msg.LR,msg.FB, msg.DIR);
                  }


              // Added for mobile
              if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {

                    console.log("You're on a mobile");
                  if (window.DeviceOrientationEvent) {
                      console.log("DeviceOrientation is supported");
                      window.addEventListener('deviceorientation', function(eventData) {
                                    var LR = eventData.gamma;
                                    var FB = eventData.beta;
                                    var DIR = eventData.alpha;
                                    Events.deviceOrientationHandlerSAVE(LR, FB, DIR);
                            }, false);
                    }
                }
            },


             deviceOrientationHandler: function(LR, FB, DIR){

					//console.log(LR,FB);

                 	// Check orientation, portrait/ landscape
		            /*        if(window.innerWidth > window.innerHeight && window.innerWidth<1200){   // to filter tablet with ortho accero compare to mobile
		                       var tempLR = LR;
		                       LR = FB;
		                       FB = - tempLR ;
		                   }
		            */

		            if(LR !=777){  //ROTATION

                                if(Math.abs(LR)<5) LR = 0;  // STABILIZE
                                if(Math.abs((FB))<5) FB = 0;


                                // var longitudeRot = ( _mouseLastXDown - event.clientX ) * _mouseSensitivity;
                                var angleCameraLat = gfxEngine.getAngleCameraLat();
                                var angleCameraLon = gfxEngine.getAngleCameraLon();

                                var angleCamLat = angleCameraLat - ( (FB)/180 * Math.PI *2 ) * _mouseSensitivity *27;
                                var angleCamLon = angleCameraLon + ( (LR)/360 * Math.PI *2)  * _mouseSensitivity*75;
                                if (angleCamLat > -1.57 && angleCamLat < 1.57) angleCameraLat = angleCamLat;   // To avoid gumball effects
                                angleCameraLon = angleCamLon;

                                gfxEngine.setCameraLonLatAngle(angleCameraLon,angleCameraLat);

                                var targetDist = gfxEngine.getTargetDist();

                                var x = -targetDist * Math.sin(angleCameraLon);
                                var z = -targetDist * Math.cos(angleCameraLon);
                                var y =  targetDist * Math.tan(angleCameraLat);


                                gfxEngine.setWantedCamRotation(x,y,z);
                                //gfxEngine.tiltCamera(angleCamLat);

                                //_mouseLastXDown = event.clientX;
                                //_mouseLastYDown = event.clientY;

                                Carto.rotatePositionMarker(angleCameraLon);

                                _keepMoving = DIR;



		            }
                  
            },

           moveTowardDirection: function(){

               if(_keepMoving){
                    var speed = 14;
                    var difX =  0;//-(_mouseX - _mouseLastXDown)*_moveSpeed *8; // movespeed to set
                    var difY =  speed;//(_mouseY - _mouseLastYDown)*_moveSpeed *6;
                    var difYY = speed;

                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(1,0,0),difX);		// On translate ds le repere camera
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(0,0,1),difY);
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(0,1,0),difYY);
                    var translatX = gfxEngine.getCamera().position.x;					// On recup les nouvelles positions
                    var translatZ = gfxEngine.getCamera().position.z;
                    var translatY = gfxEngine.getCamera().position.y;
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(1,0,0),-difX);		// On remet en position initiale pour pouvoir tweener.
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(0,0,1),-difY);
                    gfxEngine.getCamera().translateOnAxis(new THREE.Vector3(0,1,0),-difYY);

                    gfxEngine.translateCameraSmoothly( translatX,translatY,translatZ);

                }

                requestAnimSelectionAlpha(this.moveTowardDirection.bind(this));
           },

           deviceOrientationHandlerSAVE: function(LR, FB, DIR){

                 // Check orientation, portrait/ landscape
                    if(window.innerWidth > window.innerHeight && window.innerWidth<1200){   // to filter tablet with ortho accero compare to mobile
                       var tempLR = LR;
                       LR = FB;
                       FB = - tempLR ;
                   }

                    if(Math.abs(LR+4) <5) LR = -4;
                    if(Math.abs((54-FB))<5) FB = 54;


                 // var longitudeRot = ( _mouseLastXDown - event.clientX ) * _mouseSensitivity;
                    var angleCameraLat = gfxEngine.getAngleCameraLat();
                    var angleCameraLon = gfxEngine.getAngleCameraLon();

                    var angleCamLat = angleCameraLat + ( (54-FB)/180 * Math.PI *2 ) * _mouseSensitivity *18;
                    var angleCamLon = angleCameraLon + ( (LR+4)/360 * Math.PI *2) * _mouseSensitivity*50;
                    if (angleCamLat > -1.57 && angleCamLat < 1.57) angleCameraLat = angleCamLat;   // To avoid gumball effects
                    angleCameraLon = angleCamLon;

                    gfxEngine.setCameraLonLatAngle(angleCameraLon,angleCameraLat);

                    var targetDist = gfxEngine.getTargetDist();

                    var x = -targetDist * Math.sin(angleCameraLon);
                    var z = -targetDist * Math.cos(angleCameraLon);
                    var y =  targetDist * Math.tan(angleCameraLat);


                    gfxEngine.setWantedCamRotation(x,y,z);

                    _mouseLastXDown = event.clientX;
                    _mouseLastYDown = event.clientY;

                    Carto.rotatePositionMarker(angleCameraLon);
            },

            setSensitivy : function (sensitivity){
                _mouseSensitivity = sensitivity;
            },

            setMoveSpeed : function (speed){
                _moveSpeed = speed;
            },

            setPointLineMesure : function(pt1,pt2){
                 _pointLine1 = pt1;
                 _pointLine2 = pt2;
            },
/*
            hideMenuAll: function(){

                var hidden = $("#sidebar")[0].hidden;
                $("#sidebar")[0].hidden = !hidden;
                $("#search")[0].hidden = !hidden;
                $("#localisation")[0].hidden = !hidden;
                $("#sponsors")[0].hidden = !hidden;
                $("#up")[0].hidden = !hidden;
            },
           */ 
            playWithLight: function(){
               
                if(_light.x <1){
                    _light.x +=0.01;
                    _light.z +=0.02;}
                else {
                    _light.x =0;
                    _light.z =0;
                }
             //   _light.x +=0.01;
            //    _light.z +=0.01;
                
                require("Cartography3D").setLightPosition( _light);//.normalize());
                requestAnimSelectionAlpha(this.playWithLight.bind(this));
            }

        }

        return Events;
    });
requirejs.config({
    baseUrl: 'src/',
    paths : {
        'geoportail' : "http://api.ign.fr/geoportail/api/js/2.0.3/Geoportal",
        'jquery' : "//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min"      
    },

    waitSeconds : 0
});

var allInitialized = false;   // GLOBAL PARAMETER TO USE IN API SCRIPT TO BE SURE ASYNCHRONE LOAD OF METADATA (FROM DB ETC) IS DONE

requirejs([ 'API','GraphicEngine', 'RequestManager','Events'],
    function(API,  GraphicEngine, RequestManager , Events )
    {

        GraphicEngine.init('containerITOWNS');
        GraphicEngine.render();
        Events.init();
        allInitialized = true;    
    });
define("app", function(){});

